[{"path":"https://cmu-delphi.github.io/epipredict/dev/DEVELOPMENT.html","id":"setting-up-the-development-environment","dir":"","previous_headings":"","what":"Setting up the development environment","title":"NA","text":"","code":"install.packages(c('devtools', 'pkgdown', 'styler', 'lintr', 'pak')) # install dev dependencies pak::pkg_install(\".\") # install package and dependencies"},{"path":"https://cmu-delphi.github.io/epipredict/dev/DEVELOPMENT.html","id":"validating-the-package","dir":"","previous_headings":"","what":"Validating the package","title":"NA","text":"","code":"styler::style_pkg() # format code lintr::lint_package() # lint code  devtools::check() # run R CMD check, which runs everything below devtools::document() # generate package meta data and man files devtools::test() # test package devtools::build_vignettes() # build vignettes only devtools::run_examples() # run doc examples devtools::check(vignettes = FALSE) # check package without vignettes"},{"path":"https://cmu-delphi.github.io/epipredict/dev/DEVELOPMENT.html","id":"developing-the-documentation-site","dir":"","previous_headings":"","what":"Developing the documentation site","title":"NA","text":"CI builds two versions documentation: https://cmu-delphi.github.io/epipredict/ main branch https://cmu-delphi.github.io/epipredict/dev dev branch. Commands developing documentation site: Note sometimes caches either pkgdown knitr can cause difficulties. clear , run make, either clean_knitr, clean_site, clean (). work without R Studio want iterate documentation, might find Rscript pkgdown-watch.R useful. helpful. updating references, need manually call pkgdown::build_reference().","code":"# Basic build and preview R -e 'pkgdown::clean_site()' R -e 'devtools::document()' R -e 'pkgdown::build_site()'"},{"path":"https://cmu-delphi.github.io/epipredict/dev/DEVELOPMENT.html","id":"versioning","dir":"","previous_headings":"","what":"Versioning","title":"NA","text":"Please follow guidelines PR template document.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/DEVELOPMENT.html","id":"planned-cran-release-process","dir":"","previous_headings":"","what":"Planned CRAN release process","title":"NA","text":"Open release issue copy follow checklist issue (modified checklist generated usethis::use_release_issue(version = \"1.0.2\")): git pull dev branch. Make sure changes committed pushed. Check current CRAN check results. Aim 10/10, notes. check works well enough, merge main. Otherwise open PR fix . guidelines. git checkout main git pull may choke MIT license url, ‚Äôs ok. devtools::build_readme() devtools::check_win_devel() maintainer (‚Äúcre‚Äù description) check email problems. may choke, sensitive binary versions packages given system. Either bypass ask someone else run ‚Äôre concerned. Update cran-comments.md PR changes (go list ) dev run list . Submit CRAN: devtools::submit_cran(). Maintainer approves email. Wait CRAN‚Ä¶ accepted üéâ, move next steps. rejected, fix resubmit. Open merge PR containing updates made main back dev. usethis::use_github_release(publish = FALSE) (publish , otherwise won‚Äôt push) create draft release based commit hash CRAN-SUBMISSION push tag GitHub repo. Go repo, verify release notes, publish ready.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 epipredict authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/backtesting.html","id":"getting-case-data-from-us-states-into-an-epi_archive","dir":"Articles","previous_headings":"","what":"Getting case data from US states into an epi_archive","title":"Accurately backtesting forecasters","text":"First, create epi_archive() store version history percentage doctor‚Äôs visits CLI (COVID-like illness) computed medical insurance claims number new confirmed COVID-19 cases per 100,000 population (daily) 4 states data can also fetched Delphi Epidata API following query: interest computational speed, limit dataset 4 states 2020‚Äì2021, full archive can used way performed well past. choose dataset particular partly revision heavy; example, plot compares monthly snapshots data.  snapshots taken first month, vertical dashed line representing issue date time series corresponding color. example, snapshot March 1st, 2021 aquamarine, increases slightly 10. Every series necessarily left snapshot date (since known values must happen snapshot taken1). black line overlaying various snapshots represents ‚Äúfinal value‚Äù, just snapshot last version archive (versions_end). Comparing black line tells us much value time snapshot differs eventually reported. drop January 2021 snapshot 2021-02-01 initially reported much steeper eventually turned , period values initially reported higher actually . Handling data latency important real-time forecasting retrospective forecasting. Looking first snapshot, 2020-08-01 (purple dotted vertical line), noticeable gap forecast date end red time-series left. fact, take snapshot get last time_value, last day data 25th, entire week 2020-08-01. can require effort work around, especially latency variable; see step_adjust_latency() methods included package. Much functionality built arx_forecaster() using parameter adjust_ahead, use .","code":"# Setup library(epipredict) library(epiprocess) library(epidatr) library(data.table) library(dplyr) library(tidyr) library(ggplot2) library(magrittr) library(purrr) library(lubridate) # Select the `percent_cli` column from the data archive doctor_visits <- archive_cases_dv_subset$DT |>   select(geo_value, time_value, version, percent_cli) |>   tidyr::drop_na(percent_cli) |>   as_epi_archive(compactify = TRUE) library(epidatr) doctor_visits <- pub_covidcast(   source = \"doctor-visits\",   signals = \"smoothed_adj_cli\",   geo_type = \"state\",   time_type = \"day\",   geo_values = \"ca,fl,ny,tx\",   time_values = epirange(20200601, 20211201),   issues = epirange(20200601, 20211201) ) |>   # The version date column is called `issue` in the Epidata API. Rename it.   select(version = issue, geo_value, time_value, percent_cli = value) |>   as_epi_archive(compactify = TRUE) geo_choose <- \"ca\" forecast_dates <- seq(   from = as.Date(\"2020-08-01\"),   to = as.Date(\"2021-11-01\"),   by = \"1 month\") percent_cli_data <- bind_rows(   # Snapshotted data for the version-faithful forecasts   map(     forecast_dates,     ~ doctor_visits |>       epix_as_of(.x) |>       mutate(version = .x)   ) |>     bind_rows() |>     mutate(version_faithful = \"Version faithful\"),   # Latest data for the version-un-faithful forecasts   doctor_visits |>     epix_as_of(doctor_visits$versions_end) |>     mutate(version_faithful = \"Version un-faithful\") ) |> as_tibble() p0 <- autoplot(   archive_cases_dv_subset, percent_cli,    .versions = forecast_dates,    .mark_versions = TRUE,   .facet_filter = (geo_value == \"ca\") ) +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %Y\") +   labs(x = \"\", y = \"% of doctor's visits with\\n Covid-like illness\") +    scale_color_viridis_c(     option = \"viridis\",     guide = guide_legend(reverse=TRUE), direction = -1) +   scale_y_continuous(limits = c(0, NA), expand = expansion(c(0, 0.05))) +   theme(legend.position = \"none\") doctor_visits |>   epix_as_of(as.Date(\"2020-08-01\")) |>   pull(time_value) |>   max() #> [1] \"2020-07-25\""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/backtesting.html","id":"backtesting-a-simple-autoregressive-forecaster","dir":"Articles","previous_headings":"","what":"Backtesting a simple autoregressive forecaster","title":"Accurately backtesting forecasters","text":"addition outlier detection nowcasting, common use case epiprocess::epi_archive() object accurate model back-testing. start, let‚Äôs use simple autoregressive forecaster predict percent_cli, percentage doctor‚Äôs hospital visits associated COVID-like illness, 14 days future. increased accuracy use quantile regression.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/backtesting.html","id":"comparing-a-single-day-and-ahead","dir":"Articles","previous_headings":"Backtesting a simple autoregressive forecaster","what":"Comparing a single day and ahead","title":"Accurately backtesting forecasters","text":"sanity check backtest entire dataset, let‚Äôs forecast single day middle dataset. can setting .versions argument epix_slide(): need truth data compare forecast . can construct using epix_as_of() snapshot archive last available date2. Note: always want compare forecasts actual (recently reported) values outcome care . as_of data useful understanding ‚Äôre getting forecasts ‚Äôre getting, as_of values preliminary outcomes. Therefore, ‚Äôs meaningful use evaluating performance forecast. Unfortunately, ‚Äôs uncommon revisions cause poor (final) performance forecaster decent time forecast. .pred corresponds point forecast (median), 0.05 0.95 correspond 5th 95th quantiles. percent_cli truth data falls within prediction intervals, implementation passes simple validation.","code":"forecast_date <- as.Date(\"2021-04-06\") forecasts <- doctor_visits |>   epix_slide(     ~ arx_forecaster(       .x,       outcome = \"percent_cli\",       predictors = \"percent_cli\",       args_list = arx_args_list()     )$predictions |>       pivot_quantiles_wider(.pred_distn),     .versions = forecast_date   ) forecasts |>   inner_join(     doctor_visits |>       epix_as_of(doctor_visits$versions_end),     by = c(\"geo_value\", \"target_date\" = \"time_value\")   ) |>   select(geo_value, forecast_date, .pred, `0.05`, `0.95`, percent_cli) #> # A tibble: 4 √ó 6 #>   geo_value forecast_date .pred `0.05` `0.95` percent_cli #>   <chr>     <date>        <dbl>  <dbl>  <dbl>       <dbl> #> 1 ca        2021-04-03     6.79  2.63   11.0         4.06 #> 2 fl        2021-04-03     7.40  3.23   11.6         5.10 #> 3 ny        2021-04-03     8.05  3.88   12.2         6.92 #> 4 tx        2021-04-03     5.00  0.836   9.17        3.25"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/backtesting.html","id":"comparing-version-faithful-and-version-un-faithful-forecasts","dir":"Articles","previous_headings":"Backtesting a simple autoregressive forecaster","what":"Comparing version faithful and version un-faithful forecasts","title":"Accurately backtesting forecasters","text":"Now let‚Äôs compare behavior forecaster, properly considering data versioning (‚Äúversion faithful‚Äù) ignoring data versions (‚Äúversion un-faithful‚Äù). version un-faithful approach, need setup want use epix_slide backtesting. want simulate data set receives finalized updates every day, , data set revisions. , snapshot latest version data create synthetic data set, convert archive version = time_value3. version faithful approach, continue using original epi_archive object containing version updates. also create helper function forecast_wrapper() let us easily map across aheads. Note: helper function, ‚Äôre using parameter adjust_latency. need use recently released data may still several days old given forecast date (lag > 0); adjust_latency modify forecaster compensate4. See function step_adjust_latency() details examples. Now ‚Äôre set , can generate forecasts version faithful un-faithful archives, bind results together. arx_forecaster() heavy lifting. creates lags copies features (, response doctors visits), creates leads copies target respecting timestamps locations, fits forecasting model using specified engine, creates predictions, creates non-parametric confidence bands. see version faithful un-faithful predictions compare, let‚Äôs plot top latest case rates, using versioned plotting method . Note even though fit model four states (California, Texas, Florida, New York), ‚Äôll just display results two states, California (CA) Florida (FL), get sense model performance keeping graphic simpler.  weeks forecasts somewhat similar, others wildly different, although neither approach produces amazingly accurate forecasts. version faithful case California, March 2021 forecast (turquoise) starts value just 10, well lined reported values leading forecast. measured forecasted trends also concordant (increasingly moderately fast). data time period later adjusted decreasing trend, March 2021 forecast looks quite bad compared finalized data. equivalent version un-faithful forecast starts value 5, line finalized data place compared version data. October 2021 forecast version faithful case floors zero, whereas un-faithful much closer finalized data.  Now let‚Äôs look Florida. version faithful case, three late-2021 forecasts (purples pinks) starting September predict low values, near 0. trend leading forecast shows substantial decrease, forecasts seem appropriate expect score fairly well various performance metrics compared versioned data. However hindsight, know early versions data systematically -reported COVID-related doctor visits forecasts don‚Äôt actually perform well compared finalized data. example, version faithful forecasts predicted values near 0 finalized data shows values 5-10 range. result, version un-faithful forecasts dates quite bit higher, perform well scored using finalized data poorly versioned data. general, longer ago forecast made, worse performance compared finalized data. Finalized data accumulates revisions time make deviate non-finalized data model trained . Forecasts trained finalized data course appear perform better scored finalized data, unknown performance non-finalized data need use want timely predictions. Without using data available actual forecast date, little insight level performance can expect practice. Good performance version un-faithful model mirage; achievable training data revisions. data source revisions, version un-faithful-level performance unachievable making forecasts real time.","code":"archive_cases_dv_subset_faux <- doctor_visits |>   epix_as_of(doctor_visits$versions_end) |>   mutate(version = time_value) |>   as_epi_archive() forecast_wrapper <- function(     epi_data, aheads, outcome, predictors, process_data = identity     ) {   map(     aheads,     \\(ahead) {       arx_forecaster(         process_data(epi_data), outcome, predictors,         args_list = arx_args_list(           ahead = ahead,           lags = c(0:7, 14, 21),           adjust_latency = \"extend_ahead\"         )       )$predictions |> pivot_quantiles_wider(.pred_distn)     }   ) |> bind_rows() } forecast_dates <- seq(   from = as.Date(\"2020-09-01\"),   to = as.Date(\"2021-11-01\"),   by = \"1 month\" ) aheads <- c(1, 7, 14, 21, 28)  version_unfaithful <- archive_cases_dv_subset_faux |>   epix_slide(     ~ forecast_wrapper(.x, aheads, \"percent_cli\", \"percent_cli\"),     .before = 120,     .versions = forecast_dates   ) |>   mutate(version_faithful = \"Version un-faithful\")  version_faithful <- doctor_visits |>   epix_slide(     ~ forecast_wrapper(.x, aheads, \"percent_cli\", \"percent_cli\"),     .before = 120,     .versions = forecast_dates   ) |>   mutate(version_faithful = \"Version faithful\")  forecasts <-   bind_rows(     version_unfaithful,     version_faithful   ) geo_choose <- \"ca\" forecasts_filtered <- forecasts |>   filter(geo_value == geo_choose) |>   mutate(time_value = version) # we need to add the ground truth data to the version faithful plot as well plotting_data <- bind_rows(   percent_cli_data,   percent_cli_data |>     filter(version_faithful == \"Version un-faithful\") |>     mutate(version = max(percent_cli_data$version)) |>     mutate(version_faithful = \"Version faithful\") )  p1 <- ggplot(data = forecasts_filtered,              aes(x = target_date, group = time_value)) +   geom_ribbon(     aes(ymin = `0.05`, ymax = `0.95`, fill = (time_value)),     alpha = 0.4) +   geom_line(aes(y = .pred, color = (time_value)), linetype = 2L) +   geom_point(aes(y = .pred, color = (time_value)), size = 0.75) +   # the forecast date   geom_vline(     data = percent_cli_data |>       filter(geo_value == geo_choose) |>       select(-version_faithful),     aes(color = version, xintercept = version, group = version),     lty = 2   ) +   # the underlying data   geom_line(     data = plotting_data |> filter(geo_value == geo_choose),     aes(x = time_value, y = percent_cli, color = (version), group = version),     inherit.aes = FALSE, na.rm = TRUE   ) +   facet_grid(version_faithful ~ geo_value, scales = \"free\") +   scale_x_date(breaks = \"2 months\", date_labels = \"%b %Y\") +   scale_y_continuous(expand = expansion(c(0, 0.05))) +   labs(x = \"Date\",        y = \"smoothed, day of week adjusted covid-like doctors visits\") +   scale_color_viridis_c(option = \"viridis\", direction = -1) +   scale_fill_viridis_c(option = \"viridis\", direction = -1) +   theme(legend.position = \"none\") geo_choose <- \"fl\" forecasts_filtered <- forecasts |>   filter(geo_value == geo_choose) |>   mutate(time_value = version)  forecasts_filtered %>% names #>  [1] \"version\"          \"geo_value\"        \".pred\"            #>  [4] \"forecast_date\"    \"target_date\"      \"0.05\"             #>  [7] \"0.1\"              \"0.25\"             \"0.5\"              #> [10] \"0.75\"             \"0.9\"              \"0.95\"             #> [13] \"version_faithful\" \"time_value\" p2 <-   ggplot(data = forecasts_filtered, aes(x = target_date, group = time_value)) +   geom_ribbon(aes(ymin = `0.05`, ymax = `0.95`, fill = (time_value)), alpha = 0.4) +   geom_line(aes(y = .pred, color = (time_value)), linetype = 2L) +   geom_point(aes(y = .pred, color = (time_value)), size = 0.75) +   # the forecast date   geom_vline(     data = percent_cli_data |> filter(geo_value == geo_choose) |> select(-version_faithful),     aes(color = version, xintercept = version, group = version),     lty = 2   ) +   # the underlying data   geom_line(     data = plotting_data |> filter(geo_value == geo_choose),     aes(x = time_value, y = percent_cli, color = (version), group = version),     inherit.aes = FALSE, na.rm = TRUE   ) +   facet_grid(version_faithful ~ geo_value, scales = \"free\") +   scale_x_date(breaks = \"2 months\", date_labels = \"%b %Y\") +   scale_y_continuous(expand = expansion(c(0, 0.05))) +   labs(x = \"Date\", y = \"smoothed, day of week adjusted covid-like doctors visits\") +   scale_color_viridis_c(option = \"viridis\", direction = -1) +   scale_fill_viridis_c(option = \"viridis\", direction = -1) +   theme(legend.position = \"none\") p2"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/custom_epiworkflows.html","id":"anatomy-of-an-epi_workflow","dir":"Articles","previous_headings":"","what":"Anatomy of an epi_workflow","title":"Custom Epiworkflows","text":"epi_workflow() extension workflows::workflow() specially designed handle panel data, apply custom post-processing steps output model. epi_workflows, including simple canned workflows, consist 3 components, preprocessor, trainer, postprocessor.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/custom_epiworkflows.html","id":"preprocessor","dir":"Articles","previous_headings":"Anatomy of an epi_workflow","what":"Preprocessor","title":"Custom Epiworkflows","text":"preprocessor (context epipredict means {recipe}) transforms data model training prediction. Transformations can include converting counts rates, applying running average columns, steps found {recipes}. workflows must include preprocessor. basic preprocessor just assigns roles columns, telling model next step use predictors outcome. However, preprocessors can much . can think preprocessor flexible formula pass lm(): y ~ x1 + log(x2) + lag(x1, 5). simple model internally runs 6 steps, creating lagged predictor columns. general, 2 broad classes transformation recipes steps handle: Operations applied training test data without using stored information. Examples include taking log variable, leading lagging columns, filtering rows, handling dummy variables, calculating growth rates, etc. Operations rely stored information (parameters estimated training) modify train test data. Examples include centering mean, normalizing variance one (whitening). differentiate types transformations second type can result information leakage done properly. Information leakage data leakage happens system access information available prediction time change evaluation model‚Äôs real-world performance. case centering, need store mean predictor training data use value prediction data, rather using mean test predictor centering including test data mean calculation. major benefit recipes prevents information leakage. However, main mechanism rely prevent data leakage context epidemiological forecasting proper backtesting.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/custom_epiworkflows.html","id":"trainer","dir":"Articles","previous_headings":"Anatomy of an epi_workflow","what":"Trainer","title":"Custom Epiworkflows","text":"trainer (aso called model engine) fits parsnip model training data, outputs fitted model object. Examples include linear regression, quantile regression, {parsnip} engine. parsnip front-end abstracts away differences interface wide collection statistical models. workflows must include model.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/custom_epiworkflows.html","id":"postprocessor","dir":"Articles","previous_headings":"Anatomy of an epi_workflow","what":"Postprocessor","title":"Custom Epiworkflows","text":"Generally postprocessor modifies formats prediction model fit. epipredict postprocessor called frosting(); alternatives tailor performs calibration. postprocessor optional. needs included workflow need process model output. operation within postprocessor called ‚Äúlayer‚Äù (functions named layer_*), stack layers known frosting(), continuing metaphor baking cake established recipes. example operations include: generating quantiles purely point-prediction models reverting transformations done prior steps, converting rates back counts thresholding forecasts remove negative values generally adapting format prediction downstream use.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/custom_epiworkflows.html","id":"recreating-four_week_ahead-in-an-epi_workflow","dir":"Articles","previous_headings":"","what":"Recreating four_week_ahead in an epi_workflow()","title":"Custom Epiworkflows","text":"understand create custom workflows, let‚Äôs first recreate simple canned arx_forecaster() scratch. ‚Äôll think following sub-steps: Define epi_recipe(), contains preprocessing steps Define frosting() contains post-processing layers Combine trainer quantile_reg() epi_workflow(), can fit training data fit() workflow data Grab right prediction data using get_test_data() apply fit data generate prediction","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/custom_epiworkflows.html","id":"define-the-epi_recipe","dir":"Articles","previous_headings":"Recreating four_week_ahead in an epi_workflow()","what":"Define the epi_recipe()","title":"Custom Epiworkflows","text":"steps found four_week_ahead look like: 6 steps need recreate. Note steps extracted recipe marked already Trained. steps recipes::step_BoxCox() parameters change behavior, means parameters already calculated based training data set. Let‚Äôs create epi_recipe() hold 6 steps: data set passed epi_recipe isn‚Äôt required actual data set going train model. However, columns metadata (as_of other_keys); typically easiest just use training data . means can use workflow multiple data sets long format remains . might useful continue get updates data set time want train new instance model. can append step using pipes. principle, order matters, though recipe step_epi_naomit() step_training_window() depend steps . steps can thought setting parameters help specify later processing computation. Note said four_week_ahead contained 6 steps. ‚Äôve added 5 top-level steps step_epi_naomit() actually wrapper around adding two step_naomit()s, one all_predictors() one all_outcomes(). step_naomit()s differ treatment data predict time. step_epi_lag() step_epi_ahead() accept ‚Äútidy‚Äù syntax processing can applied multiple columns . example, wanted use lags case_rate death_rate, specify single step, like step_epi_lag(ends_with(\"rate\"), lag = c(0, 7, 14)). general, recipes steps assign roles (predictor, outcome, see Roles vignette details) columns either adding new columns adjusting existing ones. step_epi_lag(), example, creates new column lag name lag_x_column_name labels predictor role. step_epi_ahead() creates ahead_x_column_name columns labels outcome role. general, inspect ‚Äòprepared‚Äô steps, can run prep(), fits parameters used recipe, calculates new columns, assigns roles1. example, can use prep() make sure training correct columns: bake() applies prepared recipe (potentially new) dataset create dataset handed epi_workflow(). can inspect newly-created columns running bake() recipe far: also useful debugging malfunctioning pipelines. can run prep() bake() new recipe containing subset steps ‚Äì steps beginning one misbehaving ‚Äì full, original recipe. return evaluation recipe point can see data misbehaving step applied . also allows see exact data later parsnip model trained .","code":"hardhat::extract_recipe(four_week_ahead$epi_workflow) #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Training information #> Training data contained 856 data points and no incomplete rows. #>  #> ‚îÄ‚îÄ Operations #> 1. Lagging: case_rate by 0, 1, 2, 3, 7, 14 | Trained #> 2. Lagging: death_rate by 0, 7, 14 | Trained #> 3. Leading: death_rate by 28 | Trained #> 4. ‚Ä¢ Removing rows with NA values in: lag_0_case_rate, ... | Trained #> 5. ‚Ä¢ Removing rows with NA values in: ahead_28_death_rate | Trained #> 6. ‚Ä¢ # of recent observations per key limited to:: Inf | Trained #> 7. ‚Ä¢ Check enough data (n = 1) for: lag_0_case_rate, ... | Trained filtered_data <- covid_case_death_rates |>   filter(time_value <= forecast_date, geo_value %in% used_locations) four_week_recipe <- epi_recipe(   filtered_data,   reference_date = (filtered_data %@% metadata)$as_of ) four_week_recipe <- four_week_recipe |>   step_epi_lag(case_rate, lag = c(0, 1, 2, 3, 7, 14)) |>   step_epi_lag(death_rate, lag = c(0, 7, 14)) |>   step_epi_ahead(death_rate, ahead = 4 * 7) |>   step_epi_naomit() |>   step_training_window() prepped <- four_week_recipe |> prep(training_data) prepped$term_info |> print(n = 14) #> # A tibble: 14 √ó 4 #>    variable            type    role       source   #>    <chr>               <chr>   <chr>      <chr>    #>  1 geo_value           nominal geo_value  original #>  2 time_value          date    time_value original #>  3 case_rate           numeric raw        original #>  4 death_rate          numeric raw        original #>  5 lag_0_case_rate     numeric predictor  derived  #>  6 lag_1_case_rate     numeric predictor  derived  #>  7 lag_2_case_rate     numeric predictor  derived  #>  8 lag_3_case_rate     numeric predictor  derived  #>  9 lag_7_case_rate     numeric predictor  derived  #> 10 lag_14_case_rate    numeric predictor  derived  #> 11 lag_0_death_rate    numeric predictor  derived  #> 12 lag_7_death_rate    numeric predictor  derived  #> 13 lag_14_death_rate   numeric predictor  derived  #> 14 ahead_28_death_rate numeric outcome    derived four_week_recipe |>   prep(training_data) |>   bake(training_data) #> An `epi_df` object, 800 x 14 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 800 √ó 14 #>   geo_value time_value case_rate death_rate lag_0_case_rate lag_1_case_rate #> * <chr>     <date>         <dbl>      <dbl>           <dbl>           <dbl> #> 1 ca        2021-01-14     108.       1.22            108.            111.  #> 2 ma        2021-01-14      88.7      0.893            88.7            92.0 #> 3 ny        2021-01-14      82.4      0.969            82.4            84.9 #> 4 tx        2021-01-14      74.9      1.05             74.9            75.0 #> 5 ca        2021-01-15     104.       1.21            104.            108.  #> 6 ma        2021-01-15      83.3      0.908            83.3            88.7 #> # ‚Ñπ 794 more rows #> # ‚Ñπ 8 more variables: lag_2_case_rate <dbl>, lag_3_case_rate <dbl>, ‚Ä¶"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/custom_epiworkflows.html","id":"define-the-frosting","dir":"Articles","previous_headings":"Recreating four_week_ahead in an epi_workflow()","what":"Define the frosting()","title":"Custom Epiworkflows","text":"post-processing frosting layers2 found four_week_ahead look like: Note: since frosting unique package, ‚Äôve defined custom function extract_frosting() inspect steps. Using detailed information output , can recreate layers similar defined recipe steps3: layer_predict() needs included every postprocessor actually predict prediction data. layers work engine steps. couple layers, however, depend whether engine predicts quantiles point estimates. following layers supported point estimate engines, linear_reg(): layer_residual_quantiles(): models don‚Äôt generate quantiles, preferred method generating quantiles. function uses error residuals engine calculate quantiles. work parsnip engines. layer_predictive_distn(): alternate method generating quantiles using approximate parametric distribution. work linear regression specifically. hand, following layers supported engines output quantiles, quantile_reg(): layer_quantile_distn(): adds specified quantiles. user-requested quantile levels differ ones actually fit, interpolated /extrapolated. layer_point_from_distn(): generates point estimate distribution (either median mean), , used, included layer_quantile_distn().","code":"epipredict::extract_frosting(four_week_ahead$epi_workflow) #>  #> ‚îÄ‚îÄ Frosting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Layers #> 1. Creating predictions: \"<calculated>\" #> 2. Resampling residuals for predictive quantiles: \"<calculated>\" #> 3. quantile_levels 0.1, 0.25, 0.5, 0.75, 0.9 #> 4. Adding forecast date: \"2021-08-01\" #> 5. Adding target date: \"2021-08-29\" #> 6. Thresholding predictions: dplyr::starts_with(\".pred\") to [0, Inf) four_week_layers <- frosting() |>   layer_predict() |>   layer_residual_quantiles(quantile_levels = c(0.1, 0.25, 0.5, 0.75, 0.9)) |>   layer_add_forecast_date() |>   layer_add_target_date() |>   layer_threshold()"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/custom_epiworkflows.html","id":"fitting-an-epi_workflow","dir":"Articles","previous_headings":"Recreating four_week_ahead in an epi_workflow()","what":"Fitting an epi_workflow()","title":"Custom Epiworkflows","text":"Now recipe layers, can assemble workflow. simple passing component preprocessor, model, postprocessor epi_workflow(). fitting , recreated four_week_ahead$epi_workflow. Running fit() calculates preprocessor-required parameters, trains model data passed fit(). However, generate predictions; predictions need created separate step.","code":"four_week_workflow <- epi_workflow(   four_week_recipe,   linear_reg(),   four_week_layers ) fit_workflow <- four_week_workflow |> fit(training_data)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/custom_epiworkflows.html","id":"predicting","dir":"Articles","previous_headings":"Recreating four_week_ahead in an epi_workflow()","what":"Predicting","title":"Custom Epiworkflows","text":"make prediction, helps narrow data set relevant observations using get_test_data(). can still generate predictions without first, predict every day data-set, just reference_date. example, ‚Äôre creating relevant_data training_data, data set want predictions entirely new data, unrelated one used building workflow. trained workflow data hand, can actually make predictions: Note simply plug full training_data predict() still get predictions: resulting tibble 800 rows long, however. Passing non-subsetted data set produces forecasts just requested reference_date, every day data set sufficient data produce prediction. narrow , filter rows time_value matches forecast_date: can useful workaround get_test_data() fails pull enough data produce forecast. generally problem recipe (preprocessor) sufficiently complicated, get_test_data() can‚Äôt determine precisely data required. forecasts generated filter get_test_data identical.","code":"relevant_data <- get_test_data(   four_week_recipe,   training_data ) fit_workflow |> predict(relevant_data) #> An `epi_df` object, 4 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 4 √ó 6 #>   geo_value time_value .pred .pred_distn forecast_date target_date #>   <chr>     <date>     <dbl>   <qtls(5)> <date>        <date>      #> 1 ca        2021-08-01 0.341     [0.341] 2021-08-01    2021-08-29  #> 2 ma        2021-08-01 0.163     [0.163] 2021-08-01    2021-08-29  #> 3 ny        2021-08-01 0.196     [0.196] 2021-08-01    2021-08-29  #> 4 tx        2021-08-01 0.404     [0.404] 2021-08-01    2021-08-29 fit_workflow |> predict(training_data) #> An `epi_df` object, 800 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 800 √ó 6 #>   geo_value time_value .pred .pred_distn forecast_date target_date #>   <chr>     <date>     <dbl>   <qtls(5)> <date>        <date>      #> 1 ca        2021-01-14 0.997     [0.997] 2021-08-01    2021-08-29  #> 2 ma        2021-01-14 0.835     [0.835] 2021-08-01    2021-08-29  #> 3 ny        2021-01-14 0.868     [0.868] 2021-08-01    2021-08-29  #> 4 tx        2021-01-14 0.581     [0.581] 2021-08-01    2021-08-29  #> 5 ca        2021-01-15 0.869     [0.869] 2021-08-01    2021-08-29  #> 6 ma        2021-01-15 0.830      [0.83] 2021-08-01    2021-08-29  #> # ‚Ñπ 794 more rows fit_workflow |>   predict(training_data) |>   filter(time_value == forecast_date) #> An `epi_df` object, 4 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 4 √ó 6 #>   geo_value time_value .pred .pred_distn forecast_date target_date #>   <chr>     <date>     <dbl>   <qtls(5)> <date>        <date>      #> 1 ca        2021-08-01 0.341     [0.341] 2021-08-01    2021-08-29  #> 2 ma        2021-08-01 0.163     [0.163] 2021-08-01    2021-08-29  #> 3 ny        2021-08-01 0.196     [0.196] 2021-08-01    2021-08-29  #> 4 tx        2021-08-01 0.404     [0.404] 2021-08-01    2021-08-29"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/custom_epiworkflows.html","id":"extending-four_week_ahead","dir":"Articles","previous_headings":"","what":"Extending four_week_ahead","title":"Custom Epiworkflows","text":"Now know create four_week_ahead scratch, can start modifying workflow get custom behavior. many ways modify four_week_ahead. might consider: Converting rates counts Including growth rate estimate predictor Including time component predictor ‚Äî useful expect strong seasonal component outcome Scaling factor demonstrate couple modifications .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/custom_epiworkflows.html","id":"growth-rate","dir":"Articles","previous_headings":"Extending four_week_ahead","what":"Growth rate","title":"Custom Epiworkflows","text":"Let‚Äôs say ‚Äôre interested including growth rate predictor model think may potentially improve forecast. can easily create new growth rate column step epi_recipe. Inspecting newly added column: role: Let‚Äôs say want use quantile_reg() model. quantile_reg() outputs quantiles , need change frosting convert quantile distribution quantiles point predictions. , need switch layer_residual_quantiles() (used converting point + residuals output, e.g.¬†linear_reg() quantiles) layer_quantile_distn() layer_point_from_distn(): ‚Äôll reuse code landing page plot result.","code":"growth_rate_recipe <- epi_recipe(   covid_case_death_rates |>     filter(time_value <= forecast_date, geo_value %in% used_locations) ) |>   # Calculate growth rate from death rate column.   step_growth_rate(death_rate) |>   step_epi_lag(case_rate, lag = c(0, 1, 2, 3, 7, 14)) |>   step_epi_lag(death_rate, lag = c(0, 7, 14)) |>   step_epi_ahead(death_rate, ahead = 4 * 7) |>   step_epi_naomit() |>   step_training_window() growth_rate_recipe |>   prep(training_data) |>   bake(training_data) |>   select(     geo_value, time_value, case_rate,     death_rate, gr_7_rel_change_death_rate   ) |>   arrange(geo_value, time_value) |>   tail() #> An `epi_df` object, 6 x 5 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 6 √ó 5 #>   geo_value time_value case_rate death_rate gr_7_rel_change_death_rate #>   <chr>     <date>         <dbl>      <dbl>                      <dbl> #> 1 tx        2021-07-27      19.8      0.104                    0.00721 #> 2 tx        2021-07-28      23.6      0.118                    0.0159  #> 3 tx        2021-07-29      23.4      0.122                    0.0272  #> 4 tx        2021-07-30      27.6      0.128                    0.0339  #> 5 tx        2021-07-31      30.7      0.132                    0.0421  #> 6 tx        2021-08-01      30.7      0.136                    0.0516 prepped <- growth_rate_recipe |>   prep(training_data) prepped$term_info |> filter(grepl(\"gr\", variable)) #> # A tibble: 1 √ó 4 #>   variable                   type    role      source  #>   <chr>                      <chr>   <chr>     <chr>   #> 1 gr_7_rel_change_death_rate numeric predictor derived growth_rate_layers <- frosting() |>   layer_predict() |>   layer_quantile_distn(     quantile_levels = c(0.1, 0.25, 0.5, 0.75, 0.9)   ) |>   layer_point_from_distn() |>   layer_add_forecast_date() |>   layer_add_target_date() |>   layer_threshold()  growth_rate_workflow <- epi_workflow(   growth_rate_recipe,   quantile_reg(quantile_levels = c(0.1, 0.25, 0.5, 0.75, 0.9)),   growth_rate_layers )  relevant_data <- get_test_data(   growth_rate_recipe,   training_data ) gr_fit_workflow <- growth_rate_workflow |> fit(training_data) gr_predictions <- gr_fit_workflow |>   predict(relevant_data) |>   filter(time_value == forecast_date) forecast_date_label <-   tibble(     geo_value = rep(used_locations, 2),     .response_name = c(rep(\"case_rate\", 4), rep(\"death_rate\", 4)),     dates = rep(forecast_date - 7 * 2, 2 * length(used_locations)),     heights = c(rep(150, 4), rep(0.30, 4))   )  result_plot <- autoplot(   object = gr_fit_workflow,   predictions = gr_predictions,   observed_response = covid_case_death_rates |>     filter(geo_value %in% used_locations, time_value > \"2021-07-01\") ) +   geom_vline(aes(xintercept = forecast_date)) +   geom_text(     data = forecast_date_label |> filter(.response_name == \"death_rate\"),     aes(x = dates, label = \"forecast\\ndate\", y = heights),     size = 3, hjust = \"right\"   ) +   scale_x_date(date_breaks = \"3 months\", date_labels = \"%Y %b\") +   theme(axis.text.x = element_text(angle = 90, hjust = 1))"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/custom_epiworkflows.html","id":"population-scaling","dir":"Articles","previous_headings":"Extending four_week_ahead","what":"Population scaling","title":"Custom Epiworkflows","text":"Suppose want modify predictions return rate prediction, rather count prediction. , can adjust just frosting perform post-processing existing rates forecaster. Since rates calculated counts per 100 000 people, convert back counts multiplying rates factor regional population100,000\\frac{ \\text{regional population} }{100,000}. note ‚Äôve used tidyselect::starts_with(\".pred\") , apply function .pred .pred_distn columns.","code":"count_layers <-   frosting() |>   layer_predict() |>   layer_residual_quantiles(quantile_levels = c(0.1, 0.25, 0.5, 0.75, 0.9)) |>   layer_population_scaling(     starts_with(\".pred\"),     # `df` contains scaling values for all regions; in this case it is the state populations     df = epidatasets::state_census,     df_pop_col = \"pop\",     create_new = FALSE,     # `rate_rescaling` gives the denominator of the existing rate predictions     rate_rescaling = 1e5,     by = c(\"geo_value\" = \"abbr\")   ) |>   layer_add_forecast_date() |>   layer_add_target_date() |>   layer_threshold()  # building the new workflow count_workflow <- epi_workflow(   four_week_recipe,   linear_reg(),   count_layers ) count_pred_data <- get_test_data(four_week_recipe, training_data) count_predictions <- count_workflow |>   fit(training_data) |>   predict(count_pred_data)  count_predictions #> An `epi_df` object, 4 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 4 √ó 6 #>   geo_value time_value .pred .pred_distn forecast_date target_date #>   <chr>     <date>     <dbl>   <qtls(5)> <date>        <date>      #> 1 ca        2021-08-01 135.        [135] 2021-08-01    2021-08-29  #> 2 ma        2021-08-01  11.3      [11.3] 2021-08-01    2021-08-29  #> 3 ny        2021-08-01  38.2      [38.2] 2021-08-01    2021-08-29  #> 4 tx        2021-08-01 117.        [117] 2021-08-01    2021-08-29"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/custom_epiworkflows.html","id":"custom-classifier-workflow","dir":"Articles","previous_headings":"","what":"Custom classifier workflow","title":"Custom Epiworkflows","text":"Let‚Äôs work example complicated kind pipeline can build using epipredict framework. hotspot prediction model, predicts whether case rates increasing (), decreasing () flat (flat). model comes paper McDonald, Bien, Green, Hu et al4, roughly serves extension arx_classifier(). First, need add factor version geo_value, can used feature. put together recipe, using combination base {recipe} functions add_role() step_dummy(), epipredict functions step_growth_rate(). adds predictors: time value continuous variable (via add_role()) geo_value set indicator variables (via step_dummy() previous .factor()) growth rate case rate, prediction time (lag), lagged one two weeks outcome variable created composing several steps together. step_epi_ahead() creates column growth rate one week future, step_mutate() turns column factor 3 possible values, Z‚Ñì,t={,ifY‚Ñì,tŒî>0.25down,ifY‚Ñì,tŒî<‚àí0.20flat,otherwise  Z_{\\ell, t}=     \\begin{cases}       \\text{}, & \\text{}\\ Y^{\\Delta}_{\\ell, t} > 0.25 \\\\       \\text{}, & \\text{}\\  Y^{\\Delta}_{\\ell, t} < -0.20\\\\       \\text{flat}, & \\text{otherwise}     \\end{cases} Y‚Ñì,tŒîY^{\\Delta}_{\\ell, t} growth rate location ‚Ñì\\ell time tt. means case_rate increased least 25%, means decreased least 20%. Note step_growth_rate() step_epi_ahead() explicitly assign role none. columns used intermediaries create predictor outcome columns. Afterwards, step_rm() drops temporary columns, along original role = \"raw\" columns death_rate case_rate. geo_value_factor time_value retained roles reassigned. fit 3-class classification model like , need use parsnip model mode = \"classification\". simplest example parsnip classification-mode model multinomial_reg(). needed layers less linear_reg() regression layers, addition need remove NA values: comparing result actual growth rates point time, see ‚Äôre significantly higher 25% per week (36%-62%), matches classification model‚Äôs predictions. See tooling book -depth discussion example.","code":"training_data <-   covid_case_death_rates |>   filter(time_value <= forecast_date, geo_value %in% used_locations) |>   mutate(geo_value_factor = as.factor(geo_value)) classifier_recipe <- epi_recipe(training_data) |>   # Label `time_value` as predictor and do no other processing   add_role(time_value, new_role = \"predictor\") |>   # Use one-hot encoding on `geo_value_factor` and label each resulting column as a predictor   step_dummy(geo_value_factor) |>   # Create and lag `case_rate` growth rate   step_growth_rate(case_rate, role = \"none\", prefix = \"gr_\") |>   step_epi_lag(starts_with(\"gr_\"), lag = c(0, 7, 14)) |>   step_epi_ahead(starts_with(\"gr_\"), ahead = 7) |>   # divide growth rate into 3 bins   step_cut(ahead_7_gr_7_rel_change_case_rate, breaks = c(-Inf, -0.2, 0.25, Inf) / 7) |>   # Drop unused columns based on role assignments. This is not strictly   # necessary, as columns with roles unused in the model will be ignored anyway.   step_rm(has_role(\"none\"), has_role(\"raw\")) |>   step_epi_naomit() frost <- frosting() |>   layer_naomit(starts_with(\".pred\")) |>   layer_add_forecast_date() |>   layer_add_target_date() wf <- epi_workflow(   classifier_recipe,   multinom_reg(),   frost ) |>   fit(training_data)  forecast(wf) #> An `epi_df` object, 4 x 5 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 4 √ó 5 #>   geo_value time_value .pred_class   forecast_date target_date #>   <chr>     <date>     <fct>         <date>        <date>      #> 1 ca        2021-08-01 (0.0357, Inf] 2021-08-01    2021-08-08  #> 2 ma        2021-08-01 (0.0357, Inf] 2021-08-01    2021-08-08  #> 3 ny        2021-08-01 (0.0357, Inf] 2021-08-01    2021-08-08  #> 4 tx        2021-08-01 (0.0357, Inf] 2021-08-01    2021-08-08 growth_rates <- covid_case_death_rates |>   filter(geo_value %in% used_locations) |>   group_by(geo_value) |>   mutate(     # Multiply by 7 to estimate weekly equivalents     case_gr = growth_rate(x = time_value, y = case_rate) * 7   ) |>   ungroup()  growth_rates |> filter(time_value == \"2021-08-01\") |> select(-death_rate) #> An `epi_df` object, 4 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 4 √ó 4 #>   geo_value time_value case_rate case_gr #>   <chr>     <date>         <dbl>   <dbl> #> 1 ca        2021-08-01     24.9    0.356 #> 2 ma        2021-08-01      9.53   0.484 #> 3 ny        2021-08-01     12.5    0.504 #> 4 tx        2021-08-01     30.7    0.619"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Get started with `epipredict`","text":"high level, goal epipredict make easy run simple machine learning statistical forecasters epidemiological data. , extended tidymodels framework handle case panel time-series data. hope easy users epidemiological training statistical knowledge estimate baseline models, also allowing nuanced statistical understanding create complex custom models using framework. Towards end, epipredict provides two main classes tools:","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"canned-forecasters","dir":"Articles","previous_headings":"Introduction","what":"Canned forecasters","title":"Get started with `epipredict`","text":"set basic, easy--use ‚Äúcanned‚Äù forecasters work box. currently provide following basic forecasters: flatline_forecaster(): predicts median recently seen value increasingly wide quantiles. climatological_forecaster(): predicts median quantiles based historical values around date previous years. arx_forecaster(): AutoRegressive eXogenous feature forecaster, estimates model (e.g.¬†linear regression) lagged data predict quantiles continuous values. arx_classifier(): fits model (e.g.¬†logistic regression) lagged data predict binned version growth rate. cdc_baseline_forecaster(): variant flatline forecaster used baseline CDC‚Äôs FluSight forecasting competition.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"forecasting-framework","dir":"Articles","previous_headings":"Introduction","what":"Forecasting framework","title":"Get started with `epipredict`","text":"framework creating custom forecasters modular components, canned forecasters created. three types components: Preprocessor: transform data model training, converting counts rates, creating smoothed columns, {recipes} step Trainer: train model data, resulting fitted model object. Examples include linear regression, quantile regression, {parsnip} engine. generating quantiles purely point-prediction models, reverting operations done steps, converting rates back counts generally adapting format prediction eventual use. rest ‚ÄúGet Started‚Äù vignette focus using modifying canned forecasters. Check Custom Epiworkflows vignette examples using forecaster framework make complex, custom forecasters. interested time series non-panel data context, may also want look timetk modeltime related techniques. -depth treatment practical applications, see also Forecasting Book.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"panel-forecasting-basics","dir":"Articles","previous_headings":"","what":"Panel forecasting basics","title":"Get started with `epipredict`","text":"section gives basic usage examples package beyond basic usage arx_forecaster() forecasting single ahead using default engine. start actually building forecasters, lets import relevant libraries default forecasting date selected states (use limit data make discussion easier):","code":"library(dplyr) library(parsnip) library(workflows) library(recipes) library(epidatasets) library(epipredict) library(epiprocess) library(ggplot2) library(purrr) library(epidatr) forecast_date <- as.Date(\"2021-08-01\") used_locations <- c(\"ca\", \"ma\", \"ny\", \"tx\")"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"example-data","dir":"Articles","previous_headings":"Panel forecasting basics","what":"Example data","title":"Get started with `epipredict`","text":"forecasting methods package designed work panel time series data epi_df format made available epiprocess package. epi_df collection one time-series indexed one categorical variables. {epidatasets} package makes several pre-compiled example datasets available. Let‚Äôs look example epi_df: epi_df always geo_value time_value keys, along number value columns, case case_rate death_rate. associated geo_type (state) time_type (day), utilities. geo_value time_value minimal set keys, functions epiprocess epipredict designed accommodate key values, age, ethnicity, demographic information. example, grad_employ_subset epidatasets also age_group edu_qual additional keys: See epiprocess details epi_df format. Panel time series ubiquitous epidemiology, also common economics, psychology, sociology, many areas. package designed epidemiology mind, many techniques broadly applicable.","code":"covid_case_death_rates #> An `epi_df` object, 20,496 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 20,496 √ó 4 #>   geo_value time_value case_rate death_rate #> * <chr>     <date>         <dbl>      <dbl> #> 1 ak        2020-12-31      35.9      0.158 #> 2 al        2020-12-31      65.1      0.438 #> 3 ar        2020-12-31      66.0      1.27  #> 4 as        2020-12-31       0        0     #> 5 az        2020-12-31      76.8      1.10  #> 6 ca        2020-12-31      95.9      0.755 #> # ‚Ñπ 20,490 more rows grad_employ_subset #> An `epi_df` object, 1,445 x 7 with metadata: #> * geo_type  = custom #> * time_type = integer #> * other_keys = age_group, edu_qual #> * as_of     = 2024-09-18 #>  #> # A tibble: 1,445 √ó 7 #>   geo_value           age_group      edu_qual        time_value num_graduates #> * <chr>               <fct>          <fct>                <int>         <dbl> #> 1 Newfoundland and L‚Ä¶ 15 to 34 years Career, techni‚Ä¶       2010           430 #> 2 Newfoundland and L‚Ä¶ 35 to 64 years Career, techni‚Ä¶       2010           140 #> 3 Newfoundland and L‚Ä¶ 15 to 34 years Career, techni‚Ä¶       2010           630 #> 4 Newfoundland and L‚Ä¶ 35 to 64 years Career, techni‚Ä¶       2010           140 #> 5 Newfoundland and L‚Ä¶ 15 to 34 years Other career, ‚Ä¶       2010            60 #> 6 Newfoundland and L‚Ä¶ 35 to 64 years Other career, ‚Ä¶       2010            40 #> # ‚Ñπ 1,439 more rows #> # ‚Ñπ 2 more variables: med_income_2y <dbl>, med_income_5y <dbl>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"customizing-arx_forecaster","dir":"Articles","previous_headings":"Panel forecasting basics","what":"Customizing arx_forecaster()","title":"Get started with `epipredict`","text":"Let‚Äôs expand basic example presented landing page, starting adjusting parameters arx_forecaster(). trainer argument allows us set computational engine. can use either one relevant parsnip models, one included engines, smooth_quantile_reg(): default trainer parsnip::linear_reg(), generates quantiles fact post-processing layers, rather part model. post-processing layers produce prediction intervals arbitrary trainer, generally preferable use quantile_reg() (alternative produces statistically justifiable prediction intervals), quantiles generated post-processing can poorly behaved. quantile_reg() hand directly estimates different linear model quantile, reflected several different columns tau . flexibility parsnip, whole host models available us1; example, just easily substituted non-linear random forest model ranger: customization possible via args_list = arx_args_list(); example, wanted increase number quantiles fit: See function documentation arx_args_list() examples modifications available. want make modifications, need custom workflow; see Custom Epiworkflows vignette details.","code":"two_week_ahead <- arx_forecaster(   covid_case_death_rates |> filter(time_value <= forecast_date),   outcome = \"death_rate\",   trainer = quantile_reg(),   predictors = c(\"death_rate\"),   args_list = arx_args_list(     lags = list(c(0, 7, 14)),     ahead = 14   ) ) hardhat::extract_fit_engine(two_week_ahead$epi_workflow) #> Call: #> quantreg::rq(formula = ..y ~ ., tau = ~c(0.05, 0.1, 0.25, 0.5,  #> 0.75, 0.9, 0.95), data = data, na.action = stats::na.omit, method = ~\"br\",  #>     model = FALSE) #>  #> Coefficients: #>                      tau= 0.05  tau= 0.10 tau= 0.25  tau= 0.50  tau= 0.75 #> (Intercept)       -0.004873168 0.00000000 0.0000000 0.01867752 0.03708118 #> lag_0_death_rate   0.084091001 0.15180503 0.3076742 0.51165423 0.59058733 #> lag_7_death_rate   0.049478502 0.08493916 0.1232253 0.10018481 0.18480536 #> lag_14_death_rate  0.072304151 0.08554334 0.0712085 0.04088075 0.02609046 #>                    tau= 0.90 tau= 0.95 #> (Intercept)       0.07234641 0.1092061 #> lag_0_death_rate  0.59001978 0.5249616 #> lag_7_death_rate  0.33236190 0.4250353 #> lag_14_death_rate 0.03695928 0.1783820 #>  #> Degrees of freedom: 10416 total; 10412 residual two_week_ahead <- arx_forecaster(   covid_case_death_rates |> filter(time_value <= forecast_date),   outcome = \"death_rate\",   trainer = rand_forest(mode = \"regression\"),   predictors = c(\"death_rate\"),   args_list = arx_args_list(     lags = list(c(0, 7, 14)),     ahead = 14   ) ) two_week_ahead <- arx_forecaster(   covid_case_death_rates |>     filter(time_value <= forecast_date, geo_value %in% used_locations),   outcome = \"death_rate\",   trainer = quantile_reg(),   predictors = c(\"death_rate\"),   args_list = arx_args_list(     lags = list(c(0, 7, 14)),     ahead = 14,     ############ changing quantile_levels ############     quantile_levels = c(0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.8, 0.9, 0.95)     ##################################################   ) ) hardhat::extract_fit_engine(two_week_ahead$epi_workflow) #> Call: #> quantreg::rq(formula = ..y ~ ., tau = ~c(0.05, 0.1, 0.2, 0.3,  #> 0.5, 0.7, 0.8, 0.9, 0.95), data = data, na.action = stats::na.omit,  #>     method = ~\"br\", model = FALSE) #>  #> Coefficients: #>                     tau= 0.05    tau= 0.10    tau= 0.20     tau= 0.30 #> (Intercept)       -0.01329758 -0.006999475 -0.003226356  0.0001366959 #> lag_0_death_rate   0.25217750  0.257695857  0.486159095  0.6986147165 #> lag_7_death_rate   0.17210286  0.212294203  0.114016289  0.0704290267 #> lag_14_death_rate  0.08880828  0.057022770  0.013800329 -0.0654254593 #>                      tau= 0.50    tau= 0.70    tau= 0.80   tau= 0.90 #> (Intercept)        0.004395352  0.008467922  0.005495554  0.01626215 #> lag_0_death_rate   0.751695727  0.767243828  0.743676651  0.60494554 #> lag_7_death_rate   0.208846644  0.347907095  0.460814061  0.61021640 #> lag_14_death_rate -0.164693162 -0.234886556 -0.236950849 -0.20670731 #>                     tau= 0.95 #> (Intercept)        0.03468154 #> lag_0_death_rate   0.59202848 #> lag_7_death_rate   0.64532803 #> lag_14_death_rate -0.18566431 #>  #> Degrees of freedom: 744 total; 740 residual"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"generating-multiple-aheads","dir":"Articles","previous_headings":"Panel forecasting basics","what":"Generating multiple aheads","title":"Get started with `epipredict`","text":"often want generate trajectory forecasts range dates, rather single day. can arx_forecaster() looping aheads. example, predict every day 4-week time period:","code":"all_canned_results <- lapply(   seq(0, 28),   \\(days_ahead) {     arx_forecaster(       covid_case_death_rates |>         filter(time_value <= forecast_date, geo_value %in% used_locations),       outcome = \"death_rate\",       predictors = c(\"case_rate\", \"death_rate\"),       trainer = quantile_reg(),       args_list = arx_args_list(         lags = list(c(0, 1, 2, 3, 7, 14), c(0, 7, 14)),         ahead = days_ahead       )     )   } ) # pull out the workflow and the predictions to be able to #  effectively use autoplot workflow <- all_canned_results[[1]]$epi_workflow results <- all_canned_results |>   purrr::map(~ `$`(., \"predictions\")) |>   list_rbind() autoplot(   object = workflow,   predictions = results,   observed_response = covid_case_death_rates |>     filter(geo_value %in% used_locations, time_value > \"2021-07-01\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"other-canned-forecasters","dir":"Articles","previous_headings":"Panel forecasting basics","what":"Other canned forecasters","title":"Get started with `epipredict`","text":"section gives brief example canned forecasters.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"flatline_forecaster","dir":"Articles","previous_headings":"Panel forecasting basics > Other canned forecasters","what":"flatline_forecaster()","title":"Get started with `epipredict`","text":"simplest model provide flatline_forecaster(), predicts flat line (quantiles generated residuals using layer_residual_quantiles()). example, dataset :","code":"all_flatlines <- lapply(   seq(0, 28),   \\(days_ahead) {     flatline_forecaster(       covid_case_death_rates |>         filter(time_value <= forecast_date, geo_value %in% used_locations),       outcome = \"death_rate\",       args_list = flatline_args_list(         ahead = days_ahead,       )     )   } ) # same plotting code as in the arx multi-ahead case workflow <- all_flatlines[[1]]$epi_workflow results <- all_flatlines |>   purrr::map(~ `$`(., \"predictions\")) |>   list_rbind() autoplot(   object = workflow,   predictions = results,   observed_response = covid_case_death_rates |> filter(geo_value %in% used_locations, time_value > \"2021-07-01\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"cdc_baseline_forecaster","dir":"Articles","previous_headings":"Panel forecasting basics > Other canned forecasters","what":"cdc_baseline_forecaster()","title":"Get started with `epipredict`","text":"different method generating flatline forecast, used baseline CDC COVID-19 Forecasting Hub.  cdc_baseline_forecaster() flatline_forecaster() generate medians way, cdc_baseline_forecaster()‚Äôs quantiles generated using layer_cdc_flatline_quantiles() instead layer_residual_quantiles(). quantile-generating methods use residuals compute quantiles, layer_cdc_flatline_quantiles() extrapolates quantiles repeatedly sampling initial quantiles generate next set. results much smoother quantiles, ones capture one-ahead uncertainty.","code":"all_cdc_flatline <-   cdc_baseline_forecaster(     covid_case_death_rates |>       filter(time_value <= forecast_date, geo_value %in% used_locations),     outcome = \"death_rate\",     args_list = cdc_baseline_args_list(       aheads = 1:28,       data_frequency = \"1 day\"     )   ) # same plotting code as in the arx multi-ahead case workflow <- all_cdc_flatline$epi_workflow results <- all_cdc_flatline$predictions autoplot(   object = workflow,   predictions = results,   observed_response = covid_case_death_rates |> filter(geo_value %in% used_locations, time_value > \"2021-07-01\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"climatological_forecaster","dir":"Articles","previous_headings":"Panel forecasting basics > Other canned forecasters","what":"climatological_forecaster()","title":"Get started with `epipredict`","text":"climatological_forecaster() different kind baseline. produces point forecast quantiles based historical values given time year, rather extrapolating recent values. Among forecasters, one well suited forecasts long time horizons. Since requires multiple years data roughly seasonal signal, dataset ‚Äôve using demonstrations far poor example climate forecast2. Instead, ‚Äôll use fluview ILI dataset, weekly influenza like illness data hhs regions, going back 1997. ‚Äôll predict 2023/24 season using previous data, including 2020-2022, two years approximately seasonal flu, forecasting start season, 2023-10-08:  One feature climatological baseline forecasts multiple aheads simultaneously; entire season 28 weeks. possible arx_forecaster(), using trainer = smooth_quantile_reg(), built handle multiple aheads simultaneously3. pure climatological forecast can thought forecasting typical year far. 2023/24 regions, hhs10 quite close typical year, , hhs2 frequently outside even 90% prediction band (lightest shown ).","code":"fluview_hhs <- pub_fluview(   regions = paste0(\"hhs\", 1:10),   epiweeks = epirange(100001,222201) ) fluview <- fluview_hhs %>%   select(     geo_value = region,     time_value = epiweek,     issue,     ili) %>%   as_epi_archive() %>%   epix_as_of_current() #> inferring version column.  all_climate <- climatological_forecaster(   fluview %>% filter(time_value < \"2023-10-08\"),   outcome = \"ili\",   args_list = climate_args_list(     forecast_horizon = seq(0, 28),     time_type = \"week\",     quantile_by_key = \"geo_value\",     forecast_date = as.Date(\"2023-10-08\")   ) ) workflow <- all_climate$epi_workflow results <- all_climate$predictions autoplot(   object = workflow,   predictions = results,   observed_response = fluview %>%     filter(time_value >= \"2023-10-08\", time_value < \"2024-05-01\") %>%     mutate(geo_value = factor(geo_value, levels = paste0(\"hhs\", 1:10))) )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"arx_classifier","dir":"Articles","previous_headings":"Panel forecasting basics > Other canned forecasters","what":"arx_classifier()","title":"Get started with `epipredict`","text":"Unlike canned forecasters, arx_classifier predicts binned growth rate. forecaster converts raw outcome variable growth rate, bins predicts, using bin thresholds provided user. example, dataset forecast_date , model outputs: number size growth rate categories controlled breaks, define bin boundaries. example, custom breaks passed arx_class_args_list() correspond 2 bins: (-‚àû, 0.0357] (0.0357, ‚àû). bins can interpreted : death_rate decreasing/growing slowly, death_rate growing quickly. returned predictions assigns state one growth rate bins. case, classifier expects growth rate 4 states fall category, (-‚àû, 0.0357]. see model performed, let‚Äôs compare actual growth rates target_date, computed using epiprocess: accuracy 50%, since 4 states predicted interval (-Inf, 0.0357], two, ca ny actually .","code":"classifier <- arx_classifier(   covid_case_death_rates |>     filter(geo_value %in% used_locations, time_value < forecast_date),   outcome = \"death_rate\",   predictors = c(\"death_rate\", \"case_rate\"),   trainer = multinom_reg(),   args_list = arx_class_args_list(     lags = list(c(0, 1, 2, 3, 7, 14), c(0, 7, 14)),     ahead = 2 * 7,     breaks = 0.25 / 7   ) ) classifier$predictions #> # A tibble: 4 √ó 4 #>   geo_value .pred_class   forecast_date target_date #>   <chr>     <fct>         <date>        <date>      #> 1 ca        (-Inf,0.0357] 2021-07-31    2021-08-14  #> 2 ma        (-Inf,0.0357] 2021-07-31    2021-08-14  #> 3 ny        (-Inf,0.0357] 2021-07-31    2021-08-14  #> 4 tx        (-Inf,0.0357] 2021-07-31    2021-08-14 growth_rates <- covid_case_death_rates |>   filter(geo_value %in% used_locations) |>   group_by(geo_value) |>   mutate(     deaths_gr = growth_rate(x = time_value, y = death_rate)   ) |>   ungroup() growth_rates |> filter(time_value == \"2021-08-14\") #> An `epi_df` object, 4 x 5 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 4 √ó 5 #>   geo_value time_value case_rate death_rate deaths_gr #>   <chr>     <date>         <dbl>      <dbl>     <dbl> #> 1 ca        2021-08-14      32.1    -0.0446   -1.39   #> 2 ma        2021-08-14      16.8     0.0953    0.0633 #> 3 ny        2021-08-14      21.0     0.0946    0.0321 #> 4 tx        2021-08-14      48.4     0.311     0.0721"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"handling-multi-key-panel-data","dir":"Articles","previous_headings":"Panel forecasting basics","what":"Handling multi-key panel data","title":"Get started with `epipredict`","text":"multiple keys set epi_df other_keys, arx_forecaster automatically group addition required geographic key. example, predicting number graduates subset categories grad_employ_subset :  8 graphs represent combinations geo_values (\"Quebec\" \"British Columbia\"), edu_quals (\"Undergraduate degree\" \"Professional degree\"), age brackets (\"15 34 years\" \"35 64 years\").","code":"edu_quals <- c(\"Undergraduate degree\", \"Professional degree\") geo_values <- c(\"Quebec\", \"British Columbia\")  grad_employ <- grad_employ_subset |>   filter(edu_qual %in% edu_quals, geo_value %in% geo_values)  grad_employ #> An `epi_df` object, 64 x 7 with metadata: #> * geo_type  = custom #> * time_type = integer #> * other_keys = age_group, edu_qual #> * as_of     = 2024-09-18 #>  #> # A tibble: 64 √ó 7 #>   geo_value        age_group      edu_qual           time_value num_graduates #>   <chr>            <fct>          <fct>                   <int>         <dbl> #> 1 Quebec           15 to 34 years Undergraduate deg‚Ä¶       2010         14270 #> 2 Quebec           35 to 64 years Undergraduate deg‚Ä¶       2010          1770 #> 3 Quebec           15 to 34 years Professional degr‚Ä¶       2010          1210 #> 4 Quebec           35 to 64 years Professional degr‚Ä¶       2010            50 #> 5 British Columbia 15 to 34 years Undergraduate deg‚Ä¶       2010          8180 #> 6 British Columbia 35 to 64 years Undergraduate deg‚Ä¶       2010          1100 #> # ‚Ñπ 58 more rows #> # ‚Ñπ 2 more variables: med_income_2y <dbl>, med_income_5y <dbl>  grad_forecast <- arx_forecaster(   grad_employ |>     filter(time_value < 2017),   outcome = \"num_graduates\",   predictors = c(\"num_graduates\"),   args_list = arx_args_list(     lags = list(c(0, 1, 2)),     ahead = 1   ) ) # and plotting autoplot(   grad_forecast$epi_workflow,   grad_forecast$predictions,   observed_response = grad_employ, ) + geom_vline(aes(xintercept = 2016))"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"estimating-models-without-geo-pooling","dir":"Articles","previous_headings":"Panel forecasting basics","what":"Estimating models without geo-pooling","title":"Get started with `epipredict`","text":"methods shown far estimate single model across geographic regions, treating independently identically distributed (see Mathematical description explicit model example). called ‚Äúgeo-pooling‚Äù. context epipredict, simplest way avoid geo-pooling use different parameters geography loop geo_values: Estimating separate models geography uses far less data estimate geo-pooling 56 times slower4. dataset contains relatively observations geography, fitting geo-pooled model likely produce better, stable results. However, geo-pooling can used values comparable meaning scale across geographies can made comparable, example normalization. wanted build geo-aware model, linear regression different intercept geography, need build custom workflow geography factor.","code":"geo_values <- covid_case_death_rates |>   pull(geo_value) |>   unique()  all_fits <-   purrr::map(geo_values, \\(geo) {     covid_case_death_rates |>       filter(         geo_value == geo,         time_value <= forecast_date       ) |>       arx_forecaster(         outcome = \"death_rate\",         trainer = linear_reg(),         predictors = c(\"death_rate\"),         args_list = arx_args_list(           lags = list(c(0, 7, 14)),           ahead = 14         )       )   }) all_fits |>   map(~ pluck(., \"predictions\")) |>   list_rbind() #> # A tibble: 56 √ó 5 #>   geo_value  .pred .pred_distn forecast_date target_date #>   <chr>      <dbl>   <qtls(7)> <date>        <date>      #> 1 ak        0.0787    [0.0787] 2021-08-01    2021-08-15  #> 2 al        0.206      [0.206] 2021-08-01    2021-08-15  #> 3 ar        0.275      [0.275] 2021-08-01    2021-08-15  #> 4 as        0              [0] 2021-08-01    2021-08-15  #> 5 az        0.121      [0.121] 2021-08-01    2021-08-15  #> 6 ca        0.0674    [0.0674] 2021-08-01    2021-08-15  #> # ‚Ñπ 50 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"anatomy-of-a-canned-forecaster","dir":"Articles","previous_headings":"","what":"Anatomy of a canned forecaster","title":"Get started with `epipredict`","text":"section describes resulting object arx_forecaster(), fairly minimal description mathematical model used, description arx_fcast object.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"mathematical-description","dir":"Articles","previous_headings":"Anatomy of a canned forecaster","what":"Mathematical description","title":"Get started with `epipredict`","text":"Let‚Äôs look mathematical details model detail, using minimal version four_week_ahead: dt,jd_{t,j} death rate day tt location jj ct,jc_{t,j} associated case rate, corresponding model : dt+28,j=a0+a1dt,j+a2dt‚àí7,j+a3dt‚àí14,j+a4ct,j+a5ct‚àí7,j+a6ct‚àí14,j+Œµt,j. \\begin{aligned} d_{t+28, j} = & a_0 + a_1 d_{t,j} + a_2 d_{t-7,j} + a_3 d_{t-14, j} +\\\\      & a_4 c_{t, j} + a_5 c_{t-7, j} + a_6 c_{t-14, j} + \\varepsilon_{t,j}. \\end{aligned} example, a1a_1 lag_0_death_rate , value 0.093, a5a_5 0.0027. Note unlike d_{t,j} c_{t,j}, don‚Äôt depend either time tt location jj. make geo-pooled model. training data estimating parameters linear model constructed within arx_forecaster() function shifting series columns appropriate amount ‚Äì based requested lags. row containing NA values predictors used training observation fit coefficients a0,‚Ä¶,a6a_0,\\ldots, a_6. equation accurate description model linear engine like quantile_reg() linear_reg(); nonlinear model like rand_forest(mode = \"regression\") use input variables training data, fit appropriate model .","code":"four_week_small <- arx_forecaster(   covid_case_death_rates |> filter(time_value <= forecast_date),   outcome = \"death_rate\",   predictors = c(\"case_rate\", \"death_rate\"),   args_list = arx_args_list(     lags = list(c(0, 7, 14), c(0, 7, 14)),     ahead = 4 * 7,     quantile_levels = c(0.1, 0.25, 0.5, 0.75, 0.9)   ) ) hardhat::extract_fit_engine(four_week_small$epi_workflow) #>  #> Call: #> stats::lm(formula = ..y ~ ., data = data) #>  #> Coefficients: #>       (Intercept)    lag_0_case_rate    lag_7_case_rate   lag_14_case_rate   #>         0.0186296          0.0041617          0.0026782         -0.0003569   #>  lag_0_death_rate   lag_7_death_rate  lag_14_death_rate   #>         0.0929132          0.0641027          0.0348096"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/epipredict.html","id":"code-object","dir":"Articles","previous_headings":"Anatomy of a canned forecaster","what":"Code object","title":"Get started with `epipredict`","text":"Let‚Äôs dissect forecaster trained back landing page: four_week_ahead three components: epi_workflow, table predictions, list metadata. table predictions simple tibble, .pred gives point/median prediction, .pred_distn hardhat::quantile_pred() object representing distribution various quantile levels. 5 <qtls(5)> refers number quantiles explicitly created, [0.234] median value5. default, .pred_distn covers quantiles c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95). epi_workflow significantly complicated object, extending workflows::workflow() include post-processing steps: epi_workflow() consists 3 parts: preprocessor: collection steps transform data ready modelling. Steps can custom, included package, defined {recipes}. four_week_ahead 5 steps; can inspect closely running hardhat::extract_recipe(four_week_ahead$epi_workflow).6 spec: parsnip::model_spec includes model parameters engine fit parameters training data prepared preprocessor. four_week_ahead uses default parsnip::linear_reg(), parsnip wrapper several linear regression engines, default stats::lm(). can inspect model closely running hardhat::extract_fit_recipe(four_week_ahead$epi_workflow). postprocessor: collection layers applied resulting forecast. Layers internal package. four_week_ahead just happens 5 well. can inspect layers closely running epipredict::extract_layers(four_week_ahead$epi_workflow). See Custom Epiworkflows vignette recreating extending four_week_ahead using custom forecaster framework.","code":"four_week_ahead <- arx_forecaster(   covid_case_death_rates |> filter(time_value <= forecast_date),   outcome = \"death_rate\",   predictors = c(\"case_rate\", \"death_rate\"),   args_list = arx_args_list(     lags = list(c(0, 1, 2, 3, 7, 14), c(0, 7, 14)),     ahead = 4 * 7,     quantile_levels = c(0.1, 0.25, 0.5, 0.75, 0.9)   ) ) four_week_ahead$predictions #> # A tibble: 56 √ó 5 #>   geo_value  .pred .pred_distn forecast_date target_date #>   <chr>      <dbl>   <qtls(5)> <date>        <date>      #> 1 ak        0.234      [0.234] 2021-08-01    2021-08-29  #> 2 al        0.290       [0.29] 2021-08-01    2021-08-29  #> 3 ar        0.482      [0.482] 2021-08-01    2021-08-29  #> 4 as        0.0190     [0.019] 2021-08-01    2021-08-29  #> 5 az        0.182      [0.182] 2021-08-01    2021-08-29  #> 6 ca        0.178      [0.178] 2021-08-01    2021-08-29  #> # ‚Ñπ 50 more rows four_week_ahead$epi_workflow #>  #> ‚ïê‚ïê Epi Workflow [trained] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: linear_reg() #> Postprocessor: Frosting #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 7 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_lag() #> 3. step_epi_ahead() #> 4. step_naomit() #> 5. step_naomit() #> 6. step_training_window() #> 7. check_enough_data() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> Call: #> stats::lm(formula = ..y ~ ., data = data) #>  #> Coefficients: #>       (Intercept)    lag_0_case_rate    lag_1_case_rate    lag_2_case_rate   #>         0.0190429          0.0022671         -0.0003564          0.0007037   #>   lag_3_case_rate    lag_7_case_rate   lag_14_case_rate   lag_0_death_rate   #>         0.0027288          0.0013392         -0.0002427          0.0926092   #>  lag_7_death_rate  lag_14_death_rate   #>         0.0640675          0.0347603 #>  #> ‚îÄ‚îÄ Postprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 5 Frosting layers. #> 1. layer_predict() #> 2. layer_residual_quantiles() #> 3. layer_add_forecast_date() #> 4. layer_add_target_date() #> 5. layer_threshold() #>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/panel-data.html","id":"example-panel-data-overview","dir":"Articles","previous_headings":"","what":"Example panel data overview","title":"Using epipredict on non-epidemic panel data","text":"vignette, demonstrate using epipredict employment panel data Statistics Canada. using Table 37-10-0115-01: Characteristics median employment income longitudinal cohorts postsecondary graduates two five years graduation, educational qualification field study (primary groupings). full dataset contains yearly median employment income two five years graduation, number graduates. data stratified variables geographic region (Canadian province), education, age group. year range dataset 2010 2017, inclusive. full dataset also contains metadata describes quality data collected. demonstration purposes, make following modifications get subset full dataset: keep provincial-level geographic region (full data also ‚ÄúCanada‚Äù region) keep ‚Äúgood‚Äù better quality data rows, indicated STATUS column Choose subset covariates aggregate across remaining ones. chosen covariates age group, educational qualification. use data epipredict, need convert epi_df format using epiprocess::as_epi_df() additional keys. case, additional keys age_group, edu_qual. Note modifications, encoded time_value type integer. lets us set time_type = \"year\", ensures lag ahead modifications later using correct time units. See epiprocess::epi_df list time_types available. Now, ready use grad_employ_subset epipredict. epi_df contains 1,445 rows 7 columns. quick summary columns epi_df: time_value (time value): year date format geo_value (geo value): province Canada num_graduates (raw, time series value): number graduates med_income_2y (raw, time series value): median employment income 2 years graduation med_income_5y (raw, time series value): median employment income 5 years graduation age_group (key): one two age groups, either 15 34 years, 35 64 years edu_qual (key): one 32 unique educational qualifications, e.g., ‚ÄúMaster‚Äôs diploma‚Äù following sections, go pre-processing data epi_recipe framework, estimating model making predictions within epipredict framework using package‚Äôs canned forecasters.","code":"# Rename for simplicity employ <- grad_employ_subset sample_n(employ, 6) #> An `epi_df` object, 6 x 7 with metadata: #> * geo_type  = custom #> * time_type = integer #> * other_keys = age_group, edu_qual #> * as_of     = 2024-09-18 #>  #> # A tibble: 6 √ó 7 #>   geo_value        age_group      edu_qual           time_value num_graduates #>   <chr>            <fct>          <fct>                   <int>         <dbl> #> 1 Saskatchewan     35 to 64 years Undergraduate cer‚Ä¶       2016           120 #> 2 British Columbia 35 to 64 years Post-baccalaureat‚Ä¶       2017           240 #> 3 Saskatchewan     35 to 64 years Post-baccalaureat‚Ä¶       2012            10 #> 4 Quebec           15 to 34 years Master's certific‚Ä¶       2010            80 #> 5 British Columbia 35 to 64 years Career, technical‚Ä¶       2012          3060 #> 6 New Brunswick    35 to 64 years Career, technical‚Ä¶       2013           230 #> # ‚Ñπ 2 more variables: med_income_2y <dbl>, med_income_5y <dbl>"},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/panel-data.html","id":"pre-processing","dir":"Articles","previous_headings":"Autoregressive (AR) model to predict number of graduates in a year","what":"Pre-processing","title":"Using epipredict on non-epidemic panel data","text":"simple example, let‚Äôs work num_graduates column now. first pre-process standardizing numeric column total within group keys. since raw numeric values vary greatly province province since large differences population. visualization sample small data British Columbia Ontario. Note groups time series information since filtered time series incomplete dates.  predict standardized number graduates (proportion) next year (time t+1t+1) using autoregressive model three lags (.e., AR(3) model). model represented algebraically like : yt+1,ijk=Œ±0+Œ±1ytijk+Œ±2yt‚àí1,ijk+Œ±3yt‚àí2,ijk+œµtijk   y_{t+1,ijk} =   \\alpha_0 + \\alpha_1 y_{tijk} + \\alpha_2 y_{t-1,ijk} + \\alpha_3 y_{t-2,ijk} + \\epsilon_{tijk} ytijy_{tij} proportion graduates time tt location ii age group jj education quality kk. pre-processing step, need create additional columns employ yt+1,ijky_{t+1,ijk}, ytijky_{tijk}, yt‚àí1,ijky_{t-1,ijk}, yt‚àí2,ijky_{t-2,ijk}. via epi_recipe. Note creating epi_recipe alone doesn‚Äôt add outcome predictor columns; recipe just stores instructions adding . epi_recipe add one ahead column representing yt+1,ijky_{t+1,ijk} 3 lag columns representing ytijky_{tijk}, yt‚àí1,ijky_{t-1,ijk}, yt‚àí2,ijky_{t-2,ijk} (‚Äôs accurate think 0th ‚Äúlag‚Äù ‚Äúcurrent‚Äù value 2 lags, ‚Äôs quite processing works). Also note since specified time_type year, lag lead values years. Let‚Äôs apply recipe using prep bake generate view lag ahead columns. can see prep bake steps created new columns according epi_recipe: ahead_1_num_graduates_prop corresponds yt+1,ijky_{t+1,ijk} lag_0_num_graduates_prop, lag_1_num_graduates_prop, lag_2_num_graduates_prop correspond ytijky_{tijk}, yt‚àí1,ijky_{t-1,ijk}, yt‚àí2,ijky_{t-2,ijk} respectively.","code":"employ_small <- employ %>%   group_by(geo_value, age_group, edu_qual) %>%   # Select groups where there are complete time series values   filter(n() >= 6) %>%   mutate(     num_graduates_prop = num_graduates / sum(num_graduates),     med_income_2y_prop = med_income_2y / sum(med_income_2y),     med_income_5y_prop = med_income_5y / sum(med_income_5y)   ) %>%   ungroup() head(employ_small) #> An `epi_df` object, 6 x 10 with metadata: #> * geo_type  = custom #> * time_type = integer #> * other_keys = age_group, edu_qual #> * as_of     = 2024-09-18 #>  #> # A tibble: 6 √ó 10 #>   geo_value           age_group      edu_qual        time_value num_graduates #>   <chr>               <fct>          <fct>                <int>         <dbl> #> 1 Newfoundland and L‚Ä¶ 15 to 34 years Career, techni‚Ä¶       2010           430 #> 2 Newfoundland and L‚Ä¶ 35 to 64 years Career, techni‚Ä¶       2010           140 #> 3 Newfoundland and L‚Ä¶ 15 to 34 years Career, techni‚Ä¶       2010           630 #> 4 Newfoundland and L‚Ä¶ 35 to 64 years Career, techni‚Ä¶       2010           140 #> 5 Newfoundland and L‚Ä¶ 15 to 34 years Undergraduate ‚Ä¶       2010          1050 #> 6 Newfoundland and L‚Ä¶ 35 to 64 years Undergraduate ‚Ä¶       2010           130 #> # ‚Ñπ 5 more variables: med_income_2y <dbl>, med_income_5y <dbl>, #> #   num_graduates_prop <dbl>, med_income_2y_prop <dbl>, ‚Ä¶ employ_small %>%   filter(geo_value %in% c(\"British Columbia\", \"Ontario\")) %>%   filter(grepl(\"degree\", edu_qual, fixed = T)) %>%   group_by(geo_value, time_value, edu_qual, age_group) %>%   summarise(num_graduates_prop = sum(num_graduates_prop), .groups = \"drop\") %>%   ggplot(aes(x = time_value, y = num_graduates_prop, color = geo_value)) +   geom_line() +   scale_colour_manual(values = c(\"Cornflowerblue\", \"Orange\"), name = \"\") +   facet_grid(rows = vars(edu_qual), cols = vars(age_group)) +   xlab(\"Year\") +   ylab(\"Percentage of gratuates\") +   theme(legend.position = \"bottom\") r <- epi_recipe(employ_small) %>%   step_epi_ahead(num_graduates_prop, ahead = 1) %>%   step_epi_lag(num_graduates_prop, lag = 0:2) %>%   step_epi_naomit() r #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs #> Number of variables by role #> raw:        6 #> key:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations #> 1. Leading: num_graduates_prop by 1 #> 2. Lagging: num_graduates_prop by 0, 1, 2 #> 3. ‚Ä¢ Removing rows with NA values in: all_predictors() #> 4. ‚Ä¢ Removing rows with NA values in: all_outcomes() # Display a sample of the pre-processed data bake_and_show_sample <- function(recipe, data, n = 5) {   recipe %>%     prep(data) %>%     bake(new_data = data) %>%     sample_n(n) }  r %>% bake_and_show_sample(employ_small) #> An `epi_df` object, 5 x 14 with metadata: #> * geo_type  = custom #> * time_type = integer #> * other_keys = age_group, edu_qual #> * as_of     = 2024-09-18 #>  #> # A tibble: 5 √ó 14 #>   geo_value        age_group      edu_qual           time_value num_graduates #>   <chr>            <fct>          <fct>                   <dbl>         <dbl> #> 1 Ontario          35 to 64 years Master's diploma         2012            40 #> 2 British Columbia 15 to 34 years Undergraduate deg‚Ä¶       2014         11520 #> 3 Alberta          35 to 64 years Career, technical‚Ä¶       2013          1270 #> 4 Alberta          35 to 64 years Undergraduate deg‚Ä¶       2016          1050 #> 5 Quebec           15 to 34 years Career, technical‚Ä¶       2016          3920 #> # ‚Ñπ 9 more variables: med_income_2y <dbl>, med_income_5y <dbl>, #> #   num_graduates_prop <dbl>, med_income_2y_prop <dbl>, ‚Ä¶"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/panel-data.html","id":"model-estimation-and-prediction","dir":"Articles","previous_headings":"Autoregressive (AR) model to predict number of graduates in a year","what":"Model estimation and prediction","title":"Using epipredict on non-epidemic panel data","text":"Since goal now estimate simple autoregressive model, can use parsnip::linear_reg() default engine lm, fits linear regression using ordinary least squares. use epi_workflow epi_recipe defined pre-processing section along parsnip::linear_reg() model. Note epi_workflow container doesn‚Äôt actually fitting. pass workflow fit() get estimated model coefficients Œ±ÃÇ,=0,...,3\\widehat{\\alpha}_i,\\ =0,...,3. output tells us coefficients fitted model; instance, estimated intercept Œ±ÃÇ0=\\widehat{\\alpha}_0 = 0.109 coefficient ytijky_{tijk} Œ±ÃÇ1=\\widehat\\alpha_1 = 0.324. summary also tells us estimated coefficients significantly different zero. Extracting 95% confidence intervals coefficients also leads us conclusion: coefficient estimates significantly different 0. Now workflow, can generate predictions subset data. demo, predict number graduates using last 2 years dataset. can using augment function . Note predict augment still return epiprocess::epi_df keys present original dataset.","code":"wf_linreg <- epi_workflow(r, linear_reg()) %>%   fit(employ_small) summary(extract_fit_engine(wf_linreg)) #>  #> Call: #> stats::lm(formula = ..y ~ ., data = data) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -0.104501 -0.013043 -0.002708  0.009289  0.210582  #>  #> Coefficients: #>                           Estimate Std. Error t value Pr(>|t|)     #> (Intercept)               0.108532   0.006695  16.211  < 2e-16 *** #> lag_0_num_graduates_prop  0.324251   0.037163   8.725  < 2e-16 *** #> lag_1_num_graduates_prop  0.014190   0.038543   0.368 0.712848     #> lag_2_num_graduates_prop -0.137378   0.036337  -3.781 0.000168 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 0.02993 on 777 degrees of freedom #> Multiple R-squared:  0.1084, Adjusted R-squared:  0.1049  #> F-statistic: 31.47 on 3 and 777 DF,  p-value: < 2.2e-16 confint(extract_fit_engine(wf_linreg)) #>                                2.5 %      97.5 % #> (Intercept)               0.09538942  0.12167466 #> lag_0_num_graduates_prop  0.25130008  0.39720211 #> lag_1_num_graduates_prop -0.06147071  0.08985152 #> lag_2_num_graduates_prop -0.20870743 -0.06604791 latest <- get_test_data(recipe = r, x = employ_small) preds <- stats::predict(wf_linreg, latest) %>% filter(!is.na(.pred)) # Display a sample of the prediction values, excluding NAs preds %>% sample_n(5) #> An `epi_df` object, 5 x 5 with metadata: #> * geo_type  = custom #> * time_type = integer #> * other_keys = age_group, edu_qual #> * as_of     = 2024-09-18 #>  #> # A tibble: 5 √ó 5 #>   geo_value                 age_group      edu_qual          time_value .pred #>   <chr>                     <fct>          <fct>                  <dbl> <dbl> #> 1 New Brunswick             15 to 34 years Professional deg‚Ä¶       2017 0.141 #> 2 British Columbia          15 to 34 years Career, technica‚Ä¶       2017 0.134 #> 3 Nova Scotia               15 to 34 years Master's degree         2017 0.133 #> 4 Ontario                   15 to 34 years Undergraduate ce‚Ä¶       2017 0.161 #> 5 Newfoundland and Labrador 15 to 34 years Master's degree         2017 0.139 augment(wf_linreg, latest) %>% sample_n(5) #> An `epi_df` object, 5 x 11 with metadata: #> * geo_type  = custom #> * time_type = integer #> * other_keys = age_group, edu_qual #> * as_of     = 2024-09-18 #>  #> # A tibble: 5 √ó 11 #>   geo_value        age_group      edu_qual                  time_value  .pred #>   <chr>            <fct>          <fct>                          <dbl>  <dbl> #> 1 British Columbia 35 to 64 years Post-baccalaureate non-g‚Ä¶       2017  0.143 #> 2 Saskatchewan     15 to 34 years Career, technical or pro‚Ä¶       2015 NA     #> 3 Manitoba         15 to 34 years Career, technical or pro‚Ä¶       2016 NA     #> 4 Saskatchewan     35 to 64 years Doctoral degree                 2017  0.135 #> 5 Manitoba         35 to 64 years Other career, technical ‚Ä¶       2016 NA     #> # ‚Ñπ 6 more variables: num_graduates <dbl>, med_income_2y <dbl>, #> #   med_income_5y <dbl>, num_graduates_prop <dbl>, ‚Ä¶"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/panel-data.html","id":"model-diagnostics","dir":"Articles","previous_headings":"Autoregressive (AR) model to predict number of graduates in a year","what":"Model diagnostics","title":"Using epipredict on non-epidemic panel data","text":"First, ‚Äôll plot residuals (, ytijk‚àíyÃÇtijky_{tijk} - \\widehat{y}_{tijk}) fitted values (yÃÇtijk\\widehat{y}_{tijk}).  fitted values vs.¬†residuals plot shows us residuals mostly clustered around zero, form even band around zero line, indicating variance residuals constant. Additionally, fitted values vs.¬†square root standardized residuals makes obvious - spread square root standardized residuals varies fitted values. Q-Q plot shows us residuals heavier tails Normal distribution. normality residuals assumption doesn‚Äôt hold either. Finally, residuals vs.¬†leverage plot shows us influential points based Cook‚Äôs distance (outside red dotted line). Since appear violating linear model assumptions, might consider transforming data differently, considering non-linear model, something else.","code":"par(mfrow = c(2, 2), mar = c(5, 3, 1.2, 0)) plot(extract_fit_engine(wf_linreg))"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/panel-data.html","id":"ar-model-with-exogenous-inputs","dir":"Articles","previous_headings":"","what":"AR model with exogenous inputs","title":"Using epipredict on non-epidemic panel data","text":"Now suppose want model 1-step-ahead 5-year employment income using current two previous values, also incorporating information two time-series dataset: 2-year employment income number graduates previous 2 years. using autoregressive model exogenous inputs, defined follows: yt+1,ijk=Œ±0+Œ±1ytijk+Œ±2yt‚àí1,ijk+Œ±3yt‚àí2,ijk+Œ≤1xtijk+Œ≤2xt‚àí1,ijk+Œ≥2ztijk+Œ≥2zt‚àí1,ijk+œµtijk \\begin{aligned}   y_{t+1,ijk} &=   \\alpha_0 + \\alpha_1 y_{tijk} + \\alpha_2 y_{t-1,ijk} + \\alpha_3 y_{t-2,ijk}\\\\   &\\quad + \\beta_1 x_{tijk} + \\beta_2 x_{t-1,ijk}\\\\   &\\quad + \\gamma_2 z_{tijk} + \\gamma_2 z_{t-1,ijk} + \\epsilon_{tijk} \\end{aligned} ytijky_{tijk} 5-year median income (proportion) time tt (location ii, age group jj education quality kk), xtijkx_{tijk} 2-year median income (proportion) time tt, ztijkz_{tijk} number graduates (proportion) time tt.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/panel-data.html","id":"pre-processing-1","dir":"Articles","previous_headings":"AR model with exogenous inputs","what":"Pre-processing","title":"Using epipredict on non-epidemic panel data","text":", construct epi_recipe detailing pre-processing steps.","code":"rx <- epi_recipe(employ_small) %>%   step_epi_ahead(med_income_5y_prop, ahead = 1) %>%   # 5-year median income has current, and two lags c(0, 1, 2)   step_epi_lag(med_income_5y_prop, lag = 0:2) %>%   # But the two exogenous variables have current values, and 1 lag c(0, 1)   step_epi_lag(med_income_2y_prop, lag = c(0, 1)) %>%   step_epi_lag(num_graduates_prop, lag = c(0, 1)) %>%   step_epi_naomit()  bake_and_show_sample(rx, employ_small) #> An `epi_df` object, 5 x 18 with metadata: #> * geo_type  = custom #> * time_type = integer #> * other_keys = age_group, edu_qual #> * as_of     = 2024-09-18 #>  #> # A tibble: 5 √ó 18 #>   geo_value           age_group      edu_qual        time_value num_graduates #>   <chr>               <fct>          <fct>                <dbl>         <dbl> #> 1 Prince Edward Isla‚Ä¶ 35 to 64 years Undergraduate ‚Ä¶       2017            10 #> 2 British Columbia    35 to 64 years Post-baccalaur‚Ä¶       2014           180 #> 3 Alberta             35 to 64 years Career, techni‚Ä¶       2016          1250 #> 4 Saskatchewan        15 to 34 years Undergraduate ‚Ä¶       2015          2600 #> 5 Saskatchewan        15 to 34 years Doctoral degree       2016            70 #> # ‚Ñπ 13 more variables: med_income_2y <dbl>, med_income_5y <dbl>, #> #   num_graduates_prop <dbl>, med_income_2y_prop <dbl>, ‚Ä¶"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/panel-data.html","id":"model-estimation-post-processing","dir":"Articles","previous_headings":"AR model with exogenous inputs","what":"Model estimation & post-processing","title":"Using epipredict on non-epidemic panel data","text":"estimating model making predictions, let‚Äôs add post-processing steps using frosting layers things: Threshold predictions 0. predicting proportions, can‚Äôt negative. transformed values back dollars people can‚Äôt negative either. Generate prediction intervals based residual quantiles, allowing us quantify uncertainty associated future predicted values. Convert predictions back income values number graduates, rather standardized proportions. via frosting layer layer_population_scaling(). Based summary output model, can examine confidence intervals perform hypothesis tests usual. Let‚Äôs take look predictions along 90% prediction intervals.","code":"# Create dataframe of the sums we used for standardizing # Only have to include med_income_5y since that is our outcome totals <- employ_small %>%   group_by(geo_value, age_group, edu_qual) %>%   summarise(med_income_5y_tot = sum(med_income_5y), .groups = \"drop\")  # Define post-processing steps f <- frosting() %>%   layer_predict() %>%   layer_naomit(.pred) %>%   layer_threshold(.pred, lower = 0) %>%   # 90% prediction interval   layer_residual_quantiles(     symmetrize = FALSE   ) %>%   layer_population_scaling(     .pred, .pred_distn,     df = totals, df_pop_col = \"med_income_5y_tot\"   )  wfx_linreg <- epi_workflow(rx, parsnip::linear_reg()) %>%   fit(employ_small) %>%   add_frosting(f)  summary(extract_fit_engine(wfx_linreg)) #>  #> Call: #> stats::lm(formula = ..y ~ ., data = data) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -0.049668 -0.004509 -0.000516  0.004707  0.049882  #>  #> Coefficients: #>                           Estimate Std. Error t value Pr(>|t|)     #> (Intercept)               0.041278   0.004975   8.298 4.72e-16 *** #> lag_0_med_income_5y_prop  0.320780   0.049348   6.500 1.44e-10 *** #> lag_1_med_income_5y_prop  0.079610   0.049116   1.621  0.10546     #> lag_2_med_income_5y_prop  0.073048   0.033686   2.168  0.03043 *   #> lag_0_med_income_2y_prop  0.118122   0.045579   2.592  0.00973 **  #> lag_1_med_income_2y_prop  0.034455   0.042749   0.806  0.42050     #> lag_0_num_graduates_prop -0.025129   0.013603  -1.847  0.06509 .   #> lag_1_num_graduates_prop  0.078268   0.013396   5.842 7.58e-09 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 0.01056 on 773 degrees of freedom #> Multiple R-squared:  0.3224, Adjusted R-squared:  0.3163  #> F-statistic: 52.54 on 7 and 773 DF,  p-value: < 2.2e-16 latest <- get_test_data(recipe = rx, x = employ_small) predsx <- predict(wfx_linreg, latest)  # Display predictions along with prediction intervals predsx %>%   select(     geo_value, time_value, edu_qual, age_group,     .pred_scaled, .pred_distn_scaled   ) %>%   head() %>%   pivot_quantiles_wider(.pred_distn_scaled) #> An `epi_df` object, 6 x 12 with metadata: #> * geo_type  = custom #> * time_type = integer #> * other_keys = age_group, edu_qual #> * as_of     = 2024-09-18 #>  #> # A tibble: 6 √ó 12 #>   geo_value            time_value edu_qual        age_group      .pred_scaled #>   <chr>                     <dbl> <fct>           <fct>                 <dbl> #> 1 Newfoundland and La‚Ä¶       2017 Career, techni‚Ä¶ 15 to 34 years       45724. #> 2 Newfoundland and La‚Ä¶       2017 Career, techni‚Ä¶ 35 to 64 years       37614. #> 3 Newfoundland and La‚Ä¶       2017 Career, techni‚Ä¶ 15 to 34 years       56992. #> 4 Newfoundland and La‚Ä¶       2017 Career, techni‚Ä¶ 35 to 64 years       47802. #> 5 Newfoundland and La‚Ä¶       2017 Post career, t‚Ä¶ 15 to 34 years       61127. #> 6 Newfoundland and La‚Ä¶       2017 Undergraduate ‚Ä¶ 15 to 34 years       72713. #> # ‚Ñπ 7 more variables: `0.05` <dbl>, `0.1` <dbl>, `0.25` <dbl>, `0.5` <dbl>, #> #   `0.75` <dbl>, `0.9` <dbl>, `0.95` <dbl>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/panel-data.html","id":"using-canned-forecasters","dir":"Articles","previous_headings":"","what":"Using canned forecasters","title":"Using epipredict on non-epidemic panel data","text":"‚Äôve seen can non-epidemiological panel data using recipes frame, epi_recipe pre-processing, epi_workflow model fitting, frosting post-processing. epipredict also comes canned forecasters steps behind scenes simple models. Even though aren‚Äôt working epidemiological data, canned forecasters still work expected, box. demonstrate simple flatline_forecaster direct autoregressive (AR) forecaster arx_forecaster. illustrations, continue use employ_small dataset transformed numeric columns proportions within group keys epi_df.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/panel-data.html","id":"flatline-forecaster","dir":"Articles","previous_headings":"Using canned forecasters","what":"Flatline forecaster","title":"Using epipredict on non-epidemic panel data","text":"first example, ‚Äôll use flatline_forecaster make simple prediction 2-year median income next year, based one previous time point. model representated algebraically : yt+1,ijk=ytijk+œµtijky_{t+1,ijk} = y_{tijk} + \\epsilon_{tijk} ytijky_{tijk} 2-year median income (proportion) time tt.","code":"out_fl <- flatline_forecaster(employ_small, \"med_income_2y_prop\",   args_list = flatline_args_list(ahead = 1) )  out_fl #> ‚ïê‚ïê A basic forecaster of type flatline ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #>  #> This forecaster was fit on 2025-06-23 21:54:07. #>  #> Training data was an <epi_df> with: #> ‚Ä¢ Geography: custom, #> ‚Ä¢ Other keys: age_group and edu_qual, #> ‚Ä¢ Time type: integer, #> ‚Ä¢ Using data up-to-date as of: 2024-09-18. #> ‚Ä¢ With the last data available on 2017 #>  #> ‚îÄ‚îÄ Predictions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> A total of 167 predictions are available for #> ‚Ä¢ 11 unique geographic regions, #> ‚Ä¢ At forecast dates: 2017, #> ‚Ä¢ For target dates: 2018, #>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/panel-data.html","id":"autoregressive-forecaster-with-exogenous-inputs","dir":"Articles","previous_headings":"Using canned forecasters","what":"Autoregressive forecaster with exogenous inputs","title":"Using epipredict on non-epidemic panel data","text":"second example, ‚Äôll use arx_forecaster make prediction 5-year median income based using two lags, using two lags two exogenous variables: 2-year median income number graduates. canned forecaster gives us simple way making forecast since defines recipe, workflow, post-processing steps behind scenes. similar model introduced ‚ÄúAutoregressive Linear Model Exogenous Inputs‚Äù section article, inputs number lags. changes direct AR forecaster, like changing engine, also work expected. use boosted tree model instead linear regression.","code":"arx_args <- arx_args_list(lags = c(0L, 1L), ahead = 1L)  out_arx_lr <- arx_forecaster(employ_small, \"med_income_5y_prop\",   c(\"med_income_5y_prop\", \"med_income_2y_prop\", \"num_graduates_prop\"),   args_list = arx_args )  out_arx_lr #> ‚ïê‚ïê A basic forecaster of type ARX Forecaster ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #>  #> This forecaster was fit on 2025-06-23 21:54:08. #>  #> Training data was an <epi_df> with: #> ‚Ä¢ Geography: custom, #> ‚Ä¢ Other keys: age_group and edu_qual, #> ‚Ä¢ Time type: integer, #> ‚Ä¢ Using data up-to-date as of: 2024-09-18. #> ‚Ä¢ With the last data available on 2017 #>  #> ‚îÄ‚îÄ Predictions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> A total of 166 predictions are available for #> ‚Ä¢ 11 unique geographic regions, #> ‚Ä¢ At forecast dates: 2017, #> ‚Ä¢ For target dates: 2018, #> out_arx_rf <- arx_forecaster(   employ_small, \"med_income_5y_prop\",   c(\"med_income_5y_prop\", \"med_income_2y_prop\", \"num_graduates_prop\"),   trainer = parsnip::boost_tree(mode = \"regression\", trees = 20),   args_list = arx_args )  out_arx_rf #> ‚ïê‚ïê A basic forecaster of type ARX Forecaster ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #>  #> This forecaster was fit on 2025-06-23 21:54:09. #>  #> Training data was an <epi_df> with: #> ‚Ä¢ Geography: custom, #> ‚Ä¢ Other keys: age_group and edu_qual, #> ‚Ä¢ Time type: integer, #> ‚Ä¢ Using data up-to-date as of: 2024-09-18. #> ‚Ä¢ With the last data available on 2017 #>  #> ‚îÄ‚îÄ Predictions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> A total of 166 predictions are available for #> ‚Ä¢ 11 unique geographic regions, #> ‚Ä¢ At forecast dates: 2017, #> ‚Ä¢ For target dates: 2018, #>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/panel-data.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Using epipredict on non-epidemic panel data","text":"purpose epipredict allow tidymodels operate epidemiology data, can easily adapted (workflows canned forecasters) work generic panel data modelling.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/update.html","id":"main-goal-of-the-addupdateremove-and-adjust-functions","dir":"Articles","previous_headings":"","what":"Main goal of the add/update/remove and adjust functions","title":"Using the add/update/remove and adjust functions","text":"primary goal update adjust functions allow user modify step, layer, epi_recipe, frosting, part epi_workflow create new object time wish make change pre-processing, fitting, post-processing. context pre-processing, goal update functions add/remove/update epi_recipe step . , add_epi_recipe(), update_epi_recipe(), remove_epi_recipe() add/update/remove entire epi_recipe epi_workflow well adjust_epi_recipe() adjust particular step epi_recipe epi_workflow step number name. model, one may Add_model(), Update_model(), Remove_model() epi_workflow.1 post-processing, goal update frosting object layer , add_frosting(), remove_frosting(), update_frosting() add/update/remove entire frosting object epi_workflow well adjust_frosting() adjust particular layer frosting epi_workflow number name. summary function uses processing step shown following table: Since adding/removing/updating frosting well adjusting layer frosting object proceeds way performing tasks epi_recipe, focus implementing epi_recipe vignette briefly go examples frosting object.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/update.html","id":"addupdateremove-an-epi_recipe-in-an-epi_workflow","dir":"Articles","previous_headings":"","what":"Add/update/remove an epi_recipe in an epi_workflow","title":"Using the add/update/remove and adjust functions","text":"start built-covid_case_death_rates dataset contains JHU daily COVID-19 cases deaths state take subset Nov.¬†1, 2021 Dec.¬†31, 2021 four states Alaska, California, New York, South Carolina. , construct simple epi_recipe object named r, lag death rates 0, 7, 14 days, lead death rate 14 days, omit NA values predictors outcomes (set skip = TRUE skip processing outcome variable recipe baked). add recipe epi_workflow object inputting r add_epi_recipe() function: may go add fitted linear model epi_workflow: stage, suppose decide overhaul recipe different set pre-processing steps want make multiple changes existing steps, desire keep remainder epi_workflow . can use update_epi_recipe() function trade current recipe r another recipe r2 wf follows: can see output wf depicts sequence steps r2 instead r, indicates update successful. longer approach achieve end use remove_epi_recipe() remove old recipe add_epi_recipe() add new one. hood, update_epi_recipe() function operates way. add_epi_recipe() remove_epi_recipe() functions offload workflows versions functions much possible. main reason using epipredict version ensure retain epi_workflow class. see , let‚Äôs look happens remove current epi_recipe using workflows::remove_recipe() inspect class wf: can observe wf longer epi_workflow workflow. demoted workflow. epi_workflows workflows, workflows epi_workflows, meaning may compatibility issues limitations tools may used epipredict package plain workflow object. Now, checked happens epi_recipe remove , note actually store change wf. Hence, epi_workflow remains unchanged. One thing notice workflow output model fit remains r recipe. illustrates important point - operations performed using old recipe updated automatically. careful fit model using new recipe, r2. Similarly, predictions made using old recipe, re-generated using version epi_workflow contains updated recipe. can use Update_model() replace model used wf, fit : Alternatively, may use Remove_model() followed Add_model() combination effect.","code":"jhu <- covid_case_death_rates %>%   filter(time_value >= as.Date(\"2021-11-01\"), geo_value %in% c(\"ak\", \"ca\", \"ny\", \"sc\"))  jhu #> An `epi_df` object, 244 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 244 √ó 4 #>   geo_value time_value case_rate death_rate #>   <chr>     <date>         <dbl>      <dbl> #> 1 ak        2021-11-01      87.9      0.494 #> 2 ca        2021-11-01      15.6      0.241 #> 3 ny        2021-11-01      19.9      0.177 #> 4 sc        2021-11-01      16.0      0.531 #> 5 ak        2021-11-02      83.2      0.395 #> 6 ca        2021-11-02      15.4      0.200 #> # ‚Ñπ 238 more rows r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 14) %>%   step_naomit(all_predictors()) %>%   step_naomit(all_outcomes(), skip = TRUE) wf <- epi_workflow() %>%   add_epi_recipe(r)  wf #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: None #> Postprocessor: None #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 4 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_ahead() #> 3. step_naomit() #> 4. step_naomit() #> # Fit a linear model wf <- epi_workflow(r, linear_reg()) %>% fit(jhu)  wf #>  #> ‚ïê‚ïê Epi Workflow [trained] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: linear_reg() #> Postprocessor: None #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 4 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_ahead() #> 3. step_naomit() #> 4. step_naomit() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> Call: #> stats::lm(formula = ..y ~ ., data = data) #>  #> Coefficients: #>       (Intercept)   lag_0_death_rate   lag_7_death_rate  lag_14_death_rate   #>           0.43314           -0.75303            0.02903            0.09068 #> r2 <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 1, 7, 14)) %>%   step_epi_lag(case_rate, lag = c(0:7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()  wf <- update_epi_recipe(wf, r2) wf #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: linear_reg() #> Postprocessor: None #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 5 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_lag() #> 3. step_epi_ahead() #> 4. step_naomit() #> 5. step_naomit() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> Call: #> stats::lm(formula = ..y ~ ., data = data) #>  #> Coefficients: #>       (Intercept)   lag_0_death_rate   lag_7_death_rate  lag_14_death_rate   #>           0.43314           -0.75303            0.02903            0.09068 #> wf %>% class() # class before #> [1] \"epi_workflow\" \"workflow\" remove_recipe(wf) %>% class() # class after removing recipe using workflows function #> [1] \"workflow\" wf #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: linear_reg() #> Postprocessor: None #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 5 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_lag() #> 3. step_epi_ahead() #> 4. step_naomit() #> 5. step_naomit() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> Call: #> stats::lm(formula = ..y ~ ., data = data) #>  #> Coefficients: #>       (Intercept)   lag_0_death_rate   lag_7_death_rate  lag_14_death_rate   #>           0.43314           -0.75303            0.02903            0.09068 #> # fit linear model wf <- Update_model(wf, linear_reg()) %>% fit(jhu) wf #>  #> ‚ïê‚ïê Epi Workflow [trained] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: linear_reg() #> Postprocessor: None #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 5 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_lag() #> 3. step_epi_ahead() #> 4. step_naomit() #> 5. step_naomit() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> Call: #> stats::lm(formula = ..y ~ ., data = data) #>  #> Coefficients: #>       (Intercept)   lag_0_death_rate   lag_1_death_rate   lag_7_death_rate   #>          0.290875          -0.156658           0.054776          -0.348165   #> lag_14_death_rate    lag_0_case_rate    lag_1_case_rate    lag_2_case_rate   #>         -0.303906           0.009033          -0.009466          -0.005362   #>   lag_3_case_rate    lag_4_case_rate    lag_5_case_rate    lag_6_case_rate   #>         -0.006236           0.004849           0.005536          -0.013340   #>   lag_7_case_rate   lag_14_case_rate   #>          0.011320           0.011674 #>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/update.html","id":"addupdateremove-a-frosting-object-in-an-epi_workflow","dir":"Articles","previous_headings":"","what":"Add/update/remove a frosting object in an epi_workflow","title":"Using the add/update/remove and adjust functions","text":"now generate create frosting object post-processing predictions. initial frosting object, f, simply implement predictions fitted epi_workflow: Suppose decide augment post-processing include threshold enforce predictions least 0. well, let‚Äôs include forecast target dates separate columns. update frosting leaving remainder epi_workflow , can use update_frosting() function follows: Internally, works removing old frosting followed adding new frosting, just like update recipe model. decide want frosting post-processing , can remove frosting object workflow make predictions follows: can see results p3 p1, simply prediction layer frosting post-processing container.","code":"f <- frosting() %>%   layer_predict()  wf1 <- wf %>% add_frosting(f) p1 <- forecast(wf1) p1 #> An `epi_df` object, 4 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 4 √ó 3 #>   geo_value time_value   .pred #>   <chr>     <date>       <dbl> #> 1 ak        2021-12-31 -0.206  #> 2 ca        2021-12-31  0.0992 #> 3 ny        2021-12-31  0.295  #> 4 sc        2021-12-31  0.351 # Update frosting in a workflow and predict f2 <- frosting() %>%   layer_predict() %>%   layer_threshold(.pred) %>%   layer_add_forecast_date() %>%   layer_add_target_date()  wf2 <- wf1 %>% update_frosting(f2) p2 <- forecast(wf2) p2 #> An `epi_df` object, 4 x 5 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 4 √ó 5 #>   geo_value time_value  .pred forecast_date target_date #>   <chr>     <date>      <dbl> <date>        <date>      #> 1 ak        2021-12-31 0      2021-12-31    2022-01-07  #> 2 ca        2021-12-31 0.0992 2021-12-31    2022-01-07  #> 3 ny        2021-12-31 0.295  2021-12-31    2022-01-07  #> 4 sc        2021-12-31 0.351  2021-12-31    2022-01-07 update_frosting #> function (x, frosting, ...)  #> { #>     rlang::check_dots_empty() #>     x <- remove_frosting(x) #>     add_frosting(x, frosting) #> } #> <bytecode: 0x55a1ff1b2d30> #> <environment: namespace:epipredict> wf3 <- wf2 %>% remove_frosting() p3 <- forecast(wf3) p3 #> An `epi_df` object, 4 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 4 √ó 3 #>   geo_value time_value   .pred #>   <chr>     <date>       <dbl> #> 1 ak        2021-12-31 -0.206  #> 2 ca        2021-12-31  0.0992 #> 3 ny        2021-12-31  0.295  #> 4 sc        2021-12-31  0.351"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/update.html","id":"adjust-a-single-step-of-an-epi_recipe","dir":"Articles","previous_headings":"","what":"Adjust a single step of an epi_recipe","title":"Using the add/update/remove and adjust functions","text":"Suppose just want change single step epi_recipe (either standalone part epi_workflow). Instead replacing entire epi_recipe, can use adjust_epi_recipe() function. function, step adjusted indicated either step number name which_step parameter. , parameter name update value must inputted .... instance, suppose decide lead death_rate 14 days instead 7. may adjust step wf recipe setting which_step step number order operations, can obtained inspecting r2 tidy summary : Alternatively, may adjust step name specifying full name step, step_epi_ahead, which_step: least two steps recipe share name, specifying name which_step throw error adjust_epi_recipe() intended used modify multiple steps . way, , modify step name another indicate number ordering steps. example, r2 two steps named step_epi_lag - first step lag death rate, second lag case rate. want modify lags case_rate variable, specify step number 2 which_step. adjust recipe directly way adjust recipe workflow. main difference input wf first argument adjust_epi_recipe() rather r2. Note adjust r2 object directly, adjusting recipe epi_workflow. , modify step r2, change automatically transfer wf. need modify recipe wf directly (adjust_epi_recipe() wf) update recipe wf new epi_recipe undergone adjustment (using update_epi_recipe()):","code":"extract_preprocessor(wf) # step_epi_ahead is the third step in r2 #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations #> 1. Lagging: death_rate by 0, 1, 7, 14 #> 2. Lagging: case_rate by 0, 1, 2, 3, 4, 5, 6, 7, 14 #> 3. Leading: death_rate by 7 #> 4. ‚Ä¢ Removing rows with NA values in: all_predictors() #> 5. ‚Ä¢ Removing rows with NA values in: all_outcomes() tidy(extract_preprocessor(wf)) # tidy tibble summary of r2 #> # A tibble: 5 √ó 6 #>   number operation type      trained skip  id              #>    <int> <chr>     <chr>     <lgl>   <lgl> <chr>           #> 1      1 step      epi_lag   FALSE   FALSE epi_lag_9QeuR   #> 2      2 step      epi_lag   FALSE   FALSE epi_lag_8HfdV   #> 3      3 step      epi_ahead FALSE   FALSE epi_ahead_HIyvQ #> 4      4 step      naomit    FALSE   FALSE naomit_vjF0H    #> 5      5 step      naomit    FALSE   TRUE  naomit_gF0fi  wf <- wf %>% adjust_epi_recipe(which_step = 3, ahead = 14) wf %>% adjust_epi_recipe(which_step = \"step_epi_ahead\", ahead = 14) # not overwrite r2 because same result #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: linear_reg() #> Postprocessor: None #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 5 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_lag() #> 3. step_epi_ahead() #> 4. step_naomit() #> 5. step_naomit() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> Call: #> stats::lm(formula = ..y ~ ., data = data) #>  #> Coefficients: #>       (Intercept)   lag_0_death_rate   lag_1_death_rate   lag_7_death_rate   #>          0.290875          -0.156658           0.054776          -0.348165   #> lag_14_death_rate    lag_0_case_rate    lag_1_case_rate    lag_2_case_rate   #>         -0.303906           0.009033          -0.009466          -0.005362   #>   lag_3_case_rate    lag_4_case_rate    lag_5_case_rate    lag_6_case_rate   #>         -0.006236           0.004849           0.005536          -0.013340   #>   lag_7_case_rate   lag_14_case_rate   #>          0.011320           0.011674 #> wf <- wf %>% adjust_epi_recipe(which_step = 2, lag = c(0, 1, 7, 14, 21))  extract_preprocessor(wf) #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations #> 1. Lagging: death_rate by 0, 1, 7, 14 #> 2. Lagging: case_rate by 0, 1, 7, 14, 21 #> 3. Leading: death_rate by 14 #> 4. ‚Ä¢ Removing rows with NA values in: all_predictors() #> 5. ‚Ä¢ Removing rows with NA values in: all_outcomes() adjust_epi_recipe(r2, which_step = 2, lag = c(0, 1, 7, 14, 21)) # should be same result as above #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations #> 1. Lagging: death_rate by 0, 1, 7, 14 #> 2. Lagging: case_rate by 0, 1, 7, 14, 21 #> 3. Leading: death_rate by 7 #> 4. ‚Ä¢ Removing rows with NA values in: all_predictors() #> 5. ‚Ä¢ Removing rows with NA values in: all_outcomes() r2 <- adjust_epi_recipe(r2, which_step = 2, lag = 0:21)  extract_preprocessor(wf) #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations #> 1. Lagging: death_rate by 0, 1, 7, 14 #> 2. Lagging: case_rate by 0, 1, 7, 14, 21 #> 3. Leading: death_rate by 14 #> 4. ‚Ä¢ Removing rows with NA values in: all_predictors() #> 5. ‚Ä¢ Removing rows with NA values in: all_outcomes()"},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/update.html","id":"adjust-a-single-layer-of-a-frosting","dir":"Articles","previous_headings":"","what":"Adjust a single layer of a frosting","title":"Using the add/update/remove and adjust functions","text":"Adjusting layer frosting object proceeds way adjusting step epi_recipe . want change single layer frosting (either standalone object part epi_workflow), can use adjust_frosting() function wherein layer adjusted indicated either number name which_layer parameter. addition, argument name update value must inputted .... Let‚Äôs work frosting object directly instead working epi_workflow simple, illustrative example. Recall frosting f2 following layers: Suppose decide change upper bound prediction threshold 10 instead Inf. can adjust layer frosting object setting which_layer layer number, 3 (can found inspecting f2 tidy(f2)): Alternatively, may adjust layer specifying full name, layer_threshold, which_layer, achieve result:","code":"f2 #>  #> ‚îÄ‚îÄ Frosting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Layers #> 1. Creating predictions: \"<calculated>\" #> 2. Thresholding predictions: .pred to [0, Inf) #> 3. Adding forecast date: \"<calculated>\" #> 4. Adding target date: \"<calculated>\" f2 <- f2 %>% adjust_frosting(which_layer = 2, upper = 10)  f2 #>  #> ‚îÄ‚îÄ Frosting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Layers #> 1. Creating predictions: \"<calculated>\" #> 2. Thresholding predictions: .pred to [0, 10] #> 3. Adding forecast date: \"<calculated>\" #> 4. Adding target date: \"<calculated>\" f2 %>% adjust_frosting(which_layer = \"layer_threshold\", upper = 10) # not overwrite f2 because same result #>  #> ‚îÄ‚îÄ Frosting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Layers #> 1. Creating predictions: \"<calculated>\" #> 2. Thresholding predictions: .pred to [0, 10] #> 3. Adding forecast date: \"<calculated>\" #> 4. Adding target date: \"<calculated>\""},{"path":"https://cmu-delphi.github.io/epipredict/dev/articles/update.html","id":"on-the-tidy-method-to-inspect-an-epi_recipe-or-a-frosting-object","dir":"Articles","previous_headings":"","what":"On the tidy method to inspect an epi_recipe or a frosting object","title":"Using the add/update/remove and adjust functions","text":"tidy method, used epi_recipe, return data frame contains specific overview information recipe including operation number, operation class (either ‚Äústep‚Äù ‚Äúcheck‚Äù), type method, boolean value indicate whether prep() used estimate operation, boolean value indicate whether step applied bake() called, id operation. contrast, printing epi_recipe object shows inputs (number roles variables) well ordering brief written summary operations: general structure persists compare output frosting object tidy tibble. However, longer output specific recipe roles recipe output trained skip columns tidy tibble . Thus, output frosting object tidy tibble simplified comparison epi_recipe.","code":"tidy(r2) #> # A tibble: 5 √ó 6 #>   number operation type      trained skip  id              #>    <int> <chr>     <chr>     <lgl>   <lgl> <chr>           #> 1      1 step      epi_lag   FALSE   FALSE epi_lag_9QeuR   #> 2      2 step      epi_lag   FALSE   FALSE epi_lag_8HfdV   #> 3      3 step      epi_ahead FALSE   FALSE epi_ahead_HIyvQ #> 4      4 step      naomit    FALSE   FALSE naomit_vjF0H    #> 5      5 step      naomit    FALSE   TRUE  naomit_gF0fi r2 #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations #> 1. Lagging: death_rate by 0, 1, 7, 14 #> 2. Lagging: case_rate by 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, #> 15, #> 3. 16, 17, 18,... #> 4. Leading: death_rate by 7 #> 5. ‚Ä¢ Removing rows with NA values in: all_predictors() #> 6. ‚Ä¢ Removing rows with NA values in: all_outcomes() f #>  #> ‚îÄ‚îÄ Frosting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Layers #> 1. Creating predictions: \"<calculated>\"  tidy(f) #> # A tibble: 1 √ó 4 #>   number operation type    id                    #>    <int> <chr>     <chr>   <chr>                 #> 1      1 layer     predict predict_default_qZ3vE"},{"path":"https://cmu-delphi.github.io/epipredict/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel J. McDonald. Author, maintainer. Ryan Tibshirani. Author. Dmitry Shemetov. Author. David Weber. Author. Delphi Research Group. Copyright holder, funder. Logan Brooks. Author. Rachel Lobay. Author. Maggie Liu. Contributor. Ken Mawer. Contributor. Chloe . Contributor. Jacob Bien. Contributor.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"McDonald D, Tibshirani R, Shemetov D, Weber D, Brooks L, Lobay R (2025). epipredict: Basic epidemiology forecasting methods. R package version 0.1.15, https://github.com/cmu-delphi/epipredict/.","code":"@Manual{,   title = {epipredict: Basic epidemiology forecasting methods},   author = {Daniel J. McDonald and Ryan Tibshirani and Dmitry Shemetov and David Weber and Logan Brooks and Rachel Lobay},   year = {2025},   note = {R package version 0.1.15},   url = {https://github.com/cmu-delphi/epipredict/}, }"},{"path":"https://cmu-delphi.github.io/epipredict/dev/index.html","id":"epipredict","dir":"","previous_headings":"","what":"Basic epidemiology forecasting methods","title":"Basic epidemiology forecasting methods","text":"{epipredict} framework building transformation forecasting pipelines epidemiological panel time-series datasets. addition tools building forecasting pipelines, contains number ‚Äúcanned‚Äù forecasters meant run little modification easy way get started forecasting. designed work well {epiprocess}, utility time series handling geographic processing epidemiological context. packages meant work well panel data provided {epidatr}. Pre-compiled example datasets also available {epidatasets}. looking detail beyond package documentation, see forecasting book.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Basic epidemiology forecasting methods","text":"Unless ‚Äôre planning contributing package development, suggest using stable version. install, run: documentation stable version https://cmu-delphi.github.io/epipredict, development version https://cmu-delphi.github.io/epipredict/dev.","code":"# Stable version pak::pkg_install(\"cmu-delphi/epipredict@main\")  # Dev version pak::pkg_install(\"cmu-delphi/epipredict@dev\")"},{"path":"https://cmu-delphi.github.io/epipredict/dev/index.html","id":"motivating-example","dir":"","previous_headings":"","what":"Motivating example","title":"Basic epidemiology forecasting methods","text":"demonstrate using {epipredict} forecasting, suppose want predict COVID-19 deaths per 100k people subset states using subset Johns Hopkins Center Systems Science Engineering deaths data. fold, pull dataset epidata API clean . section intended demonstrate ubiquitous cleaning operations needed able forecast. subset dataset prepared also included ready--go {epipredict} covid_case_death_rates. First pull jhu-csse cases deaths data Delphi API using {epidatr} package: Since visualizing results every geography somewhat overwhelming, ‚Äôll train subset locations.  typical dataset, need cleaning make actually usable; ‚Äôll use utilities {epiprocess} . Specifically ‚Äôll trim outliers, especially negative values: downloading cleaning deaths per capita, well cases per 100k people, can plot subset states, marking desired forecast date vertical line:  make forecast, use simple ‚Äúcanned‚Äù auto-regressive forecaster predict death rate four weeks future using lagged1 deaths cases. model setup, using predictors case rate lagged 0-3 days, one week, two weeks, death rate lagged 0-2 weeks. result four_week_ahead fitted model object used time future create different forecasts, set predicted values (prediction intervals) location 28 days forecast date. Plotting prediction intervals true values location subset2:  tibble quantile level-value pairs: orange dot gives point prediction, blue intervals give 25-75%, 10-90%, 2.5-97.5% inter-quantile ranges3. particular day locations, forecasts relatively accurate, true data least within 10-90% interval. couple things note: epipredict methods primarily direct forecasters; means don‚Äôt need predict 1, 2,‚Ä¶, 27 days ahead predict 28 days ahead. existing engines geo-pooled, meaning training data shared across geographies. advantage increasing amount available training data, restriction data needs comparable scales, rates.","code":"library(epipredict) library(epidatr) library(epiprocess) library(dplyr) library(ggplot2) used_locations <- c(\"ca\", \"ma\", \"ny\", \"tx\") forecast_date <- as.Date(\"2021-08-01\") cases <- pub_covidcast(   source = \"jhu-csse\",   signals = \"confirmed_7dav_incidence_prop\",   time_type = \"day\",   geo_type = \"state\",   time_values = epirange(20200601, 20211231),   geo_values = \"*\" ) |>   select(geo_value, time_value, case_rate = value)  deaths <- pub_covidcast(   source = \"jhu-csse\",   signals = \"deaths_7dav_incidence_prop\",   time_type = \"day\",   geo_type = \"state\",   time_values = epirange(20200601, 20211231),   geo_values = \"*\" ) |>   select(geo_value, time_value, death_rate = value) cases_deaths <-   full_join(cases, deaths, by = c(\"time_value\", \"geo_value\")) |>   filter(geo_value %in% used_locations) |>   as_epi_df(as_of = as.Date(\"2022-01-01\")) # plotting the data as it was downloaded cases_deaths |>   autoplot(     case_rate,     death_rate,     .color_by = \"none\"   ) +   facet_grid(     rows = vars(.response_name),     cols = vars(geo_value),     scale = \"free\"   ) +   scale_x_date(date_breaks = \"3 months\", date_labels = \"%Y %b\") +   theme(axis.text.x = element_text(angle = 90, hjust = 1)) cases_deaths <-   cases_deaths |>   group_by(geo_value) |>   mutate(     outlr_death_rate = detect_outlr_rm(       time_value, death_rate,       detect_negatives = TRUE     ),     outlr_case_rate = detect_outlr_rm(       time_value, case_rate,       detect_negatives = TRUE     )   ) |>   unnest(cols = starts_with(\"outlr\"), names_sep = \"_\") |>   ungroup() |>   mutate(     death_rate = outlr_death_rate_replacement,     case_rate = outlr_case_rate_replacement   ) |>   select(geo_value, time_value, case_rate, death_rate) forecast_date_label <-   tibble(     geo_value = rep(used_locations, 2),     .response_name = c(rep(\"case_rate\", 4), rep(\"death_rate\", 4)),     dates = rep(forecast_date - 7 * 2, 2 * length(used_locations)),     heights = c(rep(150, 4), rep(0.75, 4))   ) processed_data_plot <-   cases_deaths |>   filter(geo_value %in% used_locations) |>   autoplot(     case_rate,     death_rate,     .color_by = \"none\"   ) +   facet_grid(     rows = vars(.response_name),     cols = vars(geo_value),     scale = \"free\"   ) +   geom_vline(aes(xintercept = forecast_date)) +   geom_text(     data = forecast_date_label,     aes(x = dates, label = \"forecast\\ndate\", y = heights),     size = 3, hjust = \"right\"   ) +   scale_x_date(date_breaks = \"3 months\", date_labels = \"%Y %b\") +   theme(axis.text.x = element_text(angle = 90, hjust = 1)) four_week_ahead <- arx_forecaster(   cases_deaths |> filter(time_value <= forecast_date),   outcome = \"death_rate\",   predictors = c(\"case_rate\", \"death_rate\"),   args_list = arx_args_list(     lags = list(c(0, 1, 2, 3, 7, 14), c(0, 7, 14)),     ahead = 4 * 7,     quantile_levels = c(0.1, 0.25, 0.5, 0.75, 0.9)   ) ) four_week_ahead #> ‚ïê‚ïê A basic forecaster of type ARX Forecaster ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #>  #> This forecaster was fit on 2025-05-22 11:56:44. #>  #> Training data was an <epi_df> with: #> ‚Ä¢ Geography: state, #> ‚Ä¢ Time type: day, #> ‚Ä¢ Using data up-to-date as of: 2022-01-01. #> ‚Ä¢ With the last data available on 2021-08-01 #>  #> ‚îÄ‚îÄ Predictions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> A total of 4 predictions are available for #> ‚Ä¢ 4 unique geographic regions, #> ‚Ä¢ At forecast date: 2021-08-01, #> ‚Ä¢ For target date: 2021-08-29, #> epiworkflow <- four_week_ahead$epi_workflow restricted_predictions <-   four_week_ahead$predictions |>   rename(time_value = target_date, value = .pred) |>   mutate(.response_name = \"death_rate\") forecast_plot <-   four_week_ahead |>   autoplot(observed_response = cases_deaths) +   geom_vline(aes(xintercept = forecast_date)) +   geom_text(     data = forecast_date_label %>% filter(.response_name == \"death_rate\"),     aes(x = dates, label = \"forecast\\ndate\", y = heights),     size = 3, hjust = \"right\"   ) +   scale_x_date(date_breaks = \"3 months\", date_labels = \"%y %b\") +   theme(axis.text.x = element_text(angle = 90, hjust = 1)) four_week_ahead$predictions |>   select(-.pred) |>   pivot_quantiles_longer(.pred_distn) |>   select(geo_value, forecast_date, target_date, quantile = .pred_distn_quantile_level, value = .pred_distn_value) #> # A tibble: 20 √ó 5 #>   geo_value forecast_date target_date quantile  value #>   <chr>     <date>        <date>         <dbl>  <dbl> #> 1 ca        2021-08-01    2021-08-29      0.1  0.198  #> 2 ca        2021-08-01    2021-08-29      0.25 0.285  #> 3 ca        2021-08-01    2021-08-29      0.5  0.345  #> 4 ca        2021-08-01    2021-08-29      0.75 0.405  #> 5 ca        2021-08-01    2021-08-29      0.9  0.491  #> 6 ma        2021-08-01    2021-08-29      0.1  0.0277 #> # ‚Ñπ 14 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/dev/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting Help","title":"Basic epidemiology forecasting methods","text":"encounter bug feature request, feel free file issue GitHub page. questions, feel free reach authors, either via contact form, email, InsightNet Slack.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/Add_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a model to an epi_workflow ‚Äî Add_model","title":"Add a model to an epi_workflow ‚Äî Add_model","text":"Add model epi_workflow","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/Add_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a model to an epi_workflow ‚Äî Add_model","text":"","code":"Add_model(x, spec, ..., formula = NULL)  Remove_model(x)  Update_model(x, spec, ..., formula = NULL)  # S3 method for class 'epi_workflow' Add_model(x, spec, ..., formula = NULL)  # S3 method for class 'epi_workflow' Remove_model(x)  # S3 method for class 'epi_workflow' Update_model(x, spec, ..., formula = NULL)  # S3 method for class 'workflow' Add_model(x, spec, ..., formula = NULL)  # S3 method for class 'workflow' Remove_model(x)  # S3 method for class 'workflow' Update_model(x, spec, ..., formula = NULL)  add_model(x, spec, ..., formula = NULL)  remove_model(x)  update_model(x, spec, ..., formula = NULL)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/Add_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a model to an epi_workflow ‚Äî Add_model","text":"x epi_workflow. spec parsnip model specification. ... used. formula optional formula override specify terms model. Typically, terms extracted formula recipe preprocessing methods. However, models (like survival bayesian models) use formula preprocess, specify structure model. cases, formula specifying model structure must passed unchanged model call . argument used purposes.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/Add_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a model to an epi_workflow ‚Äî Add_model","text":"x, updated new, updated, removed model.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/Add_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a model to an epi_workflow ‚Äî Add_model","text":"behaviour workflows::add_model() also ensures returned object epi_workflow. family called Add_* / Update_* / Remove_* avoid masking related functions {workflows}. also provide aliases lower-case names. However, event {workflows} loaded {epipredict}, may fail function properly.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/Add_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a model to an epi_workflow ‚Äî Add_model","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7)  rf_model <- rand_forest(mode = \"regression\")  wf <- epi_workflow(r)  wf <- wf %>% Add_model(rf_model) wf #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: rand_forest() #> Postprocessor: None #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 2 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_ahead() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Random Forest Model Specification (regression) #>  #> Computational engine: ranger  #>  #>   lm_model <- linear_reg()  wf <- Update_model(wf, lm_model) wf #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: linear_reg() #> Postprocessor: None #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 2 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_ahead() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Linear Regression Model Specification (regression) #>  #> Computational engine: lm  #>  #>   wf <- Remove_model(wf) wf #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: None #> Postprocessor: None #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 2 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_ahead() #>  #>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_epi_recipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Add/remove/update the epi_recipe of an epi_workflow ‚Äî add_epi_recipe","title":"Add/remove/update the epi_recipe of an epi_workflow ‚Äî add_epi_recipe","text":"add_recipe() specifies terms model preprocessing required usage recipe. remove_recipe() removes recipe well downstream objects update_recipe() first removes recipe, replaces previous recipe new one.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_epi_recipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add/remove/update the epi_recipe of an epi_workflow ‚Äî add_epi_recipe","text":"","code":"add_epi_recipe(x, recipe, ..., blueprint = default_epi_recipe_blueprint())  remove_epi_recipe(x)  update_epi_recipe(x, recipe, ..., blueprint = default_epi_recipe_blueprint())"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_epi_recipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add/remove/update the epi_recipe of an epi_workflow ‚Äî add_epi_recipe","text":"x workflow epi_workflow recipe epi recipe recipe ... used blueprint hardhat blueprint used fine tuning preprocessing default_epi_recipe_blueprint() used. Note preprocessing done separate preprocessing might done automatically underlying model.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_epi_recipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add/remove/update the epi_recipe of an epi_workflow ‚Äî add_epi_recipe","text":"x, updated new recipe preprocessor.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_epi_recipe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add/remove/update the epi_recipe of an epi_workflow ‚Äî add_epi_recipe","text":"add_epi_recipe() behaviour workflows::add_recipe() sets different default blueprint automatically handle epiprocess::epi_df() data.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_epi_recipe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add/remove/update the epi_recipe of an epi_workflow ‚Äî add_epi_recipe","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-08-01\")  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_epi_naomit()  workflow <- epi_workflow() %>%   add_epi_recipe(r)  workflow #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: None #> Postprocessor: None #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 5 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_ahead() #> 3. step_epi_lag() #> 4. step_naomit() #> 5. step_naomit() #>  #>   r2 <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7)  workflow <- update_epi_recipe(workflow, r2)  workflow <- remove_epi_recipe(workflow)  workflow #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: None #> Model: None #> Postprocessor: None #>  #>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_frosting.html","id":null,"dir":"Reference","previous_headings":"","what":"Add/remove/update the frosting of an epi_workflow ‚Äî add_frosting","title":"Add/remove/update the frosting of an epi_workflow ‚Äî add_frosting","text":"Add/remove/update frosting epi_workflow","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_frosting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add/remove/update the frosting of an epi_workflow ‚Äî add_frosting","text":"","code":"add_frosting(x, frosting, ...)  remove_frosting(x)  update_frosting(x, frosting, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_frosting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add/remove/update the frosting of an epi_workflow ‚Äî add_frosting","text":"x workflow frosting frosting object created using frosting(). ... used.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_frosting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add/remove/update the frosting of an epi_workflow ‚Äî add_frosting","text":"x, updated new frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_frosting.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add/remove/update the frosting of an epi_workflow ‚Äî add_frosting","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\")) r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7)  wf <- epi_workflow(r, linear_reg()) %>% fit(jhu) latest <- jhu %>%   filter(time_value >= max(time_value) - 14)  # Add frosting to a workflow and predict f <- frosting() %>%   layer_predict() %>%   layer_naomit(.pred) wf1 <- wf %>% add_frosting(f) p1 <- predict(wf1, latest) p1 #> An `epi_df` object, 3 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 3 #>   geo_value time_value .pred #>   <chr>     <date>     <dbl> #> 1 ak        2021-12-31 0.245 #> 2 ca        2021-12-31 0.312 #> 3 ny        2021-12-31 0.295  # Update frosting in a workflow and predict f2 <- frosting() %>% layer_predict() wf2 <- wf1 %>% update_frosting(f2) p2 <- predict(wf2, latest) p2 #> An `epi_df` object, 108 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 108 √ó 3 #>    geo_value time_value .pred #>    <chr>     <date>     <dbl> #>  1 ak        2021-12-10    NA #>  2 ca        2021-12-10    NA #>  3 ny        2021-12-10    NA #>  4 ak        2021-12-11    NA #>  5 ca        2021-12-11    NA #>  6 ny        2021-12-11    NA #>  7 ak        2021-12-12    NA #>  8 ca        2021-12-12    NA #>  9 ny        2021-12-12    NA #> 10 ak        2021-12-13    NA #> # ‚Ñπ 98 more rows  # Remove frosting from the workflow and predict wf3 <- wf2 %>% remove_frosting() p3 <- predict(wf3, latest) p3 #> An `epi_df` object, 108 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 108 √ó 3 #>    geo_value time_value .pred #>    <chr>     <date>     <dbl> #>  1 ak        2021-12-10    NA #>  2 ca        2021-12-10    NA #>  3 ny        2021-12-10    NA #>  4 ak        2021-12-11    NA #>  5 ca        2021-12-11    NA #>  6 ny        2021-12-11    NA #>  7 ak        2021-12-12    NA #>  8 ca        2021-12-12    NA #>  9 ny        2021-12-12    NA #> 10 ak        2021-12-13    NA #> # ‚Ñπ 98 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Add layer to a frosting object ‚Äî add_layer","title":"Add layer to a frosting object ‚Äî add_layer","text":"Add layer frosting object","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add layer to a frosting object ‚Äî add_layer","text":"","code":"add_layer(frosting, object)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add layer to a frosting object ‚Äî add_layer","text":"frosting frosting postprocessor object frosting layer","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_layer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add layer to a frosting object ‚Äî add_layer","text":"updated frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_shifted_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"backend for both bake.step_epi_ahead and bake.step_epi_lag, performs the checks missing in epi_shift_single ‚Äî add_shifted_columns","title":"backend for both bake.step_epi_ahead and bake.step_epi_lag, performs the checks missing in epi_shift_single ‚Äî add_shifted_columns","text":"backend bake.step_epi_ahead bake.step_epi_lag, performs checks missing epi_shift_single","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/add_shifted_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"backend for both bake.step_epi_ahead and bake.step_epi_lag, performs the checks missing in epi_shift_single ‚Äî add_shifted_columns","text":"","code":"add_shifted_columns(new_data, object)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/adjust_epi_recipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Adjust a step in an epi_workflow or epi_recipe ‚Äî adjust_epi_recipe","title":"Adjust a step in an epi_workflow or epi_recipe ‚Äî adjust_epi_recipe","text":"Make parameter adjustment step either epi_workflow epi_recipe object.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/adjust_epi_recipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adjust a step in an epi_workflow or epi_recipe ‚Äî adjust_epi_recipe","text":"","code":"adjust_epi_recipe(   x,   which_step,   ...,   blueprint = default_epi_recipe_blueprint() )  # S3 method for class 'epi_workflow' adjust_epi_recipe(   x,   which_step,   ...,   blueprint = default_epi_recipe_blueprint() )  # S3 method for class 'epi_recipe' adjust_epi_recipe(   x,   which_step,   ...,   blueprint = default_epi_recipe_blueprint() )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/adjust_epi_recipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adjust a step in an epi_workflow or epi_recipe ‚Äî adjust_epi_recipe","text":"x epi_workflow epi_recipe object which_step number name step adjust ... Used input parameter adjustment blueprint hardhat blueprint used fine tuning preprocessing.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/adjust_epi_recipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adjust a step in an epi_workflow or epi_recipe ‚Äî adjust_epi_recipe","text":"x, updated adjustment specified epi_recipe step.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/adjust_epi_recipe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adjust a step in an epi_workflow or epi_recipe ‚Äî adjust_epi_recipe","text":"function can either adjust step epi_recipe object step epi_recipe object epi_workflow. step adjusted indicated either step number name (name used, must unique). either case, argument name update value must inputted .... See examples brief illustrations different types updates.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/adjust_epi_recipe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adjust a step in an epi_workflow or epi_recipe ‚Äî adjust_epi_recipe","text":"","code":"library(workflows) #>  #> Attaching package: ‚Äòworkflows‚Äô #> The following objects are masked from ‚Äòpackage:epipredict‚Äô: #>  #>     add_model, remove_model, update_model  jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\")) r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()  wf <- epi_workflow(r, parsnip::linear_reg()) %>% fit(jhu) latest <- jhu %>%   filter(time_value >= max(time_value) - 14)  # Adjust `step_epi_ahead` to have an ahead value of 14 # in the `epi_workflow` # Option 1. Using the step number: wf2 <- wf %>% adjust_epi_recipe(which_step = 2, ahead = 14) extract_preprocessor(wf2) #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs  #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations  #> 1. Lagging: death_rate by 0, 7, 14 #> 2. Leading: death_rate by 14 #> 3. ‚Ä¢ Removing rows with NA values in: all_predictors() #> 4. ‚Ä¢ Removing rows with NA values in: all_outcomes() # Option 2. Using the step name: wf3 <- wf %>% adjust_epi_recipe(which_step = \"step_epi_ahead\", ahead = 14) extract_preprocessor(wf3) #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs  #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations  #> 1. Lagging: death_rate by 0, 7, 14 #> 2. Leading: death_rate by 14 #> 3. ‚Ä¢ Removing rows with NA values in: all_predictors() #> 4. ‚Ä¢ Removing rows with NA values in: all_outcomes()  # Adjust `step_epi_ahead` to have an ahead value of 14 # in the `epi_recipe` # Option 1. Using the step number r2 <- r %>% adjust_epi_recipe(which_step = 2, ahead = 14) r2 #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs  #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations  #> 1. Lagging: death_rate by 0, 7, 14 #> 2. Leading: death_rate by 14 #> 3. ‚Ä¢ Removing rows with NA values in: all_predictors() #> 4. ‚Ä¢ Removing rows with NA values in: all_outcomes() # Option 2. Using the step name r3 <- r %>% adjust_epi_recipe(which_step = \"step_epi_ahead\", ahead = 14) r3 #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs  #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations  #> 1. Lagging: death_rate by 0, 7, 14 #> 2. Leading: death_rate by 14 #> 3. ‚Ä¢ Removing rows with NA values in: all_predictors() #> 4. ‚Ä¢ Removing rows with NA values in: all_outcomes()"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/adjust_frosting.html","id":null,"dir":"Reference","previous_headings":"","what":"Adjust a layer in an epi_workflow or frosting ‚Äî adjust_frosting","title":"Adjust a layer in an epi_workflow or frosting ‚Äî adjust_frosting","text":"Make parameter adjustment layer either epi_workflow frosting object.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/adjust_frosting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adjust a layer in an epi_workflow or frosting ‚Äî adjust_frosting","text":"","code":"adjust_frosting(x, which_layer, ...)  # S3 method for class 'epi_workflow' adjust_frosting(x, which_layer, ...)  # S3 method for class 'frosting' adjust_frosting(x, which_layer, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/adjust_frosting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adjust a layer in an epi_workflow or frosting ‚Äî adjust_frosting","text":"x epi_workflow frosting object which_layer number name layer adjust ... Used input parameter adjustment","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/adjust_frosting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adjust a layer in an epi_workflow or frosting ‚Äî adjust_frosting","text":"x, updated adjustment specified frosting layer.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/adjust_frosting.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adjust a layer in an epi_workflow or frosting ‚Äî adjust_frosting","text":"function can either adjust layer frosting object layer frosting object epi_workflow. layer adjusted indicated either layer number name (name used, must unique). either case, argument name update value must inputted .... See examples brief illustrations different types updates.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/adjust_frosting.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adjust a layer in an epi_workflow or frosting ‚Äî adjust_frosting","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\")) r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()  wf <- epi_workflow(r, linear_reg()) %>% fit(jhu)  # in the frosting from the workflow f1 <- frosting() %>%   layer_predict() %>%   layer_threshold(.pred)  wf2 <- wf %>% add_frosting(f1)  # Adjust `layer_threshold` to have an upper bound of 1 # in the `epi_workflow` # Option 1. Using the layer number: wf2 <- wf2 %>% adjust_frosting(which_layer = 2, upper = 1) extract_frosting(wf2) #>  #> ‚îÄ‚îÄ Frosting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Layers  #> 1. Creating predictions: \"<calculated>\" #> 2. Thresholding predictions: .pred to [0, 1] # Option 2. Using the layer name: wf3 <- wf2 %>% adjust_frosting(which_layer = \"layer_threshold\", upper = 1) extract_frosting(wf3) #>  #> ‚îÄ‚îÄ Frosting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Layers  #> 1. Creating predictions: \"<calculated>\" #> 2. Thresholding predictions: .pred to [0, 1]  # Adjust `layer_threshold` to have an upper bound of 5 # in the `frosting` object # Option 1. Using the layer number: f2 <- f1 %>% adjust_frosting(which_layer = 2, upper = 5) f2 #>  #> ‚îÄ‚îÄ Frosting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Layers  #> 1. Creating predictions: \"<calculated>\" #> 2. Thresholding predictions: .pred to [0, 5] # Option 2. Using the layer name f3 <- f1 %>% adjust_frosting(which_layer = \"layer_threshold\", upper = 5) f3 #>  #> ‚îÄ‚îÄ Frosting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Layers  #> 1. Creating predictions: \"<calculated>\" #> 2. Thresholding predictions: .pred to [0, 5]"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/apply_frosting.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply post-processing to a fitted workflow ‚Äî apply_frosting","title":"Apply post-processing to a fitted workflow ‚Äî apply_frosting","text":"function intended internal use. implements post-processing inside predict() method fitted workflow.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/apply_frosting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply post-processing to a fitted workflow ‚Äî apply_frosting","text":"","code":"apply_frosting(workflow, ...)  # Default S3 method apply_frosting(workflow, components, ...)  # S3 method for class 'epi_workflow' apply_frosting(workflow, components, new_data, type = NULL, opts = list(), ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/apply_frosting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply post-processing to a fitted workflow ‚Äî apply_frosting","text":"workflow object class workflow ... additional arguments passed methods components list components containing model information. updated returned layer. mold - output calling hardhat::mold() workflow. contains information preprocessing, including recipe. forged - output calling hardhat::forge() workflow. predictors outcomes new_data. three components predictors, outcomes (new_data), extras (usually rest data, including keys). keys - put keys (time_value, geo_value, others) ease. new_data data frame containing new predictors preprocess predict type, opts forwarded (along ...) predict.model_fit() slather() supported layers","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_args_list.html","id":null,"dir":"Reference","previous_headings":"","what":"ARX forecaster argument constructor ‚Äî arx_args_list","title":"ARX forecaster argument constructor ‚Äî arx_args_list","text":"Constructs list arguments arx_forecaster().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_args_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ARX forecaster argument constructor ‚Äî arx_args_list","text":"","code":"arx_args_list(   lags = c(0L, 7L, 14L),   ahead = 7L,   n_training = Inf,   forecast_date = NULL,   target_date = NULL,   adjust_latency = c(\"none\", \"extend_ahead\", \"extend_lags\", \"locf\"),   warn_latency = TRUE,   quantile_levels = c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95),   symmetrize = TRUE,   nonneg = TRUE,   quantile_by_key = character(0L),   check_enough_data_n = NULL,   check_enough_data_epi_keys = NULL,   ... )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_args_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ARX forecaster argument constructor ‚Äî arx_args_list","text":"lags Vector List. Positive integers enumerating lags use autoregressive-type models (days). default, unnamed list lags set correspond order predictors. ahead Integer. Number time steps ahead (days) forecast date forecasts produced. n_training Integer. upper limit number rows per key used training (time unit epi_df). forecast_date Date. date forecast occurring. default NULL determine automatically either maximum time value data latency adjustment (default case), as_of date epi_data adjust_latency non-NULL. target_date Date. date forecast. default NULL determine automatically forecast_date + ahead. adjust_latency Character. One methods step_adjust_latency(), \"none\" (case adjustment). forecast_date last day data, determines shift model account difference. options : \"none\" default, assumes forecast_date last day data \"extend_ahead\": increase ahead latency relative last day data. example, last day data 3 days ago, ahead becomes ahead+3. \"extend_lags\": increase lags relative actual forecast date. example, lags c(0, 7, 14) last day data 3 days ago, lags become c(3, 10, 17). warn_latency default, step_adjust_latency warns user latency large. FALSE, warning turned . quantile_levels Vector NULL. vector probabilities produce prediction intervals. created computing quantiles training residuals. NULL value result point forecasts . symmetrize Logical. default TRUE calculates symmetric prediction intervals. argument applies residual quantiles used. applicable trainer = quantile_reg(), example. Typically, one want non-symmetric quantiles increasing trajectories quite different decreasing ones, strictly postive variable near zero. nonneg Logical. default TRUE enforces nonnegative predictions hard-thresholding 0. quantile_by_key Character vector. Groups residuals listed keys calculating residual quantiles. See by_key argument layer_residual_quantiles() information. default, character(0) performs grouping. argument applies residual quantiles used. applicable trainer = quantile_reg(), example. check_enough_data_n Integer. lower limit number rows per epi_key required training. NULL, check ignored. check_enough_data_epi_keys Character vector. character vector column names group data check threshold within group. Useful training per group (example, per geo_value). ... Space handle future expansions (unused).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_args_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ARX forecaster argument constructor ‚Äî arx_args_list","text":"list containing updated parameter choices class arx_flist.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_args_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ARX forecaster argument constructor ‚Äî arx_args_list","text":"","code":"arx_args_list() #> ‚Ä¢ lags : 0, 7, and 14 #> ‚Ä¢ ahead : 7 #> ‚Ä¢ n_training : Inf #> ‚Ä¢ quantile_levels : 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, and 0.95 #> ‚Ä¢ forecast_date : \"NULL\" #> ‚Ä¢ target_date : \"NULL\" #> ‚Ä¢ adjust_latency : \"none\" #> ‚Ä¢ warn_latency : TRUE #> ‚Ä¢ symmetrize : TRUE #> ‚Ä¢ nonneg : TRUE #> ‚Ä¢ max_lags : 14 #> ‚Ä¢ quantile_by_key : \"_empty_\" #> ‚Ä¢ check_enough_data_n : \"NULL\" #> ‚Ä¢ check_enough_data_epi_keys : \"NULL\" arx_args_list(symmetrize = FALSE) #> ‚Ä¢ lags : 0, 7, and 14 #> ‚Ä¢ ahead : 7 #> ‚Ä¢ n_training : Inf #> ‚Ä¢ quantile_levels : 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, and 0.95 #> ‚Ä¢ forecast_date : \"NULL\" #> ‚Ä¢ target_date : \"NULL\" #> ‚Ä¢ adjust_latency : \"none\" #> ‚Ä¢ warn_latency : TRUE #> ‚Ä¢ symmetrize : FALSE #> ‚Ä¢ nonneg : TRUE #> ‚Ä¢ max_lags : 14 #> ‚Ä¢ quantile_by_key : \"_empty_\" #> ‚Ä¢ check_enough_data_n : \"NULL\" #> ‚Ä¢ check_enough_data_epi_keys : \"NULL\" arx_args_list(quantile_levels = c(.1, .3, .7, .9), n_training = 120) #> ‚Ä¢ lags : 0, 7, and 14 #> ‚Ä¢ ahead : 7 #> ‚Ä¢ n_training : 120 #> ‚Ä¢ quantile_levels : 0.1, 0.3, 0.7, and 0.9 #> ‚Ä¢ forecast_date : \"NULL\" #> ‚Ä¢ target_date : \"NULL\" #> ‚Ä¢ adjust_latency : \"none\" #> ‚Ä¢ warn_latency : TRUE #> ‚Ä¢ symmetrize : TRUE #> ‚Ä¢ nonneg : TRUE #> ‚Ä¢ max_lags : 14 #> ‚Ä¢ quantile_by_key : \"_empty_\" #> ‚Ä¢ check_enough_data_n : \"NULL\" #> ‚Ä¢ check_enough_data_epi_keys : \"NULL\""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_class_args_list.html","id":null,"dir":"Reference","previous_headings":"","what":"ARX classifier argument constructor ‚Äî arx_class_args_list","title":"ARX classifier argument constructor ‚Äî arx_class_args_list","text":"Constructs list arguments arx_classifier().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_class_args_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ARX classifier argument constructor ‚Äî arx_class_args_list","text":"","code":"arx_class_args_list(   lags = c(0L, 7L, 14L),   ahead = 7L,   n_training = Inf,   forecast_date = NULL,   target_date = NULL,   adjust_latency = c(\"none\", \"extend_ahead\", \"extend_lags\", \"locf\"),   warn_latency = TRUE,   outcome_transform = c(\"growth_rate\", \"lag_difference\"),   breaks = 0.25,   horizon = 7L,   method = c(\"rel_change\", \"linear_reg\"),   log_scale = FALSE,   check_enough_data_n = NULL,   check_enough_data_epi_keys = NULL,   ... )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_class_args_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ARX classifier argument constructor ‚Äî arx_class_args_list","text":"lags Vector List. Positive integers enumerating lags use autoregressive-type models (days). default, unnamed list lags set correspond order predictors. ahead Integer. Number time steps ahead (days) forecast date forecasts produced. n_training Integer. upper limit number rows per key used training (time unit epi_df). forecast_date Date. date forecast occurring. default NULL determine automatically either maximum time value data latency adjustment (default case), as_of date epi_data adjust_latency non-NULL. target_date Date. date forecast. default NULL determine automatically forecast_date + ahead. adjust_latency Character. One methods step_adjust_latency(), \"none\" (case adjustment). forecast_date last day data, determines shift model account difference. options : \"none\" default, assumes forecast_date last day data \"extend_ahead\": increase ahead latency relative last day data. example, last day data 3 days ago, ahead becomes ahead+3. \"extend_lags\": increase lags relative actual forecast date. example, lags c(0, 7, 14) last day data 3 days ago, lags become c(3, 10, 17). warn_latency default, step_adjust_latency warns user latency large. FALSE, warning turned . outcome_transform Scalar character. Whether outcome created using growth rates (predictors ) lagged differences. second case closer requirements 2022-23 CDC Flusight Hospitalization Experimental Target. See Classification chapter forecasting book Vignette details create reasonable baseline case. Selecting \"growth_rate\" (default) uses epiprocess::growth_rate() create outcome using additional arguments . Choosing \"lag_difference\" instead simply uses change value selected horizon. breaks Vector. vector breaks turn real-valued growth rates discrete classes. default gives binary upswing classification McDonald, Bien, Green, Hu, et al.. coincides default trainer = parsnip::logistic_reg() argument arx_classifier(). However, multiclass classification also supported (e.g. breaks = c(-.2, .25)) provided trainer = parsnip::multinom_reg() (another multiclass trainer) used well. sliently expanded cover entire real line (default become breaks = c(-Inf, .25, Inf)) used discretize response. different behaviour recipes::step_cut() creates classes cover range training data. horizon Scalar integer. passed h argument epiprocess::growth_rate(). determines amount data used calculate growth rate. method Character. Options available growth rate calculation. log_scale Scalar logical. Whether compute growth rates log scale. check_enough_data_n Integer. lower limit number rows per epi_key required training. NULL, check ignored. check_enough_data_epi_keys Character vector. character vector column names group data check threshold within group. Useful training per group (example, per geo_value). ... Space handle future expansions (unused).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_class_args_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ARX classifier argument constructor ‚Äî arx_class_args_list","text":"list containing updated parameter choices class arx_clist.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_class_args_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ARX classifier argument constructor ‚Äî arx_class_args_list","text":"","code":"arx_class_args_list() #> ‚Ä¢ lags : 0, 7, and 14 #> ‚Ä¢ ahead : 7 #> ‚Ä¢ n_training : Inf #> ‚Ä¢ breaks : -Inf, 0.25, and Inf #> ‚Ä¢ forecast_date : \"NULL\" #> ‚Ä¢ target_date : \"NULL\" #> ‚Ä¢ adjust_latency : \"none\" #> ‚Ä¢ outcome_transform : \"growth_rate\" #> ‚Ä¢ max_lags : 14 #> ‚Ä¢ horizon : 7 #> ‚Ä¢ method : \"rel_change\" #> ‚Ä¢ log_scale : FALSE #> ‚Ä¢ check_enough_data_n : \"NULL\" #> ‚Ä¢ check_enough_data_epi_keys : \"NULL\"  # 3-class classsification, # also needs arx_classifier(trainer = parsnip::multinom_reg()) arx_class_args_list(breaks = c(-.2, .25)) #> ‚Ä¢ lags : 0, 7, and 14 #> ‚Ä¢ ahead : 7 #> ‚Ä¢ n_training : Inf #> ‚Ä¢ breaks : -Inf, -0.2, 0.25, and Inf #> ‚Ä¢ forecast_date : \"NULL\" #> ‚Ä¢ target_date : \"NULL\" #> ‚Ä¢ adjust_latency : \"none\" #> ‚Ä¢ outcome_transform : \"growth_rate\" #> ‚Ä¢ max_lags : 14 #> ‚Ä¢ horizon : 7 #> ‚Ä¢ method : \"rel_change\" #> ‚Ä¢ log_scale : FALSE #> ‚Ä¢ check_enough_data_n : \"NULL\" #> ‚Ä¢ check_enough_data_epi_keys : \"NULL\""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_class_epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a template arx_classifier workflow ‚Äî arx_class_epi_workflow","title":"Create a template arx_classifier workflow ‚Äî arx_class_epi_workflow","text":"function creates unfit workflow use arx_classifier(). useful want make small modifications classifier fitting predicting. Supplying trainer function may alter returned epi_workflow object can omitted.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_class_epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a template arx_classifier workflow ‚Äî arx_class_epi_workflow","text":"","code":"arx_class_epi_workflow(   epi_data,   outcome,   predictors,   trainer = parsnip::logistic_reg(),   args_list = arx_class_args_list() )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_class_epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a template arx_classifier workflow ‚Äî arx_class_epi_workflow","text":"epi_data epi_df object outcome character (scalar) specifying outcome (epi_df). Note arx_forecaster(), expected real-valued. Conversion data unordered classes handled internally based breaks argument arx_class_args_list(). discrete classes already epi_df, recommended code classifier scratch using epi_recipe(). predictors character vector giving column(s) predictor variables. defaults outcome. However, manually specified, variables specifically mentioned used, outcome added. trainer {parsnip} model describing type estimation. now, enforce mode = \"classification\". Typical values parsnip::logistic_reg() parsnip::multinom_reg(). complicated trainers like parsnip::naive_Bayes() parsnip::rand_forest() can also used. May NULL like decide later. args_list list customization arguments determine type forecasting model. See arx_class_args_list().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_class_epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a template arx_classifier workflow ‚Äî arx_class_epi_workflow","text":"unfit epi_workflow.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_class_epi_workflow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a template arx_classifier workflow ‚Äî arx_class_epi_workflow","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value >= as.Date(\"2021-11-01\"))  arx_class_epi_workflow(jhu, \"death_rate\", c(\"case_rate\", \"death_rate\")) #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: logistic_reg() #> Postprocessor: Frosting #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 8 Recipe steps. #> 1. step_growth_rate() #> 2. step_epi_lag() #> 3. step_epi_lag() #> 4. step_epi_ahead() #> 5. step_mutate() #> 6. step_naomit() #> 7. step_naomit() #> 8. step_training_window() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Logistic Regression Model Specification (classification) #>  #> Computational engine: glm  #>  #>  #> ‚îÄ‚îÄ Postprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 3 Frosting layers. #> 1. layer_predict() #> 2. layer_add_forecast_date() #> 3. layer_add_target_date() #>   arx_class_epi_workflow(   jhu,   \"death_rate\",   c(\"case_rate\", \"death_rate\"),   trainer = multinom_reg(),   args_list = arx_class_args_list(     breaks = c(-.05, .1), ahead = 14,     horizon = 14, method = \"linear_reg\"   ) ) #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: multinom_reg() #> Postprocessor: Frosting #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 8 Recipe steps. #> 1. step_growth_rate() #> 2. step_epi_lag() #> 3. step_epi_lag() #> 4. step_epi_ahead() #> 5. step_mutate() #> 6. step_naomit() #> 7. step_naomit() #> 8. step_training_window() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Multinomial Regression Model Specification (classification) #>  #> Computational engine: nnet  #>  #>  #> ‚îÄ‚îÄ Postprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 3 Frosting layers. #> 1. layer_predict() #> 2. layer_add_forecast_date() #> 3. layer_add_target_date() #>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_classifier.html","id":null,"dir":"Reference","previous_headings":"","what":"Direct autoregressive classifier with covariates ‚Äî arx_classifier","title":"Direct autoregressive classifier with covariates ‚Äî arx_classifier","text":"autoregressive classification model continuous data. \"direct\" forecasting, meaning estimates class particular target horizon.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_classifier.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Direct autoregressive classifier with covariates ‚Äî arx_classifier","text":"","code":"arx_classifier(   epi_data,   outcome,   predictors,   trainer = logistic_reg(),   args_list = arx_class_args_list() )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_classifier.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Direct autoregressive classifier with covariates ‚Äî arx_classifier","text":"epi_data epi_df object outcome character (scalar) specifying outcome (epi_df). Note arx_forecaster(), expected real-valued. Conversion data unordered classes handled internally based breaks argument arx_class_args_list(). discrete classes already epi_df, recommended code classifier scratch using epi_recipe(). predictors character vector giving column(s) predictor variables. defaults outcome. However, manually specified, variables specifically mentioned used, outcome added. trainer {parsnip} model describing type estimation. now, enforce mode = \"classification\". Typical values parsnip::logistic_reg() parsnip::multinom_reg(). complicated trainers like parsnip::naive_Bayes() parsnip::rand_forest() can also used. args_list list customization arguments determine type forecasting model. See arx_class_args_list().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_classifier.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Direct autoregressive classifier with covariates ‚Äî arx_classifier","text":"list (1) predictions epi_df predicted classes (2) epi_workflow, list encapsulates entire estimation workflow","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_classifier.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Direct autoregressive classifier with covariates ‚Äî arx_classifier","text":"arx_classifier() autoregressive classification model epi_df data used predict discrete class case consideration.  direct forecaster estimates classes specific horizon ahead value. get sense arx_classifier() works, consider simple example minimal inputs. , use built-covid_case_death_rates contains confirmed COVID-19 cases deaths JHU CSSE states Dec 31, 2020 Dec 31, 2021. , take subset data five states June 4, 2021 December 31, 2021. objective predict whether case rates increasing considering 0, 7 14 day case rates:   key takeaway predictions two prediction classes: (-Inf, 0.25] (0.25, Inf): classes predict must discrete. discretization real-valued outcome controlled breaks argument, defaults 0.25. breaks automatically extended cover entire real line. example, default break 0.25 silently extended breaks = c(-Inf, .25, Inf) , therefore, results two classes: [-Inf, 0.25] (0.25, Inf). two classes used discretize outcome. conversion outcome classes handled internally. discrete classes already exist outcome epi_df, recommend code classifier scratch using epi_workflow framework control. trainer parsnip model describing type estimation mode = \"classification\" enforced. two typical trainers used parsnip::logistic_reg() two classes parsnip::multinom_reg() two classes.   parsnip model specification, can see trainer used logistic regression, expected binary outcome. complicated trainers like parsnip::naive_Bayes() parsnip::rand_forest() may also used (however, stick basics gentle introduction classifier). use default trainer logistic regression binary classification decide using default break 0.25, input one break two classification bins properly dichotomize outcome. example, set break 0.5 instead relying default 0.25. can passing 0.5 breaks argument arx_class_args_list() follows:   Indeed, can observe two .pred_class now (-Inf, 0.5] (0.5, Inf). See help(arx_class_args_list) available modifications. Additional arguments may supplied arx_class_args_list() include expected lags ahead arguments autoregressive-type model. default values 0, 7, 14 days lags predictors 7 days ahead forecast date predicting outcome. also n_training indicate upper bound number training rows per key. like practice using , remove filtering command obtain data within \"2021-06-04\" \"2021-12-31\" instead set n_training number days two dates, inclusive end points. end results . addition n_training, forecast_date target_date specify date forecast created intended, respectively. dwell arguments unique classifier absolutely essential understanding operates. remaining arguments discussed organically, needed serve purposes. information remaining arguments discussed , please see function documentation complete list definitions.","code":"jhu <- covid_case_death_rates %>%   filter(     time_value >= \"2021-06-04\",     time_value <= \"2021-12-31\",     geo_value %in% c(\"ca\", \"fl\", \"tx\", \"ny\", \"nj\")   )  out <- arx_classifier(jhu, outcome = \"case_rate\", predictors = \"case_rate\")  out$predictions #> # A tibble: 5 x 4 #>   geo_value .pred_class forecast_date target_date #>   <chr>     <fct>       <date>        <date> #> 1 ca        (-Inf,0.25] 2021-12-31    2022-01-07 #> 2 fl        (-Inf,0.25] 2021-12-31    2022-01-07 #> 3 nj        (-Inf,0.25] 2021-12-31    2022-01-07 #> 4 ny        (-Inf,0.25] 2021-12-31    2022-01-07 #> 5 tx        (-Inf,0.25] 2021-12-31    2022-01-07 workflows::extract_spec_parsnip(out$epi_workflow) #> Logistic Regression Model Specification (classification) #> #> Computational engine: glm out_break_0.5 <- arx_classifier(   jhu,   outcome = \"case_rate\",   predictors = \"case_rate\",   args_list = arx_class_args_list(     breaks = 0.5   ) ) #> Warning: glm.fit: algorithm did not converge #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred  out_break_0.5$predictions #> # A tibble: 5 x 4 #>   geo_value .pred_class forecast_date target_date #>   <chr>     <fct>       <date>        <date> #> 1 ca        (-Inf,0.5]  2021-12-31    2022-01-07 #> 2 fl        (-Inf,0.5]  2021-12-31    2022-01-07 #> 3 nj        (-Inf,0.5]  2021-12-31    2022-01-07 #> 4 ny        (-Inf,0.5]  2021-12-31    2022-01-07 #> 5 tx        (-Inf,0.5]  2021-12-31    2022-01-07"},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_classifier.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Direct autoregressive classifier with covariates ‚Äî arx_classifier","text":"","code":"tiny_geos <- c(\"as\", \"mp\", \"vi\", \"gu\", \"pr\") jhu <- covid_case_death_rates %>%   filter(time_value >= as.Date(\"2021-11-01\"), !(geo_value %in% tiny_geos))  out <- arx_classifier(jhu, \"death_rate\", c(\"case_rate\", \"death_rate\")) #> Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred  out <- arx_classifier(   jhu,   \"death_rate\",   c(\"case_rate\", \"death_rate\"),   trainer = parsnip::multinom_reg(),   args_list = arx_class_args_list(     breaks = c(-.05, .1), ahead = 14,     horizon = 14, method = \"linear_reg\"   ) )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_fcast_epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a template arx_forecaster workflow ‚Äî arx_fcast_epi_workflow","title":"Create a template arx_forecaster workflow ‚Äî arx_fcast_epi_workflow","text":"function creates unfit workflow use arx_forecaster(). useful want make small modifications forecaster fitting predicting. Supplying trainer function may alter returned epi_workflow object (e.g., intend use quantile_reg()) can omitted.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_fcast_epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a template arx_forecaster workflow ‚Äî arx_fcast_epi_workflow","text":"","code":"arx_fcast_epi_workflow(   epi_data,   outcome,   predictors = outcome,   trainer = linear_reg(),   args_list = arx_args_list() )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_fcast_epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a template arx_forecaster workflow ‚Äî arx_fcast_epi_workflow","text":"epi_data epi_df object outcome character (scalar) specifying outcome (epi_df). predictors character vector giving column(s) predictor variables. defaults outcome. However, manually specified, variables specifically mentioned used, outcome added. trainer {parsnip} model describing type estimation. now, enforce mode = \"regression\". May NULL like decide later. args_list list customization arguments determine type forecasting model. See arx_args_list().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_fcast_epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a template arx_forecaster workflow ‚Äî arx_fcast_epi_workflow","text":"unfitted epi_workflow.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_fcast_epi_workflow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a template arx_forecaster workflow ‚Äî arx_fcast_epi_workflow","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value >= as.Date(\"2021-12-01\"))  arx_fcast_epi_workflow(   jhu, \"death_rate\",   c(\"case_rate\", \"death_rate\") ) #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: linear_reg() #> Postprocessor: Frosting #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 7 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_lag() #> 3. step_epi_ahead() #> 4. step_naomit() #> 5. step_naomit() #> 6. step_training_window() #> 7. check_enough_data() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Linear Regression Model Specification (regression) #>  #> Computational engine: lm  #>  #>  #> ‚îÄ‚îÄ Postprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 5 Frosting layers. #> 1. layer_predict() #> 2. layer_residual_quantiles() #> 3. layer_add_forecast_date() #> 4. layer_add_target_date() #> 5. layer_threshold() #>   arx_fcast_epi_workflow(jhu, \"death_rate\",   c(\"case_rate\", \"death_rate\"),   trainer = quantile_reg(),   args_list = arx_args_list(quantile_levels = 1:9 / 10) ) #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: quantile_reg() #> Postprocessor: Frosting #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 7 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_lag() #> 3. step_epi_ahead() #> 4. step_naomit() #> 5. step_naomit() #> 6. step_training_window() #> 7. check_enough_data() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> quantile reg Model Specification (regression) #>  #> Main Arguments: #>   quantile_levels = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9) #>   method = br #>  #> Computational engine: rq  #>  #>  #> ‚îÄ‚îÄ Postprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 6 Frosting layers. #> 1. layer_predict() #> 2. layer_quantile_distn() #> 3. layer_point_from_distn() #> 4. layer_add_forecast_date() #> 5. layer_add_target_date() #> 6. layer_threshold() #>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_forecaster.html","id":null,"dir":"Reference","previous_headings":"","what":"Direct autoregressive forecaster with covariates ‚Äî arx_forecaster","title":"Direct autoregressive forecaster with covariates ‚Äî arx_forecaster","text":"autoregressive forecasting model epiprocess::epi_df data. \"direct\" forecasting, meaning estimates model particular target horizon outcome based lags predictors. See Get started vignette worked examples Custom epi_workflows vignette recreation using custom epi_workflow().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_forecaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Direct autoregressive forecaster with covariates ‚Äî arx_forecaster","text":"","code":"arx_forecaster(   epi_data,   outcome,   predictors = outcome,   trainer = linear_reg(),   args_list = arx_args_list() )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_forecaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Direct autoregressive forecaster with covariates ‚Äî arx_forecaster","text":"epi_data epi_df object outcome character (scalar) specifying outcome (epi_df). predictors character vector giving column(s) predictor variables. defaults outcome. However, manually specified, variables specifically mentioned used, outcome added. trainer {parsnip} model describing type estimation.  now, enforce mode = \"regression\". args_list list customization arguments determine type forecasting model. See arx_args_list().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_forecaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Direct autoregressive forecaster with covariates ‚Äî arx_forecaster","text":"arx_fcast, fields predictions epi_workflow. predictions tibble predicted values epi_workflow() fit workflow used make predictions","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/arx_forecaster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Direct autoregressive forecaster with covariates ‚Äî arx_forecaster","text":"","code":"jhu <- covid_case_death_rates %>%   dplyr::filter(time_value >= as.Date(\"2021-12-01\"))  out <- arx_forecaster(   jhu,   \"death_rate\",   c(\"case_rate\", \"death_rate\") )  out <- arx_forecaster(jhu,   \"death_rate\",   c(\"case_rate\", \"death_rate\"),   trainer = quantile_reg(),   args_list = arx_args_list(quantile_levels = 1:9 / 10) ) out #> ‚ïê‚ïê A basic forecaster of type ARX Forecaster ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #>  #> This forecaster was fit on 2025-06-23 21:49:40. #>  #> Training data was an <epi_df> with: #> ‚Ä¢ Geography: state, #> ‚Ä¢ Time type: day, #> ‚Ä¢ Using data up-to-date as of: 2023-03-10. #> ‚Ä¢ With the last data available on 2021-12-31 #>  #> ‚îÄ‚îÄ Predictions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> A total of 56 predictions are available for #> ‚Ä¢ 56 unique geographic regions, #> ‚Ä¢ At forecast date: 2021-12-31, #> ‚Ä¢ For target date: 2022-01-07, #>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/augment.epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Augment data with predictions ‚Äî augment.epi_workflow","title":"Augment data with predictions ‚Äî augment.epi_workflow","text":"augment(), unlike forecast(), goal modifying training data, rather just producing new forecasts. prediction new_data, produce prediction time_values, adds .pred column new_data returns resulting join.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/augment.epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augment data with predictions ‚Äî augment.epi_workflow","text":"","code":"# S3 method for class 'epi_workflow' augment(x, new_data, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/augment.epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augment data with predictions ‚Äî augment.epi_workflow","text":"x trained epi_workflow new_data epi_df predictors ... Arguments passed predict method.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/augment.epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augment data with predictions ‚Äî augment.epi_workflow","text":"new_data additional columns containing predicted values","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/autoplot-epipred.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatically plot an epi_workflow or canned_epipred object ‚Äî autoplot-epipred","title":"Automatically plot an epi_workflow or canned_epipred object ‚Äî autoplot-epipred","text":"fit workflow, training data displayed, response default. predictions NULL point interval forecasts shown well. Unfit workflows result error, (can simply call autoplot() original epi_df).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/autoplot-epipred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatically plot an epi_workflow or canned_epipred object ‚Äî autoplot-epipred","text":"","code":"# S3 method for class 'epi_workflow' autoplot(   object,   predictions = NULL,   observed_response = NULL,   .levels = c(0.5, 0.8, 0.9),   ...,   .color_by = c(\"all_keys\", \"geo_value\", \"other_keys\", \".response\", \"all\", \"none\"),   .facet_by = c(\".response\", \"other_keys\", \"all_keys\", \"geo_value\", \"all\", \"none\"),   .base_color = \"dodgerblue4\",   .point_pred_color = \"orange\",   .facet_filter = NULL,   .max_facets = deprecated() )  # S3 method for class 'canned_epipred' autoplot(   object,   observed_response = NULL,   ...,   .color_by = c(\"all_keys\", \"geo_value\", \"other_keys\", \".response\", \"all\", \"none\"),   .facet_by = c(\".response\", \"other_keys\", \"all_keys\", \"geo_value\", \"all\", \"none\"),   .base_color = \"dodgerblue4\",   .point_pred_color = \"orange\",   .facet_filter = NULL,   .max_facets = deprecated() )  # S3 method for class 'epi_workflow' plot(x, ...)  # S3 method for class 'canned_epipred' plot(x, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/autoplot-epipred.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatically plot an epi_workflow or canned_epipred object ‚Äî autoplot-epipred","text":"object, x epi_workflow predictions data frame predictions. NULL, original data shown. observed_response epi_df data plot . case actual results compare forecast . .levels numeric vector levels plot prediction bands. 3 levels begins difficult see. ... Ignored .color_by variables determine color(s) used plot lines. Options include: all_keys - default uses interaction key variables including geo_value geo_value - geo_value other_keys - available keys geo_value .response - numeric variables (y-axis) - uses interaction keys numeric variables none - coloring aesthetic applied .facet_by Similar .color_by except default display response. .base_color available, prediction bands shown color. .point_pred_color available, point forecasts shown color. .facet_filter Select facets displayed. Especially useful many geo_value's keys. <rlang> expression along lines dplyr::filter(). However, must single expression combined & operator. contrasts typical use case allows multiple comma-separated expressions implicitly combined &. multiple variables selected ..., names can filtered combination factors using .response_name. See examples . .max_facets","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/autoplot-epipred.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatically plot an epi_workflow or canned_epipred object ‚Äî autoplot-epipred","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value >= as.Date(\"2021-11-01\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_epi_naomit()  f <- frosting() %>%   layer_residual_quantiles() %>%   layer_threshold(starts_with(\".pred\")) %>%   layer_add_target_date()  wf <- epi_workflow(r, linear_reg(), f) %>% fit(jhu)  autoplot(wf)   latest <- jhu %>% filter(time_value >= max(time_value) - 14) preds <- predict(wf, latest) autoplot(wf, preds, .facet_filter = geo_value %in% c(\"ca\", \"ny\", \"de\", \"mt\"))   # ------- Show multiple horizons  p <- lapply(c(7, 14, 21, 28), function(h) {   r <- epi_recipe(jhu) %>%     step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%     step_epi_ahead(death_rate, ahead = h) %>%     step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%     step_epi_naomit()   ewf <- epi_workflow(r, linear_reg(), f) %>% fit(jhu)   forecast(ewf) })  p <- do.call(rbind, p) autoplot(wf, p, .facet_filter = geo_value %in% c(\"ca\", \"ny\", \"de\", \"mt\"))   # ------- Plotting canned forecaster output  jhu <- covid_case_death_rates %>%   filter(time_value >= as.Date(\"2021-11-01\")) flat <- flatline_forecaster(jhu, \"death_rate\") autoplot(flat, .facet_filter = geo_value %in% c(\"ca\", \"ny\", \"de\", \"mt\")) #> Warning: Removed 7 rows containing missing values or values outside the scale range #> (`geom_line()`).   arx <- arx_forecaster(jhu, \"death_rate\", c(\"case_rate\", \"death_rate\"),   args_list = arx_args_list(ahead = 14L) ) autoplot(arx, .facet_filter = geo_value %in% c(\"ca\", \"ny\", \"de\", \"mt\", \"mo\", \"in\"))"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/cdc_baseline_args_list.html","id":null,"dir":"Reference","previous_headings":"","what":"CDC baseline forecaster argument constructor ‚Äî cdc_baseline_args_list","title":"CDC baseline forecaster argument constructor ‚Äî cdc_baseline_args_list","text":"Constructs list arguments cdc_baseline_forecaster().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/cdc_baseline_args_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CDC baseline forecaster argument constructor ‚Äî cdc_baseline_args_list","text":"","code":"cdc_baseline_args_list(   data_frequency = \"1 week\",   aheads = 1:5,   n_training = Inf,   forecast_date = NULL,   quantile_levels = c(0.01, 0.025, 1:19/20, 0.975, 0.99),   nsims = 100000L,   symmetrize = TRUE,   nonneg = TRUE,   quantile_by_key = \"geo_value\",   ... )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/cdc_baseline_args_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CDC baseline forecaster argument constructor ‚Äî cdc_baseline_args_list","text":"data_frequency Integer string. describes frequency input epi_df. typical FluSight forecasts, \"1 week\". Allowable arguments integers (taken mean numbers days) string like \"7 days\" \"2 weeks\". Currently, periods (days weeks) result error. aheads Integer vector. Unlike arx_forecaster(), effect predicted values. Predictions always recent observation. determines set prediction horizons layer_cdc_flatline_quantiles(). interacts data_frequencyargument. , example, data daily want forecasts 1:4 days ahead, use1:4. However, want one-week predictions, set c(7, 14, 21, 28). data_frequencyis\"1 week\", set 1:4`. n_training Integer. upper limit number rows per key used training (time unit epi_df). forecast_date Date. date forecast occurring. default NULL determine automatically either maximum time value data latency adjustment (default case), as_of date epi_data adjust_latency non-NULL. quantile_levels Vector NULL. vector probabilities produce prediction intervals. created computing quantiles training residuals. NULL value result point forecasts . nsims Positive integer. number draws empirical CDF. samples spaced evenly (0, 1) scale, F_X(x) resulting linear interpolation X scale. achieved stats::quantile() Type 7 (default function). symmetrize Logical. default TRUE calculates symmetric prediction intervals. argument applies residual quantiles used. applicable trainer = quantile_reg(), example. Typically, one want non-symmetric quantiles increasing trajectories quite different decreasing ones, strictly postive variable near zero. nonneg Logical. Force predictive intervals non-negative. non-negativity forced propagating forward, slightly different behaviour occur using layer_threshold(). quantile_by_key Character vector. Groups residuals listed keys calculating residual quantiles. See by_key argument layer_residual_quantiles() information. default, character(0) performs grouping. argument applies residual quantiles used. applicable trainer = quantile_reg(), example. ... Space handle future expansions (unused).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/cdc_baseline_args_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CDC baseline forecaster argument constructor ‚Äî cdc_baseline_args_list","text":"list containing updated parameter choices class cdc_flat_fcast.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/cdc_baseline_args_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CDC baseline forecaster argument constructor ‚Äî cdc_baseline_args_list","text":"","code":"cdc_baseline_args_list() #> ‚Ä¢ data_frequency : 7 #> ‚Ä¢ aheads : 1, 2, 3, 4, and 5 #> ‚Ä¢ n_training : Inf #> ‚Ä¢ forecast_date : \"NULL\" #> ‚Ä¢ quantile_levels : 0.01, 0.025, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, #>   0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, ‚Ä¶, 0.975, and 0.99 #> ‚Ä¢ nsims : 100000 #> ‚Ä¢ symmetrize : TRUE #> ‚Ä¢ nonneg : TRUE #> ‚Ä¢ quantile_by_key : \"geo_value\" cdc_baseline_args_list(symmetrize = FALSE) #> ‚Ä¢ data_frequency : 7 #> ‚Ä¢ aheads : 1, 2, 3, 4, and 5 #> ‚Ä¢ n_training : Inf #> ‚Ä¢ forecast_date : \"NULL\" #> ‚Ä¢ quantile_levels : 0.01, 0.025, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, #>   0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, ‚Ä¶, 0.975, and 0.99 #> ‚Ä¢ nsims : 100000 #> ‚Ä¢ symmetrize : FALSE #> ‚Ä¢ nonneg : TRUE #> ‚Ä¢ quantile_by_key : \"geo_value\" cdc_baseline_args_list(quantile_levels = c(.1, .3, .7, .9), n_training = 120) #> ‚Ä¢ data_frequency : 7 #> ‚Ä¢ aheads : 1, 2, 3, 4, and 5 #> ‚Ä¢ n_training : 120 #> ‚Ä¢ forecast_date : \"NULL\" #> ‚Ä¢ quantile_levels : 0.1, 0.3, 0.7, and 0.9 #> ‚Ä¢ nsims : 100000 #> ‚Ä¢ symmetrize : TRUE #> ‚Ä¢ nonneg : TRUE #> ‚Ä¢ quantile_by_key : \"geo_value\""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/cdc_baseline_forecaster.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict the future with the most recent value ‚Äî cdc_baseline_forecaster","title":"Predict the future with the most recent value ‚Äî cdc_baseline_forecaster","text":"simple forecasting model epiprocess::epi_df data. uses recent observation forecast future date, produces intervals shuffling quantiles residuals \"flatline\" forecast incrementing forward available training data.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/cdc_baseline_forecaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict the future with the most recent value ‚Äî cdc_baseline_forecaster","text":"","code":"cdc_baseline_forecaster(   epi_data,   outcome,   args_list = cdc_baseline_args_list() )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/cdc_baseline_forecaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict the future with the most recent value ‚Äî cdc_baseline_forecaster","text":"epi_data epiprocess::epi_df outcome scalar character column name wish predict. args_list list additional arguments created cdc_baseline_args_list() constructor function.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/cdc_baseline_forecaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict the future with the most recent value ‚Äî cdc_baseline_forecaster","text":"data frame point interval forecasts aheads (unique horizons) unique combination key_vars.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/cdc_baseline_forecaster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict the future with the most recent value ‚Äî cdc_baseline_forecaster","text":"default, predictive intervals computed separately combination geo_value epi_data argument. forecaster meant produce exactly CDC Baseline used COVID19ForecastHub","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/cdc_baseline_forecaster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict the future with the most recent value ‚Äî cdc_baseline_forecaster","text":"","code":"library(dplyr) #>  #> Attaching package: ‚Äòdplyr‚Äô #> The following objects are masked from ‚Äòpackage:stats‚Äô: #>  #>     filter, lag #> The following objects are masked from ‚Äòpackage:base‚Äô: #>  #>     intersect, setdiff, setequal, union library(epiprocess) #>  #> Attaching package: ‚Äòepiprocess‚Äô #> The following object is masked from ‚Äòpackage:stats‚Äô: #>  #>     filter weekly_deaths <- covid_case_death_rates %>%   select(geo_value, time_value, death_rate) %>%   left_join(state_census %>% select(pop, abbr), by = c(\"geo_value\" = \"abbr\")) %>%   mutate(deaths = pmax(death_rate / 1e5 * pop * 7, 0)) %>%   select(-pop, -death_rate) %>%   group_by(geo_value) %>%   epi_slide(~ sum(.$deaths), .window_size = 7, .new_col_name = \"deaths_7dsum\") %>%   ungroup() %>%   filter(weekdays(time_value) == \"Saturday\")  cdc <- cdc_baseline_forecaster(weekly_deaths, \"deaths_7dsum\") preds <- pivot_quantiles_wider(cdc$predictions, .pred_distn)  library(ggplot2) #>  #> Attaching package: ‚Äòggplot2‚Äô #> The following objects are masked from ‚Äòpackage:epipredict‚Äô: #>  #>     is_layer, layer forecast_date <- unique(preds$forecast_date) four_states <- c(\"ca\", \"pa\", \"wa\", \"ny\") preds %>%   filter(geo_value %in% four_states) %>%   ggplot(aes(target_date)) +   geom_ribbon(aes(ymin = `0.1`, ymax = `0.9`), fill = blues9[3]) +   geom_ribbon(aes(ymin = `0.25`, ymax = `0.75`), fill = blues9[6]) +   geom_line(aes(y = .pred), color = \"orange\") +   geom_line(     data = weekly_deaths %>% filter(geo_value %in% four_states),     aes(x = time_value, y = deaths_7dsum)   ) +   scale_x_date(limits = c(forecast_date - 90, forecast_date + 30)) +   labs(x = \"Date\", y = \"Weekly deaths\") +   facet_wrap(~geo_value, scales = \"free_y\") +   theme_bw() +   geom_vline(xintercept = forecast_date) #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_line()`). #> Warning: Removed 39 rows containing missing values or values outside the scale range #> (`geom_line()`)."},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/check_enough_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the dataset contains enough data points. ‚Äî check_enough_data","title":"Check the dataset contains enough data points. ‚Äî check_enough_data","text":"check_enough_data creates specification recipe operation check variables contain enough data.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/check_enough_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the dataset contains enough data points. ‚Äî check_enough_data","text":"","code":"check_enough_data(   recipe,   ...,   min_observations = NULL,   epi_keys = NULL,   drop_na = TRUE,   role = NA,   trained = FALSE,   skip = TRUE,   id = rand_id(\"enough_data\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/check_enough_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the dataset contains enough data points. ‚Äî check_enough_data","text":"recipe recipe object. check added sequence operations recipe. ... One selector functions choose variables check. See selections() details. usually want use recipes::all_predictors() /recipes::all_outcomes() . min_observations minimum number data points required training. NULL, total number predictors used. epi_keys character vector column names group data check threshold within group. Useful forecaster trains per group (example, per geo_value). drop_na logical whether count NA values valid rows. role used check since new variables created. trained logical whether selectors ... resolved prep(). skip logical. TRUE, training data checked, FALSE, training predicting data checked. Technically, answers question \"check skipped recipe baked bake()?\" operations baked prep() run, operations may able conducted new data (e.g. processing outcome variable(s)).  Care taken using skip = TRUE may affect computations subsequent operations. id character string unique check identify .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/check_enough_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check the dataset contains enough data points. ‚Äî check_enough_data","text":"check break prep /bake function checked columns enough non-NA values. check passes, nothing changed data. best used every step. checking training data, best set ... all_predictors(), all_outcomes(), checking prediction data, best set ... all_predictors() , n = 1.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/check_enough_data.html","id":"tidy-results","dir":"Reference","previous_headings":"","what":"tidy() results","title":"Check the dataset contains enough data points. ‚Äî check_enough_data","text":"tidy() check, tibble column terms (selectors variables selected) returned.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/check_interminable_latency.html","id":null,"dir":"Reference","previous_headings":"","what":"warn when the latency is larger than would be reasonable ‚Äî check_interminable_latency","title":"warn when the latency is larger than would be reasonable ‚Äî check_interminable_latency","text":"warn latency larger reasonable","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/check_interminable_latency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"warn when the latency is larger than would be reasonable ‚Äî check_interminable_latency","text":"","code":"check_interminable_latency(   dataset,   latency_table,   target_columns,   forecast_date,   call = caller_env() )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/check_interminable_latency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"warn when the latency is larger than would be reasonable ‚Äî check_interminable_latency","text":"dataset epi_df latency_table whole collection latencies target_columns names columns adjusting, whether unreasonably latent","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/clean_f_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Create short function names ‚Äî clean_f_name","title":"Create short function names ‚Äî clean_f_name","text":"Create short function names","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/clean_f_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create short function names ‚Äî clean_f_name","text":"","code":"clean_f_name(.f, max_length = 20L)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/clean_f_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create short function names ‚Äî clean_f_name","text":".f function, character string, lambda. example, mean, \"mean\", ~ mean(.x) \\(x) mean(x, na.rm = TRUE). max_length integer determining long names can ","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/clean_f_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create short function names ‚Äî clean_f_name","text":"character string length max_length (partially) describes function.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/clean_f_name.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create short function names ‚Äî clean_f_name","text":"","code":"clean_f_name(mean) #> [1] \"mean\" clean_f_name(\"mean\") #> [1] \"mean\" clean_f_name(~ mean(.x, na.rm = TRUE)) #> [1] \"mean(.x, na.rm = ...\" clean_f_name(\\(x) mean(x, na.rm = TRUE)) #> [1] \"[ ]{mean(x, na.r...}\" clean_f_name(function(x) mean(x, na.rm = TRUE, trim = 0.2357862)) #> [1] \"[ ]{mean(x, na.r...}\""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/climate_args_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Climatological forecaster argument constructor ‚Äî climate_args_list","title":"Climatological forecaster argument constructor ‚Äî climate_args_list","text":"Climatological forecaster argument constructor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/climate_args_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Climatological forecaster argument constructor ‚Äî climate_args_list","text":"","code":"climate_args_list(   forecast_date = NULL,   forecast_horizon = 0:4,   time_type = c(\"epiweek\", \"week\", \"month\", \"day\"),   center_method = c(\"median\", \"mean\"),   window_size = 3L,   quantile_levels = c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95),   symmetrize = FALSE,   nonneg = TRUE,   quantile_by_key = character(0L),   ... )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/climate_args_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Climatological forecaster argument constructor ‚Äî climate_args_list","text":"forecast_date Date. date forecast occurring. default NULL determine automatically either maximum time value data latency adjustment (default case), as_of date epi_data adjust_latency non-NULL. forecast_horizon Vector integers giving number time steps, units time_type, reference_date predictions produced. time_type duration time aggregation performed. center_method measure center calculated time window. window_size Scalar integer. many time units side included. example, window_size = 3 time_type = \"day\", day data, center calculated using 3 days three days . , case, operates like weekly rolling average, centered day. quantile_levels Vector NULL. vector probabilities produce prediction intervals. created computing quantiles training residuals. NULL value result point forecasts . symmetrize Logical. default TRUE calculates symmetric prediction intervals. argument applies residual quantiles used. applicable trainer = quantile_reg(), example. Typically, one want non-symmetric quantiles increasing trajectories quite different decreasing ones, strictly postive variable near zero. nonneg Logical. default TRUE enforces nonnegative predictions hard-thresholding 0. quantile_by_key Character vector. Groups residuals listed keys calculating residual quantiles. See by_key argument layer_residual_quantiles() information. default, character(0) performs grouping. argument applies residual quantiles used. applicable trainer = quantile_reg(), example. ... arguments passed methods (currently used).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/climate_args_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Climatological forecaster argument constructor ‚Äî climate_args_list","text":"list containing updated parameter choices class climate_alist.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/climate_args_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Climatological forecaster argument constructor ‚Äî climate_args_list","text":"","code":"climate_args_list() #> ‚Ä¢ forecast_date : \"NULL\" #> ‚Ä¢ forecast_horizon : 0, 1, 2, 3, and 4 #> ‚Ä¢ time_type : \"epiweek\" #> ‚Ä¢ center_method : \"median\" #> ‚Ä¢ window_size : 3 #> ‚Ä¢ quantile_levels : 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, and 0.95 #> ‚Ä¢ symmetrize : FALSE #> ‚Ä¢ nonneg : TRUE #> ‚Ä¢ quantile_by_key : \"_empty_\" climate_args_list(   forecast_horizon = 0:10,   quantile_levels = c(.01, .025, 1:19 / 20, .975, .99) ) #> ‚Ä¢ forecast_date : \"NULL\" #> ‚Ä¢ forecast_horizon : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, and 10 #> ‚Ä¢ time_type : \"epiweek\" #> ‚Ä¢ center_method : \"median\" #> ‚Ä¢ window_size : 3 #> ‚Ä¢ quantile_levels : 0.01, 0.025, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, #>   0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, ‚Ä¶, 0.975, and 0.99 #> ‚Ä¢ symmetrize : FALSE #> ‚Ä¢ nonneg : TRUE #> ‚Ä¢ quantile_by_key : \"_empty_\""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/climatological_forecaster.html","id":null,"dir":"Reference","previous_headings":"","what":"Climatological forecaster ‚Äî climatological_forecaster","title":"Climatological forecaster ‚Äî climatological_forecaster","text":"another \"baseline\" type forecaster, especially appropriate strongly seasonal diseases (e.g., influenza). idea predict \"typical season\" summarizing available history epi_data. analogous \"climate\" forecast rather \"weather\" forecast, essentially predicting \"typical January\" behavior relying long history periods rather heavily using recent data.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/climatological_forecaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Climatological forecaster ‚Äî climatological_forecaster","text":"","code":"climatological_forecaster(epi_data, outcome, args_list = climate_args_list())"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/climatological_forecaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Climatological forecaster ‚Äî climatological_forecaster","text":"epi_data epiprocess::epi_df outcome scalar character column name wish predict. args_list list additional arguments created climate_args_list() constructor function.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/climatological_forecaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Climatological forecaster ‚Äî climatological_forecaster","text":"data frame point interval) forecasts horizons unique combination key_vars.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/climatological_forecaster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Climatological forecaster ‚Äî climatological_forecaster","text":"point forecast either mean median outcome small window around target period, computed entire available history, separately key epi_df (geo_value additional keys). forecast quantiles computed residuals point prediction. default, residuals ungrouped, meaning every key shape distribution (though different centers). Note data comparable scales across keys, default likely inappropriate. case, can choose keys quantiles computed using climate_args_list(quantile_by_key = ...).","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/climatological_forecaster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Climatological forecaster ‚Äî climatological_forecaster","text":"","code":"cases <- cases_deaths_subset # set as_of to the last day in the data # \"case_rate_7d_av\" is on the same scale for all geographies attr(cases, \"metadata\")$as_of <- as.Date(\"2021-12-31\") fcast <- climatological_forecaster(cases, \"case_rate_7d_av\") autoplot(fcast)   # Compute quantiles separately by location, and a backcast # \"cases\" is on different scales by geography, due to population size # so, it is better to compute quantiles separately backcast <- climatological_forecaster(   cases, \"case_rate_7d_av\",   climate_args_list(     quantile_by_key = \"geo_value\",     forecast_date = as.Date(\"2021-06-01\")   ) ) autoplot(backcast)   # compute the climate \"daily\" rather than \"weekly\" # use a two week window (on both sides) # \"cases\" is on different scales by geography, due to population size daily_fcast <- climatological_forecaster(   cases, \"cases\",   climate_args_list(     quantile_by_key = \"geo_value\",     time_type = \"day\",     window_size = 14L,     forecast_horizon = 0:30   ) ) autoplot(daily_fcast) +   ggplot2::coord_cartesian(xlim = c(as.Date(\"2021-10-01\"), NA))"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/construct_shift_tibble.html","id":null,"dir":"Reference","previous_headings":"","what":"create a table of the columns to modify, their shifts, and their prefixes ‚Äî construct_shift_tibble","title":"create a table of the columns to modify, their shifts, and their prefixes ‚Äî construct_shift_tibble","text":"create table columns modify, shifts, prefixes","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/construct_shift_tibble.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"create a table of the columns to modify, their shifts, and their prefixes ‚Äî construct_shift_tibble","text":"","code":"construct_shift_tibble(terms_used, recipe, rel_step_type, shift_name)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/count_single_column.html","id":null,"dir":"Reference","previous_headings":"","what":"get the location of the last real value ‚Äî count_single_column","title":"get the location of the last real value ‚Äî count_single_column","text":"get location last real value","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/count_single_column.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get the location of the last real value ‚Äî count_single_column","text":"","code":"count_single_column(col)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/count_single_column.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get the location of the last real value ‚Äî count_single_column","text":"col relevant column","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/dist_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A distribution parameterized by a set of quantiles ‚Äî dist_quantiles","text":"","code":"dist_quantiles(values, quantile_levels)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/dist_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A distribution parameterized by a set of quantiles ‚Äî dist_quantiles","text":"values vector (list vectors) values. quantile_levels vector (list vectors) probabilities corresponding values. creating multiple sets values/quantile_levels resulting different distributions, sizes must match. See examples .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/dist_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A distribution parameterized by a set of quantiles ‚Äî dist_quantiles","text":"vector class \"distribution\".","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/dist_quantiles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A distribution parameterized by a set of quantiles ‚Äî dist_quantiles","text":"function deprecated. recommended alternative hardhat::quantile_pred().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/drop_ignored_keys.html","id":null,"dir":"Reference","previous_headings":"","what":"given a list named by key columns, remove any matching key values keys_to_ignore should have the form list(col_name = c(","title":"given a list named by key columns, remove any matching key values keys_to_ignore should have the form list(col_name = c(","text":"given list named key columns, remove matching key values keys_to_ignore form list(col_name = c(\"value_to_ignore\", \"other_value_to_ignore\"))","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/drop_ignored_keys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"given a list named by key columns, remove any matching key values keys_to_ignore should have the form list(col_name = c(","text":"","code":"drop_ignored_keys(training, keys_to_ignore)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_recipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a epi_recipe for preprocessing data ‚Äî epi_recipe","title":"Create a epi_recipe for preprocessing data ‚Äî epi_recipe","text":"recipe description steps applied data set order prepare data analysis. loose wrapper around recipes::recipe() properly handle additional columns present epi_df","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_recipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a epi_recipe for preprocessing data ‚Äî epi_recipe","text":"","code":"epi_recipe(x, ...)  # S3 method for class 'epi_df' epi_recipe(   x,   reference_date = NULL,   formula = NULL,   ...,   vars = NULL,   roles = NULL )  # S3 method for class 'formula' epi_recipe(formula, data, reference_date = NULL, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_recipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a epi_recipe for preprocessing data ‚Äî epi_recipe","text":"x, data epi_df template data set (see ). ... arguments passed methods (currently used). reference_date Either date class time_value column epi_df NULL. date, gives date operations relative. Typically, real-time tasks date model created (presumably trained). forecasting, often recent date data availability, data \"latent\" (reported date corresponds), performing nowcast, reference_date may later . Setting reference_date value recent data true \"forecast\", future data used create model, may reasonable model building, nowcasting (predicting finalized values preliminary data), producing backcast. NULL, set as_of date epi_df. formula model formula. -line functions used (e.g. log(x), x:y, etc.) minus signs allowed. types transformations enacted using step functions package. Dots allowed simple multivariate outcome terms (.e. need cbind; see Examples). vars character string column names corresponding variables used context (see ) roles character string (length vars) describes single role variable take. value anything common roles \"outcome\", \"predictor\", \"time_value\", \"geo_value\"","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_recipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a epi_recipe for preprocessing data ‚Äî epi_recipe","text":"object class recipe sub-objects: var_info tibble containing information original data set columns. term_info tibble contains current set terms data set. initially defaults data contained var_info. steps list step check objects define sequence preprocessing operations applied data. default value NULL. template tibble data. initialized data given data argument can different recipe trained.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_recipe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a epi_recipe for preprocessing data ‚Äî epi_recipe","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-08-01\")  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_epi_naomit()  r #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs  #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations  #> 1. Lagging: death_rate by 0, 7, 14 #> 2. Leading: death_rate by 7 #> 3. Lagging: case_rate by 0, 7, 14 #> 4. ‚Ä¢ Removing rows with NA values in: all_predictors() #> 5. ‚Ä¢ Removing rows with NA values in: all_outcomes()"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_shift_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift predictors while maintaining grouping and time_value ordering ‚Äî epi_shift_single","title":"Shift predictors while maintaining grouping and time_value ordering ‚Äî epi_shift_single","text":"lower-level function. performs error checking.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_shift_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift predictors while maintaining grouping and time_value ordering ‚Äî epi_shift_single","text":"","code":"epi_shift_single(x, col, shift_val, newname, key_cols)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_shift_single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift predictors while maintaining grouping and time_value ordering ‚Äî epi_shift_single","text":"x Data frame. shift_val single integer. Negative values produce leads. newname name newly shifted column key_cols vector, NULL. Additional grouping vars.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_shift_single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shift predictors while maintaining grouping and time_value ordering ‚Äî epi_shift_single","text":"list tibbles","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_slide_wrapper.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrapper to handle epi_slide particulars ‚Äî epi_slide_wrapper","title":"Wrapper to handle epi_slide particulars ‚Äî epi_slide_wrapper","text":"simplify somewhat future can run epi_slide columns. Surprisingly, lapply several orders magnitude faster using roughly equivalent tidy select style.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_slide_wrapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrapper to handle epi_slide particulars ‚Äî epi_slide_wrapper","text":"","code":"epi_slide_wrapper(   new_data,   .window_size,   .align,   columns,   fns,   fn_names,   group_keys,   name_prefix )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_slide_wrapper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrapper to handle epi_slide particulars ‚Äî epi_slide_wrapper","text":"fns vector functions, even length 1. group_keys keys group . likely epi_keys (without time_value)","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an epi_workflow ‚Äî epi_workflow","title":"Create an epi_workflow ‚Äî epi_workflow","text":"container object unifies preprocessing, fitting, prediction, post-processing predictive modeling epidemiological data. extends functionality workflows::workflow() handle typical panel data structures found field. extension handled completely internally, invisible user. intents purposes, operates exactly like workflows::workflow(). {epipredict} specific examples, see custom epiworkflows vignette.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an epi_workflow ‚Äî epi_workflow","text":"","code":"epi_workflow(preprocessor = NULL, spec = NULL, postprocessor = NULL)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an epi_workflow ‚Äî epi_workflow","text":"preprocessor optional preprocessor add workflow. One : formula, passed add_formula(). recipe, passed add_recipe(). workflow_variables() object, passed add_variables(). spec optional parsnip model specification add workflow. Passed add_model(). postprocessor optional postprocessor add workflow. Currently frosting allowed using, add_frosting().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an epi_workflow ‚Äî epi_workflow","text":"new epi_workflow object.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epi_workflow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an epi_workflow ‚Äî epi_workflow","text":"","code":"jhu <- covid_case_death_rates  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_epi_naomit()  wf <- epi_workflow(r, parsnip::linear_reg())  wf #>  #> ‚ïê‚ïê Epi Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: linear_reg() #> Postprocessor: None #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 5 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_ahead() #> 3. step_epi_lag() #> 4. step_naomit() #> 5. step_naomit() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> Linear Regression Model Specification (regression) #>  #> Computational engine: lm  #>  #>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epiweek_leap.html","id":null,"dir":"Reference","previous_headings":"","what":"epiweek, but it assigns week 53 the value of 999 instead so it mirrors the assignments in yday_leap ‚Äî epiweek_leap","title":"epiweek, but it assigns week 53 the value of 999 instead so it mirrors the assignments in yday_leap ‚Äî epiweek_leap","text":"epiweek, assigns week 53 value 999 instead mirrors assignments yday_leap","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/epiweek_leap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"epiweek, but it assigns week 53 the value of 999 instead so it mirrors the assignments in yday_leap ‚Äî epiweek_leap","text":"","code":"epiweek_leap(time_value)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extract_argument.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract an argument made to a frosting layer or recipe step ‚Äî extract_argument","title":"Extract an argument made to a frosting layer or recipe step ‚Äî extract_argument","text":"Extract argument made frosting layer recipe step","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extract_argument.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract an argument made to a frosting layer or recipe step ‚Äî extract_argument","text":"","code":"extract_argument(x, name, arg, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extract_argument.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract an argument made to a frosting layer or recipe step ‚Äî extract_argument","text":"x epi_workflow, epi_recipe, frosting, step, layer object name name layer arg name argument ... used","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extract_argument.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract an argument made to a frosting layer or recipe step ‚Äî extract_argument","text":"object originally passed argument layer step","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extract_argument.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract an argument made to a frosting layer or recipe step ‚Äî extract_argument","text":"","code":"f <- frosting() %>%   layer_predict() %>%   layer_residual_quantiles(symmetrize = FALSE) %>%   layer_naomit(.pred)  extract_argument(f, \"layer_residual_quantiles\", \"symmetrize\") #> [1] FALSE"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extract_frosting.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the frosting object from a workflow ‚Äî extract_frosting","title":"Extract the frosting object from a workflow ‚Äî extract_frosting","text":"Extract frosting object workflow","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extract_frosting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the frosting object from a workflow ‚Äî extract_frosting","text":"","code":"extract_frosting(x, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extract_frosting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the frosting object from a workflow ‚Äî extract_frosting","text":"x epi_workflow object ... used","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extract_frosting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the frosting object from a workflow ‚Äî extract_frosting","text":"frosting object","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extrapolate_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Extrapolate the quantiles to new quantile levels ‚Äî extrapolate_quantiles","title":"Extrapolate the quantiles to new quantile levels ‚Äî extrapolate_quantiles","text":"interpolates quantile levels already defined x extrapolates quantiles outside bounds. interpolation method determined quantile argument middle, can either \"cubic\" (Hyman) cubic spline interpolation, \"linear\" simple linear interpolation.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extrapolate_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extrapolate the quantiles to new quantile levels ‚Äî extrapolate_quantiles","text":"","code":"extrapolate_quantiles(x, probs, replace_na = TRUE, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extrapolate_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extrapolate the quantiles to new quantile levels ‚Äî extrapolate_quantiles","text":"x vector class quantile_pred. probs vector probabilities calculate quantiles replace_na logical. x contains NA's, imputed possible (TRUE) retained (FALSE). ... additional arguments passed quantile method","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extrapolate_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extrapolate the quantiles to new quantile levels ‚Äî extrapolate_quantiles","text":"quantile_pred vector. element x now superset original quantile_values (union probs).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extrapolate_quantiles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extrapolate the quantiles to new quantile levels ‚Äî extrapolate_quantiles","text":"one extrapolation method values greater largest available quantile level smaller smallest available quantile level. assumes roughly exponential tail, whose decay rate offset derived slope two extreme quantile levels logistic scale.  See internal function tail_extrapolate() exact implementation. function takes quantile_pred vector returns type object, expanded include additional quantiles computed probs. want behaviour similar stats::quantile(), quantile(x,...) may appropriate.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/extrapolate_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extrapolate the quantiles to new quantile levels ‚Äî extrapolate_quantiles","text":"","code":"dstn <- quantile_pred(rbind(1:4, 8:11), c(.2, .4, .6, .8)) # extra quantiles are appended as_tibble(extrapolate_quantiles(dstn, probs = c(0.25, 0.5, 0.75))) #> # A tibble: 14 √ó 3 #>    .pred_quantile .quantile_levels  .row #>             <dbl>            <dbl> <int> #>  1           1                0.2      1 #>  2           1.25             0.25     1 #>  3           2                0.4      1 #>  4           2.5              0.5      1 #>  5           3                0.6      1 #>  6           3.75             0.75     1 #>  7           4                0.8      1 #>  8           8                0.2      2 #>  9           8.25             0.25     2 #> 10           9                0.4      2 #> 11           9.5              0.5      2 #> 12          10                0.6      2 #> 13          10.8              0.75     2 #> 14          11                0.8      2  extrapolate_quantiles(dstn, probs = c(0.0001, 0.25, 0.5, 0.75, 0.99999)) #> <quantiles[2]> #> [1] [2.5] [9.5] #> # Quantile levels: 0.0001 0.2000 0.2500 0.4000 0.5000 0.6000 0.7500 0.8000 1.0000"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/fit-epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit an epi_workflow object ‚Äî fit-epi_workflow","title":"Fit an epi_workflow object ‚Äî fit-epi_workflow","text":"fit() method epi_workflow() object estimates parameters given model set data. Fitting epi_workflow() involves two main steps, preprocessing data fitting underlying parsnip model.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/fit-epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit an epi_workflow object ‚Äî fit-epi_workflow","text":"","code":"# S3 method for class 'epi_workflow' fit(object, data, ..., control = workflows::control_workflow())"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/fit-epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit an epi_workflow object ‚Äî fit-epi_workflow","text":"object epi_workflow object data epi_df predictors outcomes use fitting epi_workflow ... used control workflows::control_workflow() object","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/fit-epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit an epi_workflow object ‚Äî fit-epi_workflow","text":"epi_workflow object, updated fit parsnip model object$fit$fit slot.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/fit-epi_workflow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit an epi_workflow object ‚Äî fit-epi_workflow","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7)  wf <- epi_workflow(r, parsnip::linear_reg()) %>% fit(jhu) wf #>  #> ‚ïê‚ïê Epi Workflow [trained] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: linear_reg() #> Postprocessor: None #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 2 Recipe steps. #> 1. step_epi_lag() #> 2. step_epi_ahead() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> Call: #> stats::lm(formula = ..y ~ ., data = data) #>  #> Coefficients: #>       (Intercept)   lag_0_death_rate   lag_7_death_rate  lag_14_death_rate   #>           0.32709           -0.01822           -0.02096           -0.05793   #>  #>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline.html","id":null,"dir":"Reference","previous_headings":"","what":"(Internal) implementation of the flatline forecaster ‚Äî flatline","title":"(Internal) implementation of the flatline forecaster ‚Äî flatline","text":"internal function used create parsnip::linear_reg() model. somewhat odd behaviour (see ).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"(Internal) implementation of the flatline forecaster ‚Äî flatline","text":"","code":"flatline(formula, data)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"(Internal) implementation of the flatline forecaster ‚Äî flatline","text":"formula lhs single variable. standard usage, actually observed time series shifted forward forecast horizon. right hand side must contain keys (locations) panel data separated plus. observed time series must come last. example   Note function shifting, done outside. data data frame containing least variables used formula. must also contain column time_value giving observed time points.","code":"form <- as.formula(lead7_y ~ state + age + y)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"(Internal) implementation of the flatline forecaster ‚Äî flatline","text":"S3 object class flatline two components: residuals - tibble keys .resid column contains forecast errors. .pred - tibble keys .pred column containing predictions future data (last observed outcome combination keys.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"(Internal) implementation of the flatline forecaster ‚Äî flatline","text":"","code":"tib <- data.frame(   y = runif(100),   expand.grid(k = letters[1:4], j = letters[5:9], time_value = 1:5) ) %>%   dplyr::group_by(k, j) %>%   dplyr::mutate(y2 = dplyr::lead(y, 2)) # predict 2 steps ahead flat <- flatline(y2 ~ j + k + y, tib) # predictions for 20 locations sum(!is.na(flat$residuals$.resid)) # 100 residuals, but 40 are NA #> [1] 60"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline_args_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Flatline forecaster argument constructor ‚Äî flatline_args_list","title":"Flatline forecaster argument constructor ‚Äî flatline_args_list","text":"Constructs list arguments flatline_forecaster().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline_args_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flatline forecaster argument constructor ‚Äî flatline_args_list","text":"","code":"flatline_args_list(   ahead = 7L,   n_training = Inf,   forecast_date = NULL,   target_date = NULL,   quantile_levels = c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95),   symmetrize = TRUE,   nonneg = TRUE,   quantile_by_key = character(0L),   ... )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline_args_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flatline forecaster argument constructor ‚Äî flatline_args_list","text":"ahead Integer. Unlike arx_forecaster(), effect predicted values. Predictions always recent observation. However, impact residuals stored object. Residuals calculated based number mimic badly done. example, ahead = 7 create residuals comparing values 7 days apart. n_training Integer. upper limit number rows per key used training (time unit epi_df). forecast_date Date. date forecast occurring. default NULL determine automatically either maximum time value data latency adjustment (default case), as_of date epi_data adjust_latency non-NULL. target_date Date. date forecast. default NULL determine automatically forecast_date + ahead. quantile_levels Vector NULL. vector probabilities produce prediction intervals. created computing quantiles training residuals. NULL value result point forecasts . symmetrize Logical. default TRUE calculates symmetric prediction intervals. argument applies residual quantiles used. applicable trainer = quantile_reg(), example. Typically, one want non-symmetric quantiles increasing trajectories quite different decreasing ones, strictly postive variable near zero. nonneg Logical. default TRUE enforces nonnegative predictions hard-thresholding 0. quantile_by_key Character vector. Groups residuals listed keys calculating residual quantiles. See by_key argument layer_residual_quantiles() information. default, character(0) performs grouping. argument applies residual quantiles used. applicable trainer = quantile_reg(), example. ... Space handle future expansions (unused).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline_args_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flatline forecaster argument constructor ‚Äî flatline_args_list","text":"list containing updated parameter choices class flatline_alist.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline_args_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flatline forecaster argument constructor ‚Äî flatline_args_list","text":"","code":"flatline_args_list() #> ‚Ä¢ ahead : 7 #> ‚Ä¢ n_training : Inf #> ‚Ä¢ forecast_date : \"NULL\" #> ‚Ä¢ target_date : \"NULL\" #> ‚Ä¢ quantile_levels : 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, and 0.95 #> ‚Ä¢ symmetrize : TRUE #> ‚Ä¢ nonneg : TRUE #> ‚Ä¢ quantile_by_key : \"_empty_\" flatline_args_list(symmetrize = FALSE) #> ‚Ä¢ ahead : 7 #> ‚Ä¢ n_training : Inf #> ‚Ä¢ forecast_date : \"NULL\" #> ‚Ä¢ target_date : \"NULL\" #> ‚Ä¢ quantile_levels : 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, and 0.95 #> ‚Ä¢ symmetrize : FALSE #> ‚Ä¢ nonneg : TRUE #> ‚Ä¢ quantile_by_key : \"_empty_\" flatline_args_list(quantile_levels = c(.1, .3, .7, .9), n_training = 120) #> ‚Ä¢ ahead : 7 #> ‚Ä¢ n_training : 120 #> ‚Ä¢ forecast_date : \"NULL\" #> ‚Ä¢ target_date : \"NULL\" #> ‚Ä¢ quantile_levels : 0.1, 0.3, 0.7, and 0.9 #> ‚Ä¢ symmetrize : TRUE #> ‚Ä¢ nonneg : TRUE #> ‚Ä¢ quantile_by_key : \"_empty_\""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline_forecaster.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict the future with today's value ‚Äî flatline_forecaster","title":"Predict the future with today's value ‚Äî flatline_forecaster","text":"simple forecasting model epiprocess::epi_df data. uses recent observation forecast future date, produces intervals based quantiles residuals \"flatline\" forecast available training data. default, predictive intervals computed separately combination key values (geo_value + additional keys) epi_data argument. forecaster similar used COVID19ForecastHub","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline_forecaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict the future with today's value ‚Äî flatline_forecaster","text":"","code":"flatline_forecaster(epi_data, outcome, args_list = flatline_args_list())"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline_forecaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict the future with today's value ‚Äî flatline_forecaster","text":"epi_data epiprocess::epi_df outcome scalar character column name wish predict. args_list list additional arguments created flatline_args_list() constructor function.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline_forecaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict the future with today's value ‚Äî flatline_forecaster","text":"data frame point (optionally interval) forecasts single ahead (unique horizon) unique combination key_vars.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline_forecaster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict the future with today's value ‚Äî flatline_forecaster","text":"(roughly) code flatline_forecaster() applied case_rate epidatasets::covid_case_death_rates.","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\")) r <- epi_recipe(covid_case_death_rates) %>%   step_epi_ahead(case_rate, ahead = 7, skip = TRUE) %>%   recipes::update_role(case_rate, new_role = \"predictor\") %>%   recipes::add_role(all_of(key_colnames(jhu)), new_role = \"predictor\")  f <- frosting() %>%   layer_predict() %>%   layer_residual_quantiles() %>%   layer_add_forecast_date() %>%   layer_add_target_date() %>%   layer_threshold(starts_with(\".pred\"))  eng <- linear_reg() %>% set_engine(\"flatline\") wf <- epi_workflow(r, eng, f) %>% fit(jhu) preds <- forecast(wf)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flatline_forecaster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict the future with today's value ‚Äî flatline_forecaster","text":"","code":"jhu <- covid_case_death_rates %>%   dplyr::filter(time_value >= as.Date(\"2021-12-01\"))  out <- flatline_forecaster(jhu, \"death_rate\")"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flusight_hub_formatter.html","id":null,"dir":"Reference","previous_headings":"","what":"Format predictions for submission to FluSight forecast Hub ‚Äî flusight_hub_formatter","title":"Format predictions for submission to FluSight forecast Hub ‚Äî flusight_hub_formatter","text":"function converts predictions included forecasters format (nearly) ready submission 2023-24 FluSight-forecast-hub. See documentation required columns. Currently, \"quantile\" forcasts supported, intention support \"quantile\" \"pmf\". reason, adding output_type column done via ... argument. See examples . specific required format forecast task .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flusight_hub_formatter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format predictions for submission to FluSight forecast Hub ‚Äî flusight_hub_formatter","text":"","code":"flusight_hub_formatter(object, ..., .fcast_period = c(\"daily\", \"weekly\"))"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flusight_hub_formatter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format predictions for submission to FluSight forecast Hub ‚Äî flusight_hub_formatter","text":"object data.frame predictions object class canned_epipred created , e.g., arx_forecaster() ... <dynamic-dots> Name = value pairs constant columns (mutations) perform results. See examples. .fcast_period Control whether horizon represent days weeks. Depending whether forecaster output target dates layer_add_target_date() , may need compute horizon /target_end_date available columns predictions. ahead target_date available, ignored. ahead aheads exists, target date may need multiplied ahead represents weekly forecasts. Alternatively, , target_date available, horizon days, unless argument \"weekly\". Note can adjusted later ... argument.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flusight_hub_formatter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format predictions for submission to FluSight forecast Hub ‚Äî flusight_hub_formatter","text":"tibble::tibble. ... empty, result contain columns reference_date, horizon, target_end_date, location, output_type_id, value. ... can perform mutations .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/flusight_hub_formatter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format predictions for submission to FluSight forecast Hub ‚Äî flusight_hub_formatter","text":"","code":"library(dplyr) library(epiprocess) weekly_deaths <- covid_case_death_rates %>%   filter(     time_value >= as.Date(\"2021-09-01\"),     geo_value %in% c(\"ca\", \"ny\", \"dc\", \"ga\", \"vt\")   ) %>%   select(geo_value, time_value, death_rate) %>%   left_join(state_census %>% select(pop, abbr), by = c(\"geo_value\" = \"abbr\")) %>%   mutate(deaths = pmax(death_rate / 1e5 * pop * 7, 0)) %>%   select(-pop, -death_rate) %>%   group_by(geo_value) %>%   epi_slide(~ sum(.$deaths), .window_size = 7, .new_col_name = \"deaths_7dsum\") %>%   ungroup() %>%   filter(weekdays(time_value) == \"Saturday\")  cdc <- cdc_baseline_forecaster(weekly_deaths, \"deaths_7dsum\") flusight_hub_formatter(cdc) #> # A tibble: 575 √ó 7 #>    reference_date horizon target_end_date location output_type_id value .pred #>    <date>           <int> <date>          <chr>             <dbl> <dbl> <dbl> #>  1 2021-12-25           1 2022-01-01      06                0.01  2147. 3166. #>  2 2021-12-25           1 2022-01-01      06                0.025 2165. 3166. #>  3 2021-12-25           1 2022-01-01      06                0.05  2215. 3166. #>  4 2021-12-25           1 2022-01-01      06                0.1   2277. 3166. #>  5 2021-12-25           1 2022-01-01      06                0.15  2594. 3166. #>  6 2021-12-25           1 2022-01-01      06                0.2   2847. 3166. #>  7 2021-12-25           1 2022-01-01      06                0.25  2886. 3166. #>  8 2021-12-25           1 2022-01-01      06                0.3   2931. 3166. #>  9 2021-12-25           1 2022-01-01      06                0.35  2977. 3166. #> 10 2021-12-25           1 2022-01-01      06                0.4   3001. 3166. #> # ‚Ñπ 565 more rows flusight_hub_formatter(cdc, target = \"wk inc covid deaths\") #> # A tibble: 575 √ó 8 #>    reference_date horizon target_end_date location output_type_id value .pred #>    <date>           <int> <date>          <chr>             <dbl> <dbl> <dbl> #>  1 2021-12-25           1 2022-01-01      06                0.01  2147. 3166. #>  2 2021-12-25           1 2022-01-01      06                0.025 2165. 3166. #>  3 2021-12-25           1 2022-01-01      06                0.05  2215. 3166. #>  4 2021-12-25           1 2022-01-01      06                0.1   2277. 3166. #>  5 2021-12-25           1 2022-01-01      06                0.15  2594. 3166. #>  6 2021-12-25           1 2022-01-01      06                0.2   2847. 3166. #>  7 2021-12-25           1 2022-01-01      06                0.25  2886. 3166. #>  8 2021-12-25           1 2022-01-01      06                0.3   2931. 3166. #>  9 2021-12-25           1 2022-01-01      06                0.35  2977. 3166. #> 10 2021-12-25           1 2022-01-01      06                0.4   3001. 3166. #> # ‚Ñπ 565 more rows #> # ‚Ñπ 1 more variable: target <chr> flusight_hub_formatter(cdc, target = paste(horizon, \"wk inc covid deaths\")) #> # A tibble: 575 √ó 8 #>    reference_date horizon target_end_date location output_type_id value .pred #>    <date>           <int> <date>          <chr>             <dbl> <dbl> <dbl> #>  1 2021-12-25           1 2022-01-01      06                0.01  2147. 3166. #>  2 2021-12-25           1 2022-01-01      06                0.025 2165. 3166. #>  3 2021-12-25           1 2022-01-01      06                0.05  2215. 3166. #>  4 2021-12-25           1 2022-01-01      06                0.1   2277. 3166. #>  5 2021-12-25           1 2022-01-01      06                0.15  2594. 3166. #>  6 2021-12-25           1 2022-01-01      06                0.2   2847. 3166. #>  7 2021-12-25           1 2022-01-01      06                0.25  2886. 3166. #>  8 2021-12-25           1 2022-01-01      06                0.3   2931. 3166. #>  9 2021-12-25           1 2022-01-01      06                0.35  2977. 3166. #> 10 2021-12-25           1 2022-01-01      06                0.4   3001. 3166. #> # ‚Ñπ 565 more rows #> # ‚Ñπ 1 more variable: target <chr> flusight_hub_formatter(cdc, target = \"wk inc covid deaths\", output_type = \"quantile\") #> # A tibble: 575 √ó 9 #>    reference_date horizon target_end_date location output_type_id value .pred #>    <date>           <int> <date>          <chr>             <dbl> <dbl> <dbl> #>  1 2021-12-25           1 2022-01-01      06                0.01  2147. 3166. #>  2 2021-12-25           1 2022-01-01      06                0.025 2165. 3166. #>  3 2021-12-25           1 2022-01-01      06                0.05  2215. 3166. #>  4 2021-12-25           1 2022-01-01      06                0.1   2277. 3166. #>  5 2021-12-25           1 2022-01-01      06                0.15  2594. 3166. #>  6 2021-12-25           1 2022-01-01      06                0.2   2847. 3166. #>  7 2021-12-25           1 2022-01-01      06                0.25  2886. 3166. #>  8 2021-12-25           1 2022-01-01      06                0.3   2931. 3166. #>  9 2021-12-25           1 2022-01-01      06                0.35  2977. 3166. #> 10 2021-12-25           1 2022-01-01      06                0.4   3001. 3166. #> # ‚Ñπ 565 more rows #> # ‚Ñπ 2 more variables: target <chr>, output_type <chr>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/forecast.epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Produce a forecast from an epi workflow and it's training data ‚Äî forecast.epi_workflow","title":"Produce a forecast from an epi workflow and it's training data ‚Äî forecast.epi_workflow","text":"forecast.epi_workflow predicts restricting training data latest available data, predicting . binds together get_test_data() predict().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/forecast.epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Produce a forecast from an epi workflow and it's training data ‚Äî forecast.epi_workflow","text":"","code":"# S3 method for class 'epi_workflow' forecast(object, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/forecast.epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Produce a forecast from an epi workflow and it's training data ‚Äî forecast.epi_workflow","text":"object epi workflow. ... used.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/forecast.epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Produce a forecast from an epi workflow and it's training data ‚Äî forecast.epi_workflow","text":"forecast tibble.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/forecast.epi_workflow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Produce a forecast from an epi workflow and it's training data ‚Äî forecast.epi_workflow","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-08-01\")  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()  epi_workflow(r, parsnip::linear_reg()) %>%   fit(jhu) %>%   forecast() #> An `epi_df` object, 56 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 56 √ó 3 #>    geo_value time_value .pred #>    <chr>     <date>     <dbl> #>  1 ak        2021-12-31 0.550 #>  2 al        2021-12-31 0.290 #>  3 ar        2021-12-31 0.504 #>  4 as        2021-12-31 0.148 #>  5 az        2021-12-31 0.724 #>  6 ca        2021-12-31 0.258 #>  7 co        2021-12-31 0.454 #>  8 ct        2021-12-31 0.333 #>  9 dc        2021-12-31 0.204 #> 10 de        2021-12-31 0.402 #> # ‚Ñπ 46 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/format_varnames.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"Designed give good output interpolated cli. Main purpose add backticks around variable names necessary, something empty string length 0.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/format_varnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"format_varnames(x, empty = \"*none*\")"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/format_varnames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"x chr; e.g., colnames data frame empty string; output x length 0?","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/format_varnames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"","text":"chr","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/frosting.html","id":null,"dir":"Reference","previous_headings":"","what":"Create frosting for post-processing predictions ‚Äî frosting","title":"Create frosting for post-processing predictions ‚Äî frosting","text":"generates post-processing container (much like recipes::recipe()) hold steps post-processing predictions.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/frosting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create frosting for post-processing predictions ‚Äî frosting","text":"","code":"frosting(layers = NULL, requirements = NULL)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/frosting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create frosting for post-processing predictions ‚Äî frosting","text":"layers Must NULL. requirements Must NULL.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/frosting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create frosting for post-processing predictions ‚Äî frosting","text":"frosting object.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/frosting.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create frosting for post-processing predictions ‚Äî frosting","text":"arguments currently placeholders must NULL","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/frosting.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create frosting for post-processing predictions ‚Äî frosting","text":"","code":"# Toy example to show that frosting can be created and added for post-processing f <- frosting() wf <- epi_workflow() %>% add_frosting(f)  # A more realistic example jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()  wf <- epi_workflow(r, parsnip::linear_reg()) %>% fit(jhu)  f <- frosting() %>%   layer_predict() %>%   layer_naomit(.pred)  wf1 <- wf %>% add_frosting(f)  p <- forecast(wf1) p #> An `epi_df` object, 3 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 3 #>   geo_value time_value .pred #>   <chr>     <date>     <dbl> #> 1 ak        2021-12-31 0.245 #> 2 ca        2021-12-31 0.312 #> 3 ny        2021-12-31 0.295"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_forecast_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the as_of for the forecast date, and make sure there's nothing very off about it. ‚Äî get_forecast_date","title":"Extract the as_of for the forecast date, and make sure there's nothing very off about it. ‚Äî get_forecast_date","text":"Extract as_of forecast date, make sure nothing .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_forecast_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the as_of for the forecast date, and make sure there's nothing very off about it. ‚Äî get_forecast_date","text":"","code":"get_forecast_date(new_data, info, epi_keys_checked, latency, columns = NULL)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_forecast_date_in_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"get the target date while in a layer ‚Äî get_forecast_date_in_layer","title":"get the target date while in a layer ‚Äî get_forecast_date_in_layer","text":"get target date layer","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_forecast_date_in_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get the target date while in a layer ‚Äî get_forecast_date_in_layer","text":"","code":"get_forecast_date_in_layer(this_recipe, workflow_max_time_value, new_data)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_forecast_date_in_layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get the target date while in a layer ‚Äî get_forecast_date_in_layer","text":"this_recipe recipe check step_adjust_latency workflow_max_time_value max_time value coming fit workflow (maximal time value potentially different dataset) new_data data currently working , take potentially different max_time_value","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_latency.html","id":null,"dir":"Reference","previous_headings":"","what":"the latency is also the amount the shift is off by ‚Äî get_latency","title":"the latency is also the amount the shift is off by ‚Äî get_latency","text":"latency also amount shift ","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_latency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"the latency is also the amount the shift is off by ‚Äî get_latency","text":"","code":"get_latency(new_data, forecast_date, column, sign_shift, epi_keys_checked)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_latency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"the latency is also the amount the shift is off by ‚Äî get_latency","text":"sign_shift integer. 1 lag -1 ahead. represent need shift data bring 3 day lagged value today.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_latency_table.html","id":null,"dir":"Reference","previous_headings":"","what":"create the latency table This is a table of column names and the latency adjustment necessary for that column. An example: ‚Äî get_latency_table","title":"create the latency table This is a table of column names and the latency adjustment necessary for that column. An example: ‚Äî get_latency_table","text":"col_name   latency  1 case_rate        5 2 death_rate       5","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_latency_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"create the latency table This is a table of column names and the latency adjustment necessary for that column. An example: ‚Äî get_latency_table","text":"","code":"get_latency_table(   training,   columns,   forecast_date,   latency,   sign_shift,   epi_keys_checked,   keys_to_ignore,   info,   terms )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_sign.html","id":null,"dir":"Reference","previous_headings":"","what":"lags move columns forward to bring the past up to today, while aheads drag the future back to today ‚Äî get_sign","title":"lags move columns forward to bring the past up to today, while aheads drag the future back to today ‚Äî get_sign","text":"lags move columns forward bring past today, aheads drag future back today","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_sign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"lags move columns forward to bring the past up to today, while aheads drag the future back to today ‚Äî get_sign","text":"","code":"get_sign(object)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_test_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Get test data for prediction based on longest lag period ‚Äî get_test_data","title":"Get test data for prediction based on longest lag period ‚Äî get_test_data","text":"predict() given full training dataset, produce prediction every time_value enough data. cases, generates predictions time_values outcome already observed.  get_test_data() designed restrict given dataset minimum amount needed produce forecast forecast_date future data, rather prediction past time_values.  Primarily based longest lag period recipe.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_test_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get test data for prediction based on longest lag period ‚Äî get_test_data","text":"","code":"get_test_data(recipe, x)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_test_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get test data for prediction based on longest lag period ‚Äî get_test_data","text":"recipe recipe object. x epi_df. typical usage pass data used fitting recipe.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_test_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get test data for prediction based on longest lag period ‚Äî get_test_data","text":"object type x columns geo_value, time_value, additional keys, well variables original dataset.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_test_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get test data for prediction based on longest lag period ‚Äî get_test_data","text":"minimum required (recent) data produce forecast equal maximum lag requested (predictor) plus longest horizon used growth rate calculations requested recipe. calculated internally.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/get_test_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get test data for prediction based on longest lag period ‚Äî get_test_data","text":"","code":"# create recipe rec <- epi_recipe(covid_case_death_rates) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) get_test_data(recipe = rec, x = covid_case_death_rates) #> An `epi_df` object, 840 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 840 √ó 4 #>    geo_value time_value case_rate death_rate #>    <chr>     <date>         <dbl>      <dbl> #>  1 ak        2021-12-17      23.1      1.19  #>  2 al        2021-12-17      15.6      0.290 #>  3 ar        2021-12-17      23.4      0.467 #>  4 as        2021-12-17       0        0     #>  5 az        2021-12-17      41.2      1.04  #>  6 ca        2021-12-17      16.8      0.158 #>  7 co        2021-12-17      31.8      0.371 #>  8 ct        2021-12-17      64.8      0.120 #>  9 dc        2021-12-17      50.4      0.140 #> 10 de        2021-12-17      67.9      0.333 #> # ‚Ñπ 830 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/grf_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Random quantile forests via grf ‚Äî grf_quantiles","title":"Random quantile forests via grf ‚Äî grf_quantiles","text":"grf::quantile_forest() fits random forests way makes easy calculate quantile forests. Currently, engine provided , since quantile regression typical use-case.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/grf_quantiles.html","id":"tuning-parameters","dir":"Reference","previous_headings":"","what":"Tuning Parameters","title":"Random quantile forests via grf ‚Äî grf_quantiles","text":"model 3 tuning parameters: mtry: # Randomly Selected Predictors (type: integer, default: see ) trees: # Trees (type: integer, default: 2000L) min_n: Minimal Node Size (type: integer, default: 5) mtry depends number columns design matrix. default grf::quantile_forest() min(ceiling(sqrt(ncol(X)) + 20), ncol(X)). categorical predictors, one-hot encoding always used. makes splitting efficient, implications mtry choice. factor many levels become large number columns design matrix means may selected frequently potential splits. different implementations random forest. details, see grf discussion.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/grf_quantiles.html","id":"translation-from-parsnip-to-the-original-package","dir":"Reference","previous_headings":"","what":"Translation from parsnip to the original package","title":"Random quantile forests via grf ‚Äî grf_quantiles","text":"","code":"rand_forest(   mode = \"regression\", # you must specify the `mode = regression`   mtry = integer(1),   trees = integer(1),   min_n = integer(1) ) %>%   set_engine(\"grf_quantiles\") %>%   translate() #> Random Forest Model Specification (regression) #> #> Main Arguments: #>   mtry = integer(1) #>   trees = integer(1) #>   min_n = integer(1) #> #> Computational engine: grf_quantiles #> #> Model fit template: #> grf::quantile_forest(X = missing_arg(), Y = missing_arg(), mtry = min_cols(~integer(1), #>     x), num.trees = integer(1), min.node.size = min_rows(~integer(1), #>     x), quantiles = c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95), #>     num.threads = 1L, seed = stats::runif(1, 0, .Machine$integer.max))"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/grf_quantiles.html","id":"case-weights","dir":"Reference","previous_headings":"","what":"Case weights","title":"Random quantile forests via grf ‚Äî grf_quantiles","text":"Case weights supported.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/grf_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random quantile forests via grf ‚Äî grf_quantiles","text":"","code":"library(grf) tib <- data.frame(   y = rnorm(100), x = rnorm(100), z = rnorm(100),   f = factor(sample(letters[1:3], 100, replace = TRUE)) ) spec <- rand_forest(engine = \"grf_quantiles\", mode = \"regression\") out <- fit(spec, formula = y ~ x + z, data = tib) predict(out, new_data = tib[1:5, ]) %>%   pivot_quantiles_wider(.pred) #> # A tibble: 5 √ó 7 #>   `0.05` `0.1` `0.25`   `0.5` `0.75` `0.9` `0.95` #>    <dbl> <dbl>  <dbl>   <dbl>  <dbl> <dbl>  <dbl> #> 1  -1.69 -1.23 -0.531 -0.242   0.497  1.45   1.62 #> 2  -1.34 -1.21 -0.390 -0.0336  0.516  1.63   2.25 #> 3  -1.25 -1.14 -0.531 -0.242   0.469  1.45   1.46 #> 4  -1.33 -1.25 -0.898 -0.331   0.497  1.62   1.92 #> 5  -1.58 -1.28 -0.689 -0.235   0.472  1.63   2.25  # -- adjusting the desired quantiles  spec <- rand_forest(mode = \"regression\") %>%   set_engine(engine = \"grf_quantiles\", quantiles = c(1:9 / 10)) out <- fit(spec, formula = y ~ x + z, data = tib) predict(out, new_data = tib[1:5, ]) %>%   pivot_quantiles_wider(.pred) #> # A tibble: 5 √ó 9 #>   `0.1`  `0.2`  `0.3`  `0.4`   `0.5`   `0.6` `0.7` `0.8` `0.9` #>   <dbl>  <dbl>  <dbl>  <dbl>   <dbl>   <dbl> <dbl> <dbl> <dbl> #> 1 -1.21 -0.774 -0.453 -0.310 -0.231  -0.0520 0.233 0.678  1.45 #> 2 -1.21 -0.599 -0.348 -0.231 -0.0520  0.233  0.469 0.809  1.63 #> 3 -1.04 -0.763 -0.496 -0.348 -0.231  -0.0524 0.183 0.761  1.45 #> 4 -1.25 -0.916 -0.530 -0.390 -0.331  -0.231  0.126 0.678  1.62 #> 5 -1.28 -0.710 -0.453 -0.304 -0.201  -0.0736 0.233 0.678  1.62  # -- a more complicated task  dat <- covid_case_death_rates %>%   filter(time_value > as.Date(\"2021-10-01\")) rec <- epi_recipe(dat) %>%   step_epi_lag(case_rate, death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit() frost <- frosting() %>%   layer_predict() %>%   layer_threshold(.pred) spec <- rand_forest(mode = \"regression\") %>%   set_engine(engine = \"grf_quantiles\", quantiles = c(.25, .5, .75))  ewf <- epi_workflow(rec, spec, frost) %>%   fit(dat) %>%   forecast() ewf %>%   rename(forecast_date = time_value) %>%   mutate(target_date = forecast_date + 7L) %>%   pivot_quantiles_wider(.pred) #> # A tibble: 56 √ó 6 #>    geo_value forecast_date target_date `0.25` `0.5` `0.75` #>    <chr>     <date>        <date>       <dbl> <dbl>  <dbl> #>  1 ak        2021-12-31    2022-01-07  0.196  0.269  0.445 #>  2 al        2021-12-31    2022-01-07  0.143  0.201  0.298 #>  3 ar        2021-12-31    2022-01-07  0.461  0.523  0.621 #>  4 as        2021-12-31    2022-01-07  0      0      0     #>  5 az        2021-12-31    2022-01-07  0.518  0.668  0.860 #>  6 ca        2021-12-31    2022-01-07  0.180  0.225  0.267 #>  7 co        2021-12-31    2022-01-07  0.351  0.480  0.635 #>  8 ct        2021-12-31    2022-01-07  0.333  0.419  0.458 #>  9 dc        2021-12-31    2022-01-07  0.0811 0.216  0.459 #> 10 de        2021-12-31    2022-01-07  0.249  0.387  0.530 #> # ‚Ñπ 46 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/is_epi_recipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for epi_recipe ‚Äî is_epi_recipe","title":"Test for epi_recipe ‚Äî is_epi_recipe","text":"Test epi_recipe","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/is_epi_recipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for epi_recipe ‚Äî is_epi_recipe","text":"","code":"is_epi_recipe(x)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/is_epi_recipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for epi_recipe ‚Äî is_epi_recipe","text":"x object.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/is_epi_recipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for epi_recipe ‚Äî is_epi_recipe","text":"TRUE object inherits epi_recipe.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/is_epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for an epi_workflow ‚Äî is_epi_workflow","title":"Test for an epi_workflow ‚Äî is_epi_workflow","text":"Test epi_workflow","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/is_epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for an epi_workflow ‚Äî is_epi_workflow","text":"","code":"is_epi_workflow(x)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/is_epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for an epi_workflow ‚Äî is_epi_workflow","text":"x object.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/is_epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for an epi_workflow ‚Äî is_epi_workflow","text":"TRUE object inherits epi_workflow.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/isoweek_leap.html","id":null,"dir":"Reference","previous_headings":"","what":"isoweek, but it assigns week 53 the value of 999 instead so it mirrors the assignments in yday_leap ‚Äî isoweek_leap","title":"isoweek, but it assigns week 53 the value of 999 instead so it mirrors the assignments in yday_leap ‚Äî isoweek_leap","text":"isoweek, assigns week 53 value 999 instead mirrors assignments yday_leap","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/isoweek_leap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"isoweek, but it assigns week 53 the value of 999 instead so it mirrors the assignments in yday_leap ‚Äî isoweek_leap","text":"","code":"isoweek_leap(time_value)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer-processors.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract, validate, or detect layers of frosting ‚Äî extract_layers","title":"Extract, validate, or detect layers of frosting ‚Äî extract_layers","text":"functions mainly internal. can access validate different layers frosting.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer-processors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract, validate, or detect layers of frosting ‚Äî extract_layers","text":"","code":"extract_layers(x, ...)  # S3 method for class 'frosting' extract_layers(x, ...)  # S3 method for class 'workflow' extract_layers(x, ...)  is_layer(x)  validate_layer(x, ..., arg = rlang::caller_arg(x), call = caller_env())  detect_layer(x, name, ...)  # S3 method for class 'frosting' detect_layer(x, name, ...)  # S3 method for class 'workflow' detect_layer(x, name, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer-processors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract, validate, or detect layers of frosting ‚Äî extract_layers","text":"x epi_workflow, frosting, layer object ... additional arguments possible future methods arg name input (error reporting) call environment (error reporting) name layer name detect","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer-processors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract, validate, or detect layers of frosting ‚Äî extract_layers","text":"logical validators/detectors list layers extractors","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer-processors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract, validate, or detect layers of frosting ‚Äî extract_layers","text":"","code":"f <- frosting() %>% layer_predict() wf <- epi_workflow(postprocessor = f)  is_layer(layer(\"what_the_what\")) #> Error: Can't create layer without a stat. detect_layer(f, \"layer_predict\") #> [1] TRUE detect_layer(wf, \"layer_predict\") #> [1] TRUE  extract_layers(f) #> [[1]] #> Creating predictions: \"<calculated>\" #>  extract_layers(wf) #> [[1]] #> Creating predictions: \"<calculated>\" #>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer.html","id":null,"dir":"Reference","previous_headings":"","what":"layer sets the class of the layer ‚Äî layer","title":"layer sets the class of the layer ‚Äî layer","text":"layer sets class layer","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"layer sets the class of the layer ‚Äî layer","text":"","code":"layer(subclass, ..., .prefix = \"layer_\")"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"layer sets the class of the layer ‚Äî layer","text":"subclass character string resulting class. example, subclass = \"blah\" layer object returned class layer_blah. ... arguments operator returned. .prefix Prefix subclass created.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"layer sets the class of the layer ‚Äî layer","text":"updated layer new class","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_add_forecast_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Post-processing step to add the forecast date ‚Äî layer_add_forecast_date","title":"Post-processing step to add the forecast date ‚Äî layer_add_forecast_date","text":"Post-processing step add forecast date","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_add_forecast_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Post-processing step to add the forecast date ‚Äî layer_add_forecast_date","text":"","code":"layer_add_forecast_date(   frosting,   forecast_date = NULL,   id = rand_id(\"add_forecast_date\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_add_forecast_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Post-processing step to add the forecast date ‚Äî layer_add_forecast_date","text":"frosting frosting postprocessor forecast_date forecast date add column epi_df. cases, specified form \"yyyy-mm-dd\". Note forecast date left unspecified, set one two values.  step_adjust_latency step present, uses forecast_date set function. Otherwise, uses maximum time_value across data used pre-processing, fitting model, post-processing. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_add_forecast_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Post-processing step to add the forecast date ‚Äî layer_add_forecast_date","text":"updated frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_add_forecast_date.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Post-processing step to add the forecast date ‚Äî layer_add_forecast_date","text":"use function, either specify forecast date leave forecast date unspecifed . latter case, forecast date set maximum time value data used pre-processing, fitting model, post-processing. case, forecast date less maximum as_of value (data used pre-processing, model fitting, post-processing), appropriate warning thrown.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_add_forecast_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Post-processing step to add the forecast date ‚Äî layer_add_forecast_date","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\")) r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit() wf <- epi_workflow(r, linear_reg()) %>% fit(jhu) latest <- jhu %>%   filter(time_value >= max(time_value) - 14)  # Don't specify `forecast_date` (by default, this should be last date in latest) f <- frosting() %>%   layer_predict() %>%   layer_naomit(.pred) wf0 <- wf %>% add_frosting(f) p0 <- predict(wf0, latest) p0 #> An `epi_df` object, 3 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 3 #>   geo_value time_value .pred #>   <chr>     <date>     <dbl> #> 1 ak        2021-12-31 0.245 #> 2 ca        2021-12-31 0.312 #> 3 ny        2021-12-31 0.295  # Specify a `forecast_date` that is greater than or equal to `as_of` date f <- frosting() %>%   layer_predict() %>%   layer_add_forecast_date(forecast_date = \"2022-05-31\") %>%   layer_naomit(.pred) wf1 <- wf %>% add_frosting(f)  p1 <- predict(wf1, latest) p1 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 4 #>   geo_value time_value .pred forecast_date #>   <chr>     <date>     <dbl> <date>        #> 1 ak        2021-12-31 0.245 2022-05-31    #> 2 ca        2021-12-31 0.312 2022-05-31    #> 3 ny        2021-12-31 0.295 2022-05-31     # Specify a `forecast_date` that is less than `as_of` date f2 <- frosting() %>%   layer_predict() %>%   layer_add_forecast_date(forecast_date = \"2021-12-31\") %>%   layer_naomit(.pred) wf2 <- wf %>% add_frosting(f2)  p2 <- predict(wf2, latest) p2 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 4 #>   geo_value time_value .pred forecast_date #>   <chr>     <date>     <dbl> <date>        #> 1 ak        2021-12-31 0.245 2021-12-31    #> 2 ca        2021-12-31 0.312 2021-12-31    #> 3 ny        2021-12-31 0.295 2021-12-31     # Do not specify a forecast_date f3 <- frosting() %>%   layer_predict() %>%   layer_add_forecast_date() %>%   layer_naomit(.pred) wf3 <- wf %>% add_frosting(f3)  p3 <- predict(wf3, latest) p3 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 4 #>   geo_value time_value .pred forecast_date #>   <chr>     <date>     <dbl> <date>        #> 1 ak        2021-12-31 0.245 2021-12-31    #> 2 ca        2021-12-31 0.312 2021-12-31    #> 3 ny        2021-12-31 0.295 2021-12-31"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_add_target_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Post-processing step to add the target date ‚Äî layer_add_target_date","title":"Post-processing step to add the target date ‚Äî layer_add_target_date","text":"Post-processing step add target date","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_add_target_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Post-processing step to add the target date ‚Äî layer_add_target_date","text":"","code":"layer_add_target_date(   frosting,   target_date = NULL,   id = rand_id(\"add_target_date\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_add_target_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Post-processing step to add the target date ‚Äî layer_add_target_date","text":"frosting frosting postprocessor target_date target date add column epi_df. forecast date specified upstream (either step_adjust_latency layer_forecast_date), forecast date plus ahead (step_epi_ahead epi_recipe). Otherwise, maximum time_value (data used pre-processing, fitting model, post-processing) plus ahead, ahead specified preprocessing. user may override specifying target date (form \"yyyy-mm-dd\"). id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_add_target_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Post-processing step to add the target date ‚Äî layer_add_target_date","text":"updated frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_add_target_date.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Post-processing step to add the target date ‚Äî layer_add_target_date","text":"default, function assumes value ahead specified preprocessing step (likely step_epi_ahead). , ahead added forecast_date test data get target date. forecast_date can set 3 ways: default forecast_date simply maximum time_value every dataset used (prep, training, prediction). step_adjust_latency present, typically use training epi_df's as_of layer_add_forecast_date, inherits 2 manually specifed","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_add_target_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Post-processing step to add the target date ‚Äî layer_add_target_date","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\")) r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()  wf <- epi_workflow(r, linear_reg()) %>% fit(jhu)  # Use ahead + forecast date f <- frosting() %>%   layer_predict() %>%   layer_add_forecast_date(forecast_date = as.Date(\"2022-05-31\")) %>%   layer_add_target_date() %>%   layer_naomit(.pred) wf1 <- wf %>% add_frosting(f)  p <- forecast(wf1) p #> An `epi_df` object, 3 x 5 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 5 #>   geo_value time_value .pred forecast_date target_date #>   <chr>     <date>     <dbl> <date>        <date>      #> 1 ak        2021-12-31 0.245 2022-05-31    2022-06-07  #> 2 ca        2021-12-31 0.312 2022-05-31    2022-06-07  #> 3 ny        2021-12-31 0.295 2022-05-31    2022-06-07   # Use ahead + forecast_date from adjust_latency # setting the `as_of` to something realistic attributes(jhu)$metadata$as_of <- max(jhu$time_value) + 3 r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_adjust_latency(method = \"extend_ahead\") %>%   step_epi_naomit() #> Warning: If `method` is \"extend_ahead\", then the previous `step_epi_ahead` won't be #> modified. f2 <- frosting() %>%   layer_predict() %>%   layer_add_target_date() %>%   layer_naomit(.pred) wf2 <- wf %>% add_frosting(f2)  p2 <- forecast(wf2) p2 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 4 #>   geo_value time_value .pred target_date #>   <chr>     <date>     <dbl> <date>      #> 1 ak        2021-12-31 0.245 2022-01-07  #> 2 ca        2021-12-31 0.312 2022-01-07  #> 3 ny        2021-12-31 0.295 2022-01-07   # Use ahead + max time value from pre, fit, post # which is the same if include `layer_add_forecast_date()` f3 <- frosting() %>%   layer_predict() %>%   layer_add_target_date() %>%   layer_naomit(.pred) wf3 <- wf %>% add_frosting(f3)  p3 <- forecast(wf2) p2 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 4 #>   geo_value time_value .pred target_date #>   <chr>     <date>     <dbl> <date>      #> 1 ak        2021-12-31 0.245 2022-01-07  #> 2 ca        2021-12-31 0.312 2022-01-07  #> 3 ny        2021-12-31 0.295 2022-01-07   # Specify own target date f4 <- frosting() %>%   layer_predict() %>%   layer_add_target_date(target_date = \"2022-01-08\") %>%   layer_naomit(.pred) wf4 <- wf %>% add_frosting(f4)  p4 <- forecast(wf4) p4 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 4 #>   geo_value time_value .pred target_date #>   <chr>     <date>     <dbl> <date>      #> 1 ak        2021-12-31 0.245 2022-01-08  #> 2 ca        2021-12-31 0.312 2022-01-08  #> 3 ny        2021-12-31 0.295 2022-01-08"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_cdc_flatline_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"CDC Flatline Forecast Quantiles ‚Äî layer_cdc_flatline_quantiles","title":"CDC Flatline Forecast Quantiles ‚Äî layer_cdc_flatline_quantiles","text":"layer creates quantile forecasts taking sample interpolated CDF flatline residuals, shuffling . added point prediction.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_cdc_flatline_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CDC Flatline Forecast Quantiles ‚Äî layer_cdc_flatline_quantiles","text":"","code":"layer_cdc_flatline_quantiles(   frosting,   ...,   aheads = 1:4,   quantile_levels = c(0.01, 0.025, 1:19/20, 0.975, 0.99),   nsims = 1000,   by_key = \"geo_value\",   symmetrize = FALSE,   nonneg = TRUE,   id = rand_id(\"cdc_baseline_bands\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_cdc_flatline_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CDC Flatline Forecast Quantiles ‚Äî layer_cdc_flatline_quantiles","text":"frosting frosting postprocessor ... Unused, include consistency layers. aheads Numeric vector desired forecast horizons. given \"units training data\". , example, data typically observed daily (possibly missing values), weekly forecast targets, use c(7, 14, 21, 28). weekly data, use 1:4. quantile_levels Numeric vector probabilities values (0,1) referring desired predictive intervals. default standard set COVID Forecast Hub. nsims Positive integer. number draws empirical CDF. samples spaced evenly (0, 1) scale, F_X(x) resulting linear interpolation X scale. achieved stats::quantile() Type 7 (default function). by_key character vector keys group residuals calculating quantiles. default, c() performs grouping. symmetrize Scalar logical. TRUE, two things: () forces \"empirical\" CDF residuals symmetric pretending every actually-observed residual X also observed another residual -X, (ii) ahead, forces median simulated value equal point prediction adding subtracting amount every simulated value. Adjustments (ii) take place propagating forward simulating next ahead. forces 1-ahead predictive intervals symmetric point prediction, encourages larger aheads symmetric. nonneg Scalar logical. Force predictive intervals non-negative. non-negativity forced propagating forward, slightly different behaviour occur using layer_threshold(). Thresholding ahead takes place shifting symmetrize. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_cdc_flatline_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CDC Flatline Forecast Quantiles ‚Äî layer_cdc_flatline_quantiles","text":"updated frosting postprocessor. Calling predict() result additional <list-col> named .pred_distn_all containing 2-column tibble::tibble()'s. desired combination key's, tibble contain one row per ahead associated quantile_pred().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_cdc_flatline_quantiles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"CDC Flatline Forecast Quantiles ‚Äî layer_cdc_flatline_quantiles","text":"layer intended used concert flatline(). can also used anything else. long residuals available fitted model, layer useful. Like layer_residual_quantiles() uses residuals fitted model object. However, propagates forward aheads, iteratively shuffling (randomly), adding previous set. contrast happens flatline_forecaster(). using flatline() underlying engine (), result predictions (recent observed value), model calculates separate residuals ahead comparing observations future. version continues use set residuals, adds produce wider intervals ahead increases.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_cdc_flatline_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CDC Flatline Forecast Quantiles ‚Äî layer_cdc_flatline_quantiles","text":"","code":"library(recipes) #>  #> Attaching package: ‚Äòrecipes‚Äô #> The following object is masked from ‚Äòpackage:stats‚Äô: #>  #>     step r <- epi_recipe(covid_case_death_rates) %>%   # data is \"daily\", so we fit this to 1 ahead, the result will contain   # 1 day ahead residuals   step_epi_ahead(death_rate, ahead = 1L, skip = TRUE) %>%   update_role(death_rate, new_role = \"predictor\") %>%   add_role(time_value, geo_value, new_role = \"predictor\")  forecast_date <- max(covid_case_death_rates$time_value)  f <- frosting() %>%   layer_predict() %>%   layer_cdc_flatline_quantiles(aheads = c(7, 14, 21, 28), symmetrize = TRUE)  eng <- linear_reg(engine = \"flatline\")  wf <- epi_workflow(r, eng, f) %>% fit(covid_case_death_rates) preds <- forecast(wf) %>%   select(-time_value) %>%   mutate(forecast_date = forecast_date) preds #> # A tibble: 56 √ó 4 #>    geo_value  .pred .pred_distn_all  forecast_date #>    <chr>      <dbl> <list>           <date>        #>  1 ak        0.0395 <tibble [4 √ó 2]> 2021-12-31    #>  2 al        0.107  <tibble [4 √ó 2]> 2021-12-31    #>  3 ar        0.490  <tibble [4 √ó 2]> 2021-12-31    #>  4 as        0      <tibble [4 √ó 2]> 2021-12-31    #>  5 az        0.608  <tibble [4 √ó 2]> 2021-12-31    #>  6 ca        0.139  <tibble [4 √ó 2]> 2021-12-31    #>  7 co        0.551  <tibble [4 √ó 2]> 2021-12-31    #>  8 ct        0.333  <tibble [4 √ó 2]> 2021-12-31    #>  9 dc        0.0802 <tibble [4 √ó 2]> 2021-12-31    #> 10 de        0.217  <tibble [4 √ó 2]> 2021-12-31    #> # ‚Ñπ 46 more rows  preds <- preds %>%   tidyr::unnest(.pred_distn_all) %>%   pivot_quantiles_wider(.pred_distn) %>%   mutate(target_date = forecast_date + ahead)  library(ggplot2) four_states <- c(\"ca\", \"pa\", \"wa\", \"ny\") preds %>%   filter(geo_value %in% four_states) %>%   ggplot(aes(target_date)) +   geom_ribbon(aes(ymin = `0.1`, ymax = `0.9`), fill = blues9[3]) +   geom_ribbon(aes(ymin = `0.25`, ymax = `0.75`), fill = blues9[6]) +   geom_line(aes(y = .pred), color = \"orange\") +   geom_line(     data = covid_case_death_rates %>% filter(geo_value %in% four_states),     aes(x = time_value, y = death_rate)   ) +   scale_x_date(limits = c(forecast_date - 90, forecast_date + 30)) +   labs(x = \"Date\", y = \"Death rate\") +   facet_wrap(~geo_value, scales = \"free_y\") +   theme_bw() +   geom_vline(xintercept = forecast_date) #> Warning: Removed 275 rows containing missing values or values outside the scale range #> (`geom_line()`)."},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_naomit.html","id":null,"dir":"Reference","previous_headings":"","what":"Omit NAs from predictions or other columns ‚Äî layer_naomit","title":"Omit NAs from predictions or other columns ‚Äî layer_naomit","text":"Omit NAs predictions columns","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_naomit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Omit NAs from predictions or other columns ‚Äî layer_naomit","text":"","code":"layer_naomit(frosting, ..., id = rand_id(\"naomit\"))"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_naomit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Omit NAs from predictions or other columns ‚Äî layer_naomit","text":"frosting frosting postprocessor ... <tidy-select> One unquoted expressions separated commas. Variable names can used positions data frame, expressions like x:y can used select range variables. Typical usage .pred remove rows NA predictions. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_naomit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Omit NAs from predictions or other columns ‚Äî layer_naomit","text":"updated frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_naomit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Omit NAs from predictions or other columns ‚Äî layer_naomit","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7)  wf <- epi_workflow(r, linear_reg()) %>% fit(jhu)  f <- frosting() %>%   layer_predict() %>%   layer_naomit(.pred)  wf1 <- wf %>% add_frosting(f)  p <- forecast(wf1) p #> An `epi_df` object, 3 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 3 #>   geo_value time_value .pred #>   <chr>     <date>     <dbl> #> 1 ak        2021-12-31 0.245 #> 2 ca        2021-12-31 0.312 #> 3 ny        2021-12-31 0.295"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_point_from_distn.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts distributional forecasts to point forecasts ‚Äî layer_point_from_distn","title":"Converts distributional forecasts to point forecasts ‚Äî layer_point_from_distn","text":"function adds post-processing layer extract point forecast distributional forecast. NOTE: default arguments, remove information, one usually call layer_quantile_distn() set name argument something specific.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_point_from_distn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts distributional forecasts to point forecasts ‚Äî layer_point_from_distn","text":"","code":"layer_point_from_distn(   frosting,   ...,   type = c(\"median\", \"mean\"),   name = NULL,   id = rand_id(\"point_from_distn\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_point_from_distn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts distributional forecasts to point forecasts ‚Äî layer_point_from_distn","text":"frosting frosting postprocessor ... Unused, include consistency layers. type character. Either mean median. name character. name output column. default NULL overwrite .pred column, removing distribution information. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_point_from_distn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts distributional forecasts to point forecasts ‚Äî layer_point_from_distn","text":"updated frosting postprocessor.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_point_from_distn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts distributional forecasts to point forecasts ‚Äî layer_point_from_distn","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()  wf <- epi_workflow(r, quantile_reg(quantile_levels = c(.25, .5, .75))) %>%   fit(jhu)  f1 <- frosting() %>%   layer_predict() %>%   layer_quantile_distn() %>% # puts the other quantiles in a different col   layer_point_from_distn() %>% # mutate `.pred` to contain only a point prediction   layer_naomit(.pred) wf1 <- wf %>% add_frosting(f1)  p1 <- forecast(wf1) p1 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 4 #>   geo_value time_value  .pred .pred_distn #>   <chr>     <date>      <dbl>   <qtls(7)> #> 1 ak        2021-12-31 0.0580     [0.058] #> 2 ca        2021-12-31 0.179      [0.179] #> 3 ny        2021-12-31 0.274      [0.274]  f2 <- frosting() %>%   layer_predict() %>%   layer_point_from_distn() %>% # mutate `.pred` to contain only a point prediction   layer_naomit(.pred) wf2 <- wf %>% add_frosting(f2)  p2 <- forecast(wf2) p2 #> An `epi_df` object, 3 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 3 #>   geo_value time_value  .pred #>   <chr>     <date>      <dbl> #> 1 ak        2021-12-31 0.0580 #> 2 ca        2021-12-31 0.179  #> 3 ny        2021-12-31 0.274"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_population_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert per-capita predictions to raw scale ‚Äî layer_population_scaling","title":"Convert per-capita predictions to raw scale ‚Äî layer_population_scaling","text":"layer_population_scaling creates specification frosting layer \"undo\" per-capita scaling done step_population_scaling(). Typical usage set df dataset contains list population geo_values, use convert predictions made raw scale model rate-scale dividing population. Although, worth noting nothing special \"population\",  function can used scale variable. Population standard use case epidemiology forecasting scenario. value passed multiply selected variables rate_rescaling argument common divisor selected variables.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_population_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert per-capita predictions to raw scale ‚Äî layer_population_scaling","text":"","code":"layer_population_scaling(   frosting,   ...,   df,   by = NULL,   df_pop_col,   rate_rescaling = 1,   create_new = TRUE,   suffix = \"_scaled\",   id = rand_id(\"population_scaling\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_population_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert per-capita predictions to raw scale ‚Äî layer_population_scaling","text":"frosting frosting postprocessor. layer added sequence operations frosting. ... One selector functions scale variables step. See recipes::selections() details. df data frame contains population data used inverting existing scaling. (possibly named) character vector variables join df onto epi_df . NULL, default, function try infer reasonable set columns. First, try join variables test data roles \"geo_value\", \"key\", \"time_value\" also appear df; roles automatically set using epi_df, can use, e.g., update_role. roles set, try perform natural join, using variables common training/test data population data. columns training/testing data df name (included ), .df suffix added one user-provided data disambiguate. join different variables epi_df df, use named vector. example, = c(\"geo_value\" = \"states\") match epi_df$geo_value df$states. join multiple variables, use vector length > 1. example, = c(\"geo_value\" = \"states\", \"county\" = \"county\") match epi_df$geo_value df$states epi_df$county df$county. See dplyr::left_join() details. df_pop_col name column data frame df contains population data used scaling. rate_rescaling Sometimes rates \"per 100K\" \"per 1M\" rather \"per person\". Adjustments can made . example, original rate \"per 100K\", set rate_rescaling = 1e5 get counts back. create_new TRUE create new column keep original column epi_df. suffix character. suffix added column name create_new = TRUE. Default \"_scaled\". id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_population_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert per-capita predictions to raw scale ‚Äî layer_population_scaling","text":"updated frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_population_scaling.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert per-capita predictions to raw scale ‚Äî layer_population_scaling","text":"","code":"jhu <- cases_deaths_subset %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ca\", \"ny\")) %>%   select(geo_value, time_value, cases)  pop_data <- data.frame(states = c(\"ca\", \"ny\"), value = c(20000, 30000))  r <- epi_recipe(jhu) %>%   step_population_scaling(     df = pop_data,     df_pop_col = \"value\",     by = c(\"geo_value\" = \"states\"),     cases, suffix = \"_scaled\"   ) %>%   step_epi_lag(cases_scaled, lag = c(0, 7, 14)) %>%   step_epi_ahead(cases_scaled, ahead = 7, role = \"outcome\") %>%   step_epi_naomit()  f <- frosting() %>%   layer_predict() %>%   layer_threshold(.pred) %>%   layer_naomit(.pred) %>%   layer_population_scaling(.pred,     df = pop_data,     by = c(\"geo_value\" = \"states\"),     df_pop_col = \"value\"   )  wf <- epi_workflow(r, linear_reg()) %>%   fit(jhu) %>%   add_frosting(f)  forecast(wf) #> An `epi_df` object, 2 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2024-03-20 #>  #> # A tibble: 2 √ó 4 #>   geo_value time_value .pred .pred_scaled #>   <chr>     <date>     <dbl>        <dbl> #> 1 ca        2021-12-31  4.25       84938. #> 2 ny        2021-12-31  5.93      177766."},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction layer for post-processing ‚Äî layer_predict","title":"Prediction layer for post-processing ‚Äî layer_predict","text":"Implements prediction fitted epi_workflow. One may want different types prediction, potentially apply amount post-processing. typically first layer frosting postprocessor.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction layer for post-processing ‚Äî layer_predict","text":"","code":"layer_predict(   frosting,   type = NULL,   opts = list(),   ...,   id = rand_id(\"predict_default\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction layer for post-processing ‚Äî layer_predict","text":"frosting frosting object type single character value NULL. Possible values \"numeric\", \"class\", \"prob\", \"conf_int\", \"pred_int\", \"quantile\", \"time\", \"hazard\", \"survival\", \"raw\". NULL, predict() choose appropriate value based model's mode. opts list optional arguments underlying predict function used type = \"raw\". list include options model object new data predicted. ... Additional parsnip-related options, depending value type. Arguments underlying model's prediction function passed (use opts argument instead). Possible arguments : interval: type equal \"survival\" \"quantile\", interval estimates added, available? Options \"none\" \"confidence\". level: type equal \"conf_int\", \"pred_int\", \"survival\", parameter tail area intervals (e.g. confidence level confidence intervals). Default value 0.95. std_error: type equal \"conf_int\" \"pred_int\", add standard error fit prediction (scale linear predictors). Default value FALSE. quantile: type equal quantile, quantiles distribution. Default (1:9)/10. eval_time: type equal \"survival\" \"hazard\", time points survival probability hazard estimated. id string identifying layer","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction layer for post-processing ‚Äî layer_predict","text":"updated frosting object","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_predict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction layer for post-processing ‚Äî layer_predict","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()  wf <- epi_workflow(r, linear_reg()) %>% fit(jhu) latest <- jhu %>% filter(time_value >= max(time_value) - 14)  # Predict layer alone f <- frosting() %>% layer_predict() wf1 <- wf %>% add_frosting(f)  p1 <- predict(wf1, latest) p1 #> An `epi_df` object, 3 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 3 #>   geo_value time_value .pred #>   <chr>     <date>     <dbl> #> 1 ak        2021-12-31 0.245 #> 2 ca        2021-12-31 0.312 #> 3 ny        2021-12-31 0.295  # Prediction with interval f <- frosting() %>% layer_predict(type = \"pred_int\") wf2 <- wf %>% add_frosting(f)  p2 <- predict(wf2, latest) p2 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 4 #>   geo_value time_value .pred_lower .pred_upper #>   <chr>     <date>           <dbl>       <dbl> #> 1 ak        2021-12-31      -0.366       0.857 #> 2 ca        2021-12-31      -0.285       0.909 #> 3 ny        2021-12-31      -0.302       0.891"},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_predictive_distn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns predictive distributions ‚Äî layer_predictive_distn","text":"","code":"layer_predictive_distn(   frosting,   ...,   dist_type = c(\"gaussian\", \"student_t\"),   truncate = c(-Inf, Inf),   name = \".pred_distn\",   id = rand_id(\"predictive_distn\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_predictive_distn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns predictive distributions ‚Äî layer_predictive_distn","text":"frosting frosting postprocessor ... Unused, include consistency layers. dist_type Gaussian Student's t predictive intervals truncate truncate distribution interval name character. name output column. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_predictive_distn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns predictive distributions ‚Äî layer_predictive_distn","text":"updated frosting postprocessor additional columns residual quantiles added prediction","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_predictive_distn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns predictive distributions ‚Äî layer_predictive_distn","text":"function calculates approximation parametric predictive distribution. Predictive distributions linear models require x* (X'X)^{-1} x* along degrees freedom. function approximates . reasonably accurate models fit using lm new point x* far bulk data. Outside specific case, recommended use layer_residual_quantiles(), working model produces distributional predictions, use layer_quantile_distn().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_quantile_distn.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns predictive quantiles ‚Äî layer_quantile_distn","title":"Returns predictive quantiles ‚Äî layer_quantile_distn","text":"function calculates quantiles prediction distributional. model producing forecast distributional, recommended use layer_residual_quantiles() instead.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_quantile_distn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns predictive quantiles ‚Äî layer_quantile_distn","text":"","code":"layer_quantile_distn(   frosting,   ...,   quantile_levels = c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95),   truncate = c(-Inf, Inf),   name = \".pred_distn\",   id = rand_id(\"quantile_distn\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_quantile_distn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns predictive quantiles ‚Äî layer_quantile_distn","text":"frosting frosting postprocessor ... Unused, include consistency layers. quantile_levels vector probabilities extract truncate truncate distribution interval name character. name output column. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_quantile_distn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns predictive quantiles ‚Äî layer_quantile_distn","text":"updated frosting postprocessor. additional column predictive quantiles added predictions.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_quantile_distn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns predictive quantiles ‚Äî layer_quantile_distn","text":"Currently, distributional modes/engines quantile_reg() smooth_quantile_reg() rand_forest(mode = \"regression\") %>% set_engine(\"grf_quantiles\") engines used, layer grab estimated (extrapolated) quantiles requested quantile values.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_quantile_distn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns predictive quantiles ‚Äî layer_quantile_distn","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()  wf <- epi_workflow(r, quantile_reg(quantile_levels = c(.25, .5, .75))) %>%   fit(jhu)  f <- frosting() %>%   layer_predict() %>%   layer_quantile_distn() %>%   layer_naomit(.pred) wf1 <- wf %>% add_frosting(f)  p <- forecast(wf1) p #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 4 #>   geo_value time_value     .pred .pred_distn #>   <chr>     <date>     <qtls(3)>   <qtls(7)> #> 1 ak        2021-12-31   [0.058]     [0.058] #> 2 ca        2021-12-31   [0.179]     [0.179] #> 3 ny        2021-12-31   [0.274]     [0.274]"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_residual_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates predictions based on residual quantiles ‚Äî layer_residual_quantiles","title":"Creates predictions based on residual quantiles ‚Äî layer_residual_quantiles","text":"function calculates predictive quantiles based empirical quantiles model's residuals. model producing forecast distributional, recommended use layer_residual_quantiles() instead, accurate.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_residual_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates predictions based on residual quantiles ‚Äî layer_residual_quantiles","text":"","code":"layer_residual_quantiles(   frosting,   ...,   quantile_levels = c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95),   symmetrize = TRUE,   by_key = character(0L),   name = \".pred_distn\",   id = rand_id(\"residual_quantiles\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_residual_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates predictions based on residual quantiles ‚Äî layer_residual_quantiles","text":"frosting frosting postprocessor ... Unused, include consistency layers. quantile_levels numeric vector probabilities values (0,1) referring desired quantile. Note 0.5 always included even left user. symmetrize logical. TRUE interval symmetric. Typically, one want non-symmetric quantiles increasing trajectories quite different decreasing ones, strictly postive variable near zero. by_key character vector keys group residuals calculating quantiles. default, c() performs grouping. name character. name output column. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_residual_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates predictions based on residual quantiles ‚Äî layer_residual_quantiles","text":"updated frosting postprocessor additional columns residual quantiles added prediction","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_residual_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates predictions based on residual quantiles ‚Äî layer_residual_quantiles","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()  wf <- epi_workflow(r, linear_reg()) %>% fit(jhu)  f <- frosting() %>%   layer_predict() %>%   layer_residual_quantiles(     quantile_levels = c(0.025, 0.975),     symmetrize = FALSE   ) %>%   layer_naomit(.pred) wf1 <- wf %>% add_frosting(f)  p <- forecast(wf1)  f2 <- frosting() %>%   layer_predict() %>%   layer_residual_quantiles(     quantile_levels = c(0.3, 0.7),     by_key = \"geo_value\"   ) %>%   layer_naomit(.pred) wf2 <- wf %>% add_frosting(f2)  p2 <- forecast(wf2) #> Warning: Some grouping keys are not in data.frame returned by the `residuals()` method. #> Groupings may not be correct."},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_threshold.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower and upper thresholds for predicted values ‚Äî layer_threshold","title":"Lower and upper thresholds for predicted values ‚Äî layer_threshold","text":"post-processing step used set prediction values smaller lower threshold higher upper threshold equal threshold values.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_threshold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower and upper thresholds for predicted values ‚Äî layer_threshold","text":"","code":"layer_threshold(   frosting,   ...,   lower = 0,   upper = Inf,   id = rand_id(\"threshold\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_threshold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lower and upper thresholds for predicted values ‚Äî layer_threshold","text":"frosting frosting postprocessor ... <tidy-select> One unquoted expressions separated commas. Variable names can used positions data frame, expressions like x:y can used select range variables. Typical usage .pred threshold predictions range (say, nonnegative). lower Lower threshold prediction values. , predictions less lower bound set . Default value 0. upper Upper threshold prediction values. , predictions greater upper bound set . Default value Inf. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_threshold.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lower and upper thresholds for predicted values ‚Äî layer_threshold","text":"updated frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_threshold.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lower and upper thresholds for predicted values ‚Äî layer_threshold","text":"Making case count predictions strictly positive typical example usage. must called column containing quantiles. means earliest can called layer_predict() distributional models, layer_residual_quantiles() point prediction models. Typical best practice use starts_with(\".pred\") variables threshold.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_threshold.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lower and upper thresholds for predicted values ‚Äî layer_threshold","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value < \"2021-03-08\", geo_value %in% c(\"ak\", \"ca\", \"ar\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit() wf <- epi_workflow(r, linear_reg()) %>% fit(jhu)  f <- frosting() %>%   layer_predict() %>%   layer_threshold(starts_with(\".pred\"), lower = 0.180, upper = 0.310) wf <- wf %>% add_frosting(f) p <- forecast(wf) p #> An `epi_df` object, 3 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 3 #>   geo_value time_value .pred #>   <chr>     <date>     <dbl> #> 1 ak        2021-03-07  0.18 #> 2 ar        2021-03-07  0.18 #> 3 ca        2021-03-07  0.31"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_unnest.html","id":null,"dir":"Reference","previous_headings":"","what":"Unnest prediction list-cols ‚Äî layer_unnest","title":"Unnest prediction list-cols ‚Äî layer_unnest","text":"model produces forecasts multiple outcomes, multiple aheads, resulting prediction list forecasts inside column prediction tibble, may desirable. layer \"lengthens\" result, moving outcome separate row, manner tidyr::unnest() . moment, engine smooth_quantile_reg().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_unnest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unnest prediction list-cols ‚Äî layer_unnest","text":"","code":"layer_unnest(frosting, ..., id = rand_id(\"unnest\"))"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_unnest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unnest prediction list-cols ‚Äî layer_unnest","text":"frosting frosting postprocessor ... <tidy-select> One unquoted expressions separated commas. Variable names can used positions data frame, expressions like x:y can used select range variables. id random id string","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_unnest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unnest prediction list-cols ‚Äî layer_unnest","text":"updated frosting postprocessor","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/layer_unnest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unnest prediction list-cols ‚Äî layer_unnest","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  aheads <- 1:7  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = aheads) %>%   step_epi_naomit()  wf <- epi_workflow(   r,   smooth_quantile_reg(     quantile_levels = c(.05, .1, .25, .5, .75, .9, .95),     outcome_locations = aheads   ) ) %>%   fit(jhu)  f <- frosting() %>%   layer_predict() %>%   layer_naomit() %>%   layer_unnest(.pred)  wf1 <- wf %>% add_frosting(f)  p <- forecast(wf1) p #> An `epi_df` object, 21 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 21 √ó 4 #>    geo_value time_value ahead     distn #>    <chr>     <date>     <int> <qtls(7)> #>  1 ak        2021-12-31     1  [0.0399] #>  2 ak        2021-12-31     2  [0.0571] #>  3 ak        2021-12-31     3  [0.0656] #>  4 ak        2021-12-31     4  [0.0821] #>  5 ak        2021-12-31     5  [0.0881] #>  6 ak        2021-12-31     6  [0.0865] #>  7 ak        2021-12-31     7  [0.0549] #>  8 ca        2021-12-31     1    [0.14] #>  9 ca        2021-12-31     2   [0.148] #> 10 ca        2021-12-31     3   [0.155] #> # ‚Ñπ 11 more rows"},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/nested_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn a vector of quantile distributions into a list-col ‚Äî nested_quantiles","text":"","code":"nested_quantiles(x)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/nested_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn a vector of quantile distributions into a list-col ‚Äî nested_quantiles","text":"x distribution containing dist_quantiles","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/nested_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn a vector of quantile distributions into a list-col ‚Äî nested_quantiles","text":"list-col","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/nested_quantiles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Turn a vector of quantile distributions into a list-col ‚Äî nested_quantiles","text":"function deprecated. recommended alternative hardhat::quantile_pred() tibble::as_tibble()","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/nested_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turn a vector of quantile distributions into a list-col ‚Äî nested_quantiles","text":"","code":"pred_quantile <- quantile_pred(matrix(rnorm(20), 5), c(.2, .4, .6, .8)) nested_quantiles(pred_quantile) #> Warning: `nested_quantiles()` was deprecated in epipredict 0.1.11. #> ‚Ñπ Please use `hardhat::quantile_pred()` instead. #> # A tibble: 5 √ó 1 #>   data             #>   <list>           #> 1 <tibble [4 √ó 2]> #> 2 <tibble [4 √ó 2]> #> 3 <tibble [4 √ó 2]> #> 4 <tibble [4 √ó 2]> #> 5 <tibble [4 √ó 2]>  pred_quantile %>%   as_tibble() %>%   tidyr::nest(.by = .row) %>%   dplyr::select(-.row) #> # A tibble: 5 √ó 1 #>   data             #>   <list>           #> 1 <tibble [4 √ó 2]> #> 2 <tibble [4 √ó 2]> #> 3 <tibble [4 √ó 2]> #> 4 <tibble [4 √ó 2]> #> 5 <tibble [4 √ó 2]>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/new_epi_recipe_blueprint.html","id":null,"dir":"Reference","previous_headings":"","what":"Recipe blueprint that accounts for epi_df panel data ‚Äî new_epi_recipe_blueprint","title":"Recipe blueprint that accounts for epi_df panel data ‚Äî new_epi_recipe_blueprint","text":"Used simplicity. See hardhat::new_recipe_blueprint() hardhat::default_recipe_blueprint() details.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/new_epi_recipe_blueprint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recipe blueprint that accounts for epi_df panel data ‚Äî new_epi_recipe_blueprint","text":"","code":"new_epi_recipe_blueprint(   intercept = FALSE,   allow_novel_levels = FALSE,   fresh = TRUE,   composition = \"tibble\",   ptypes = NULL,   recipe = NULL,   ...,   subclass = character() )  epi_recipe_blueprint(   intercept = FALSE,   allow_novel_levels = FALSE,   fresh = TRUE,   composition = \"tibble\" )  default_epi_recipe_blueprint(   intercept = FALSE,   allow_novel_levels = FALSE,   fresh = TRUE,   composition = \"tibble\" )  new_default_epi_recipe_blueprint(   intercept = FALSE,   allow_novel_levels = FALSE,   fresh = TRUE,   composition = \"tibble\",   ptypes = NULL,   recipe = NULL,   extra_role_ptypes = NULL,   ...,   subclass = character() )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/new_epi_recipe_blueprint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recipe blueprint that accounts for epi_df panel data ‚Äî new_epi_recipe_blueprint","text":"intercept logical. intercept included processed data? information used process function mold forge function list. allow_novel_levels logical. novel factor levels allowed prediction time? information used clean function forge function list, passed scream(). fresh already trained operations re-trained prep() called? composition Either \"tibble\", \"matrix\", \"dgCMatrix\" format processed predictors. \"matrix\" \"dgCMatrix\" chosen, predictors must numeric preprocessing method applied; otherwise error thrown. ptypes Either NULL, named list 2 elements, predictors outcomes, 0-row tibbles. ptypes generated automatically mold() time used validate new_data prediction time. recipe Either NULL, unprepped recipe. argument set automatically mold() time. ... Name-value pairs additional elements blueprints subclass blueprint. subclass character vector. subclasses blueprint. extra_role_ptypes named list. names unique non-standard recipe roles (.e. everything except \"predictors\" \"outcomes\"). values prototypes original columns role. used validation forge().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/new_epi_recipe_blueprint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recipe blueprint that accounts for epi_df panel data ‚Äî new_epi_recipe_blueprint","text":"recipe blueprint.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/new_epi_recipe_blueprint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Recipe blueprint that accounts for epi_df panel data ‚Äî new_epi_recipe_blueprint","text":"bake_dependent_roles automatically set epi_df defaults.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/pad_to_end.html","id":null,"dir":"Reference","previous_headings":"","what":"pad every group at the right interval ‚Äî pad_to_end","title":"pad every group at the right interval ‚Äî pad_to_end","text":"Perform last observation carried forward group group basis. uses guess_period find appropriate interval fill-forward . maintains grouping structure recieves. fill \"interior\" NA values occurring data beforehand.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/pad_to_end.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"pad every group at the right interval ‚Äî pad_to_end","text":"","code":"pad_to_end(x, groups, end_date, columns_to_complete = NULL)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/pad_to_end.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"pad every group at the right interval ‚Äî pad_to_end","text":"x epi_df filled forward. groups grouping fill forward columns_to_complete columns apply completion . default every non-key column epi_df","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator ‚Äî %>%","title":"Pipe operator ‚Äî %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator ‚Äî %>%","text":"","code":"lhs %>% rhs"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator ‚Äî %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator ‚Äî %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/pivot_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Pivot a column containing quantile_pred to explicit rows or columns ‚Äî pivot_quantiles","title":"Pivot a column containing quantile_pred to explicit rows or columns ‚Äî pivot_quantiles","text":"functions expand column quantile_preds separate quantiles. Since consists set names (quantiles) values, operate analogously pivot_wider pivot_longer.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/pivot_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pivot a column containing quantile_pred to explicit rows or columns ‚Äî pivot_quantiles","text":"","code":"pivot_quantiles_longer(.data, ...)  pivot_quantiles_wider(.data, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/pivot_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pivot a column containing quantile_pred to explicit rows or columns ‚Äî pivot_quantiles","text":".data data frame, data frame extension tibble epi_df. ... <tidy-select> One unquoted expressions separated commas. Variable names can used positions data frame. Note one variable can selected operation.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/pivot_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pivot a column containing quantile_pred to explicit rows or columns ‚Äî pivot_quantiles","text":"object class .data.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/pivot_quantiles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pivot a column containing quantile_pred to explicit rows or columns ‚Äî pivot_quantiles","text":"piot_quantiles_wider creates new column quantile_level, values corresponding quantile values.  pivoting multiple columns, original column name used prefix. Similarly, pivot_quantiles_longer assigns selected columns quantile_levels one column values another. multiple columns selected, prefixed column name.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/pivot_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pivot a column containing quantile_pred to explicit rows or columns ‚Äî pivot_quantiles","text":"","code":"d1 <- quantile_pred(rbind(1:3, 2:4), 1:3 / 4) d2 <- quantile_pred(rbind(2:4, 3:5), 2:4 / 5) tib <- tibble(g = c(\"a\", \"b\"), d1 = d1, d2 = d2)  pivot_quantiles_longer(tib, \"d1\") #> # A tibble: 6 √ó 4 #>   g            d2 d1_value d1_quantile_level #>   <chr> <qtls(3)>    <int>             <dbl> #> 1 a         [2.5]        1              0.25 #> 2 a         [2.5]        2              0.5  #> 3 a         [2.5]        3              0.75 #> 4 b         [3.5]        2              0.25 #> 5 b         [3.5]        3              0.5  #> 6 b         [3.5]        4              0.75 pivot_quantiles_longer(tib, dplyr::ends_with(\"1\")) #> # A tibble: 6 √ó 4 #>   g            d2 d1_value d1_quantile_level #>   <chr> <qtls(3)>    <int>             <dbl> #> 1 a         [2.5]        1              0.25 #> 2 a         [2.5]        2              0.5  #> 3 a         [2.5]        3              0.75 #> 4 b         [3.5]        2              0.25 #> 5 b         [3.5]        3              0.5  #> 6 b         [3.5]        4              0.75 pivot_quantiles_longer(tib, d2) #> # A tibble: 6 √ó 4 #>   g            d1 d2_value d2_quantile_level #>   <chr> <qtls(3)>    <int>             <dbl> #> 1 a           [2]        2               0.4 #> 2 a           [2]        3               0.6 #> 3 a           [2]        4               0.8 #> 4 b           [3]        3               0.4 #> 5 b           [3]        4               0.6 #> 6 b           [3]        5               0.8  pivot_quantiles_wider(tib, \"d1\") #> # A tibble: 2 √ó 5 #>   g            d2 `0.25` `0.5` `0.75` #>   <chr> <qtls(3)>  <int> <int>  <int> #> 1 a         [2.5]      1     2      3 #> 2 b         [3.5]      2     3      4 pivot_quantiles_wider(tib, dplyr::ends_with(\"2\")) #> # A tibble: 2 √ó 5 #>   g            d1 `0.4` `0.6` `0.8` #>   <chr> <qtls(3)> <int> <int> <int> #> 1 a           [2]     2     3     4 #> 2 b           [3]     3     4     5 pivot_quantiles_wider(tib, d2) #> # A tibble: 2 √ó 5 #>   g            d1 `0.4` `0.6` `0.8` #>   <chr> <qtls(3)> <int> <int> <int> #> 1 a           [2]     2     3     4 #> 2 b           [3]     3     4     5"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/predict-epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict from an epi_workflow ‚Äî predict-epi_workflow","title":"Predict from an epi_workflow ‚Äî predict-epi_workflow","text":"predict() method fit epi_workflow object. 3 steps implements : Preprocess new_data using preprocessing method specified workflow created fit. accomplished using hardhat::forge(), apply formula preprocessing call recipes::bake() recipe supplied. Preprocessing new_data using preprocessing method specified epi_workflow created fit. accomplished using hardhat::bake() recipe supplied (passing hardhat::forge(), used non-recipe preprocessors). Note slightly different bake operation one occuring fit. step skip = TRUE applied prediction; example step_epi_naomit(), all_outcomes() NA omitted, since drop exact time_values trying predict. Calling parsnip::predict.model_fit() using underlying fit parsnip model. slather() frosting included epi_workflow.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/predict-epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict from an epi_workflow ‚Äî predict-epi_workflow","text":"","code":"# S3 method for class 'epi_workflow' predict(object, new_data, type = NULL, opts = list(), ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/predict-epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict from an epi_workflow ‚Äî predict-epi_workflow","text":"object epi_workflow fit workflows::fit.workflow() new_data data frame containing new predictors preprocess predict type single character value NULL. Possible values \"numeric\", \"class\", \"prob\", \"conf_int\", \"pred_int\", \"quantile\", \"time\", \"hazard\", \"survival\", \"raw\". NULL, predict() choose appropriate value based model's mode. opts list optional arguments underlying predict function used type = \"raw\". list include options model object new data predicted. ... Additional parsnip-related options, depending value type. Arguments underlying model's prediction function passed (use opts argument instead). Possible arguments : interval: type equal \"survival\" \"quantile\", interval estimates added, available? Options \"none\" \"confidence\". level: type equal \"conf_int\", \"pred_int\", \"survival\", parameter tail area intervals (e.g. confidence level confidence intervals). Default value 0.95. std_error: type equal \"conf_int\" \"pred_int\", add standard error fit prediction (scale linear predictors). Default value FALSE. quantile: type equal quantile, quantiles distribution. Default (1:9)/10. eval_time: type equal \"survival\" \"hazard\", time points survival probability hazard estimated.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/predict-epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict from an epi_workflow ‚Äî predict-epi_workflow","text":"data frame model predictions, many rows new_data . new_data epiprocess::epi_df data frame time_value geo_value columns, result well.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/predict-epi_workflow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict from an epi_workflow ‚Äî predict-epi_workflow","text":"","code":"jhu <- covid_case_death_rates  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_epi_naomit()  wf <- epi_workflow(r, parsnip::linear_reg()) %>% fit(jhu) latest <- jhu %>% dplyr::filter(time_value >= max(time_value) - 14)  preds <- predict(wf, latest) preds #> An `epi_df` object, 56 x 3 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 56 √ó 3 #>    geo_value time_value   .pred #>    <chr>     <date>       <dbl> #>  1 ak        2021-12-31 0.362   #>  2 al        2021-12-31 0.255   #>  3 ar        2021-12-31 0.431   #>  4 as        2021-12-31 0.00105 #>  5 az        2021-12-31 0.647   #>  6 ca        2021-12-31 0.276   #>  7 co        2021-12-31 0.718   #>  8 ct        2021-12-31 0.614   #>  9 dc        2021-12-31 1.00    #> 10 de        2021-12-31 0.709   #> # ‚Ñπ 46 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/quantile.quantile_pred.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantiles from a distribution ‚Äî quantile.quantile_pred","title":"Quantiles from a distribution ‚Äî quantile.quantile_pred","text":"Given hardhat::quantile_pred object, users may wish compute additional quantile_levels part object. function attempts estimate quantities assumptions. Interior probabilities, contained within existing probabilities interpolated manner controled middle argument. outside existing probabilities extrapolated assumption tails distribution decays exponentially. Optionally, one may constrain quantiles within support (say, [0, Inf)).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/quantile.quantile_pred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantiles from a distribution ‚Äî quantile.quantile_pred","text":"","code":"# S3 method for class 'quantile_pred' quantile(   x,   probs = seq(0, 1, 0.25),   na.rm = FALSE,   lower = -Inf,   upper = Inf,   middle = c(\"cubic\", \"linear\"),   ... )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/quantile.quantile_pred.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantiles from a distribution ‚Äî quantile.quantile_pred","text":"x numeric vector whose sample quantiles wanted,     object class method defined (see also     ‚Äòdetails‚Äô). NA NaN values     allowed numeric vectors unless na.rm TRUE. probs numeric vector probabilities values     \\([0,1]\\).  (Values 2e-14 outside     range accepted moved nearby endpoint.) na.rm logical; true, NA NaN's     removed x quantiles computed. lower Scalar. Optional lower bound. upper Scalar. Optional upper bound. middle Controls extrapolation \"interior\" probabilities performed. \"cubic\" attempts use stats::splinefun() \"linear\" uses stats::approx(). \"linear\" method used fallback \"cubic\" fail reason. ... unused","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/quantile.quantile_pred.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantiles from a distribution ‚Äî quantile.quantile_pred","text":"matrix one row entry x one column value probs","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/quantile.quantile_pred.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantiles from a distribution ‚Äî quantile.quantile_pred","text":"","code":"qp <- quantile_pred(matrix(1:8, nrow = 2, byrow = TRUE), 1:4 / 5) quantile(qp) #>      [,1] [,2] [,3] [,4] [,5] #> [1,] -Inf 1.25  2.5 3.75  Inf #> [2,] -Inf 5.25  6.5 7.75  Inf quantile(qp, lower = 0) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0 1.25  2.5 3.75  Inf #> [2,]    0 5.25  6.5 7.75  Inf quantile(qp, probs = 0.5) #>      [,1] #> [1,]  2.5 #> [2,]  6.5 quantile(qp, probs = 1:9 / 10) #>           [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]     [,9] #> [1,] 0.2477407    1  1.5    2  2.5    3  3.5    4 4.752259 #> [2,] 4.2477407    5  5.5    6  6.5    7  7.5    8 8.752259"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/quantile_reg.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile regression ‚Äî quantile_reg","title":"Quantile regression ‚Äî quantile_reg","text":"quantile_reg() generates quantile regression model specification tidymodels framework. Currently, supported engines \"rq\", uses quantreg::rq(). Quantile regression also possible combining parsnip::rand_forest() grf engine. See grf_quantiles.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/quantile_reg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile regression ‚Äî quantile_reg","text":"","code":"quantile_reg(   mode = \"regression\",   engine = \"rq\",   quantile_levels = c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95),   method = \"br\" )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/quantile_reg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile regression ‚Äî quantile_reg","text":"mode single character string type model. possible value model \"regression\". engine Character string naming fitting function. Currently, \"rq\" \"grf\" supported. quantile_levels scalar vector values (0, 1) determine quantiles estimate (default set 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95). method fitting method used quantreg::rq(). See documentation list options.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/quantile_reg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile regression ‚Äî quantile_reg","text":"","code":"library(quantreg) #> Loading required package: SparseM tib <- data.frame(y = rnorm(100), x1 = rnorm(100), x2 = rnorm(100)) rq_spec <- quantile_reg(quantile_levels = c(.2, .8)) %>% set_engine(\"rq\") ff <- rq_spec %>% fit(y ~ ., data = tib) predict(ff, new_data = tib) #> # A tibble: 100 √ó 1 #>        .pred #>    <qtls(2)> #>  1  [-0.439] #>  2  [-0.448] #>  3  [-0.359] #>  4 [-0.0541] #>  5  [-0.164] #>  6  [-0.115] #>  7  [-0.239] #>  8 [-0.0324] #>  9  [0.0271] #> 10  [-0.344] #> # ‚Ñπ 90 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages ‚Äî reexports","title":"Objects exported from other packages ‚Äî reexports","text":"objects imported packages. Follow links see documentation. dplyr filter, mutate, rename, select epiprocess as_epi_df, key_colnames generics fit, fit, forecast, forecast, tidy, tidy ggplot2 autoplot hardhat extract_quantile_levels, extract_quantile_levels, quantile_pred, quantile_pred recipes bake, bake, prep, prep, rand_id, rand_id tibble as_tibble, as_tibble, tibble, tibble tidyr pivot_longer, pivot_wider, unnest","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/roll_modular_multivec.html","id":null,"dir":"Reference","previous_headings":"","what":"group col by .idx values and sum windows around each .idx value ‚Äî roll_modular_multivec","title":"group col by .idx values and sum windows around each .idx value ‚Äî roll_modular_multivec","text":"group col .idx values sum windows around .idx value","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/roll_modular_multivec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"group col by .idx values and sum windows around each .idx value ‚Äî roll_modular_multivec","text":"","code":"roll_modular_multivec(col, idx_in, weights, aggr, window_size, modulus)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/roll_modular_multivec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"group col by .idx values and sum windows around each .idx value ‚Äî roll_modular_multivec","text":"col list values indexed idx_in idx_in relevant periodic part time value, e.g. week number, limited relevant range weights much weigh particular datapoint (also indexed idx_in) aggr aggregation function, probably Quantile, mean, median window_size number .idx entries include aggregation modulus number days/weeks/months year, including leap days/weeks","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/seq_forward.html","id":null,"dir":"Reference","previous_headings":"","what":"seq, but returns null if from is larger ‚Äî seq_forward","title":"seq, but returns null if from is larger ‚Äî seq_forward","text":"seq, returns null larger","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/seq_forward.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"seq, but returns null if from is larger ‚Äî seq_forward","text":"","code":"seq_forward(from, to, by)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/slather.html","id":null,"dir":"Reference","previous_headings":"","what":"Spread a layer of frosting on a fitted workflow ‚Äî slather","title":"Spread a layer of frosting on a fitted workflow ‚Äî slather","text":"Slathering frosting means implement post-processing layer. post-processing equivalent bake recipe. Given layer, applies actual transformation layer. creating new post-processing layer, must implement S3 method function. Generally, need call function directly, used indirectly predict.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/slather.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spread a layer of frosting on a fitted workflow ‚Äî slather","text":"","code":"slather(object, components, workflow, new_data, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/slather.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spread a layer of frosting on a fitted workflow ‚Äî slather","text":"object workflow frosting post-processing steps components list components containing model information. updated returned layer. mold - output calling hardhat::mold() workflow. contains information preprocessing, including recipe. forged - output calling hardhat::forge() workflow. predictors outcomes new_data. three components predictors, outcomes (new_data), extras (usually rest data, including keys). keys - put keys (time_value, geo_value, others) ease. workflow object class workflow new_data data frame containing new predictors preprocess predict ... additional arguments used methods. Currently unused.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/slather.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spread a layer of frosting on a fitted workflow ‚Äî slather","text":"components list, format , applying updates.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/smooth_quantile_reg.html","id":null,"dir":"Reference","previous_headings":"","what":"Smooth quantile regression ‚Äî smooth_quantile_reg","title":"Smooth quantile regression ‚Äî smooth_quantile_reg","text":"smooth_quantile_reg() generates quantile regression model specification tidymodels framework. Currently, supported engine smoothqr::smooth_qr().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/smooth_quantile_reg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smooth quantile regression ‚Äî smooth_quantile_reg","text":"","code":"smooth_quantile_reg(   mode = \"regression\",   engine = \"smoothqr\",   outcome_locations = NULL,   quantile_levels = c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95),   degree = 3L )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/smooth_quantile_reg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smooth quantile regression ‚Äî smooth_quantile_reg","text":"mode single character string type model. possible value model \"regression\". engine Character string naming fitting function. Currently, \"rq\" \"grf\" supported. outcome_locations Defaults vector 1:ncol(y) responses observed different spacing (appear different order), information used . argument mapped ahead argument smoothqr::smooth_qr(). quantile_levels scalar vector values (0, 1) determine quantiles estimate (default set 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95). degree number polynomials used response smoothing. Must number responses.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/smooth_quantile_reg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Smooth quantile regression ‚Äî smooth_quantile_reg","text":"","code":"library(smoothqr) tib <- data.frame(   y1 = rnorm(100), y2 = rnorm(100), y3 = rnorm(100),   y4 = rnorm(100), y5 = rnorm(100), y6 = rnorm(100),   x1 = rnorm(100), x2 = rnorm(100) ) qr_spec <- smooth_quantile_reg(quantile_levels = c(.2, .5, .8), outcome_locations = 1:6) ff <- qr_spec %>% fit(cbind(y1, y2, y3, y4, y5, y6) ~ ., data = tib) p <- predict(ff, new_data = tib)  x <- -99:99 / 100 * 2 * pi y <- sin(x) + rnorm(length(x), sd = .1) fd <- x[length(x) - 20] XY <- smoothqr::lagmat(y[1:(length(y) - 20)], c(-20:20)) XY <- as_tibble(XY) qr_spec <- smooth_quantile_reg(quantile_levels = c(.2, .5, .8), outcome_locations = 20:1) tt <- qr_spec %>% fit_xy(x = XY[, 21:41], y = XY[, 1:20])  pl <- predict(   object = tt,   new_data = XY[max(which(complete.cases(XY[, 21:41]))), 21:41] ) pl <- pl %>%   unnest(.pred) %>%   pivot_quantiles_wider(distn) %>%   mutate(     x = x[length(x) - 20] + ahead / 100 * 2 * pi,     ahead = NULL   ) plot(x, y, pch = 16, xlim = c(pi, 2 * pi), col = \"lightgrey\") curve(sin(x), add = TRUE) abline(v = fd, lty = 2) lines(pl$x, pl$`0.2`, col = \"blue\") lines(pl$x, pl$`0.8`, col = \"blue\") lines(pl$x, pl$`0.5`, col = \"red\")   library(ggplot2) ggplot(data.frame(x = x, y = y), aes(x)) +   geom_ribbon(data = pl, aes(ymin = `0.2`, ymax = `0.8`), fill = \"cornflowerblue\") +   geom_point(aes(y = y), colour = \"grey\") + # observed data   geom_function(fun = sin, colour = \"black\") + # truth   geom_vline(xintercept = fd, linetype = \"dashed\") + # end of training data   geom_line(data = pl, aes(y = `0.5`), colour = \"orange\") + # median prediction   theme_bw() +   coord_cartesian(xlim = c(0, NA)) +   ylab(\"y\")"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/snap.html","id":null,"dir":"Reference","previous_headings":"","what":"restrict various objects to the interval [lower, upper] ‚Äî snap","title":"restrict various objects to the interval [lower, upper] ‚Äî snap","text":"restrict various objects interval [lower, upper]","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/snap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"restrict various objects to the interval [lower, upper] ‚Äî snap","text":"","code":"snap(x, lower, upper, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/snap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"restrict various objects to the interval [lower, upper] ‚Äî snap","text":"x object restrict lower numeric, lower bound upper numeric, upper bound ... unused","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_adjust_latency.html","id":null,"dir":"Reference","previous_headings":"","what":"Adapt the model to latent data ‚Äî step_adjust_latency","title":"Adapt the model to latent data ‚Äî step_adjust_latency","text":"standard case, arx models assume last observation also day forecast made. data latency, may wish adjust predictors (lags) /outcome (ahead) compensate. useful realtime pseudo-prospective forecasting data delay event occurring event reported.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_adjust_latency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adapt the model to latent data ‚Äî step_adjust_latency","text":"","code":"step_adjust_latency(   recipe,   ...,   method = c(\"extend_ahead\", \"locf\", \"extend_lags\"),   epi_keys_checked = NULL,   keys_to_ignore = c(),   fixed_latency = NULL,   fixed_forecast_date = NULL,   check_latency_length = TRUE,   id = rand_id(\"adjust_latency\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_adjust_latency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adapt the model to latent data ‚Äî step_adjust_latency","text":"recipe recipe object. step added sequence operations recipe. ... One selector functions choose variables step. See selections() details. method character. Determines method forecast handles latency. options : \"extend_ahead\": Lengthen ahead forecasting last observation results forecast ahead forecast_date date. E.g. 3 days latency last observation forecast_date date 4 day ahead forecast, ahead used practice actually 7. \"locf\": carries forward last observed value(s) forecast date. \"extend_lags\": per epi_key predictor, adjusts lag shortest lag predict time last observation. E.g. lags c(0,7,14) data 3 days latent, actual lags used become c(3,10,17). epi_keys_checked character vector. list keys group finding max_time_value (last day data), defaulting geo_value. Different locations may different latencies; produce forecast every location, need guarantee data every location using largest latency across every location; means taking max_time_value minimum max_time_values set key values (earliest date).  NULL empty character vector, take maximum across values, irrespective keys. Note separate concern different latencies across different data columns, handled choice method. keys_to_ignore list character vectors. Set avoid using specific key values epi_keys_checked set latency. example, say two locations pr gu useful training data, stopped providing --date information, longer part test set. Setting keys_to_ignore = list(geo_value = c(\"pr\", \"gu\")) exclude latency calculation. fixed_latency either positive integer, labeled positive integer vector. set time fixed_forecast_date. non-NULL, amount offset ahead lag . single integer, used columns; labeled vector, labels must correspond base column names (lags/aheads).  NULL, latency distance epi_df's max_time_value forecast_date. fixed_forecast_date either date kind used epi_df, NULL. Exclusive fixed_latency. date, gives date forecast actually occurring. NULL, forecast_date determined either via fixed_latency, set epi_df's as_of value fixed_latency also NULL. check_latency_length bool, determines whether warn latency unusually high. Turn know forecast going far future. id character string unique step identify .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_adjust_latency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adapt the model to latent data ‚Äî step_adjust_latency","text":"updated version recipe new step added sequence existing operations.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_adjust_latency.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adapt the model to latent data ‚Äî step_adjust_latency","text":"step allows user create models recent data, automatically accounting latency patterns. Instead using last observation date, step_adjust_latency uses as_of date epi_df forecast_date, adjusts model data available. demonstrate subtleties, consider toy dataset:   looking predict value 15th, forecasting 14th (as_of date ), two issues need address: \"ca\" latent 2 days, whereas \"ma\" latent 1 want use b exogenous variable, \"ma\" latent 3 days instead just 1. Regardless method, epi_keys_checked=\"geo_value\" guarantees tha difference \"ma\" \"ca\" accounted making latency adjustment least 2. comparison, various methods :","code":"toy_df <- tribble(  ~geo_value, ~time_value, ~a, ~b,  \"ma\", as.Date(\"2015-01-11\"), 20, 6,  \"ma\", as.Date(\"2015-01-12\"), 23, NA,  \"ma\", as.Date(\"2015-01-13\"), 25, NA,  \"ca\", as.Date(\"2015-01-11\"), 100, 5,  \"ca\", as.Date(\"2015-01-12\"), 103, 10, ) %>%    as_epi_df(as_of = as.Date(\"2015-01-14\"))"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_adjust_latency.html","id":"locf","dir":"Reference","previous_headings":"","what":"locf","title":"Adapt the model to latent data ‚Äî step_adjust_latency","text":"Short \"last observation carried forward\", locf assumes every day last observation forecast day exactly . straightforward assumption, wrecks features depend changes value time, growth rate, even adjacent lags. robust version falls heading nowcasting, eventual aim package. toy dataset, matter day trying predict, since just fills forward forecast_date:","code":"toy_recipe <- epi_recipe(toy_df) %>%   step_adjust_latency(has_role(\"raw\"), method=\"locf\")  toy_recipe %>%   prep(toy_df) %>%   bake(toy_df) %>%   arrange(geo_value, time_value) #> An `epi_df` object, 8 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2015-01-14 #> #> # A tibble: 8 x 4 #>   geo_value time_value     a     b #>   <chr>     <date>     <dbl> <dbl> #> 1 ca        2015-01-11   100     5 #> 2 ca        2015-01-12   103    10 #> 3 ca        2015-01-13   103    10 #> 4 ca        2015-01-14   103    10 #> 5 ma        2015-01-11    20     6 #> 6 ma        2015-01-12    23     6 #> 7 ma        2015-01-13    25     6 #> 8 ma        2015-01-14    25     6"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_adjust_latency.html","id":"extend-lags","dir":"Reference","previous_headings":"","what":"extend_lags","title":"Adapt the model to latent data ‚Äî step_adjust_latency","text":"extend_lags increases lags guaranteed data. advantage applicable per-column basis; cases deaths reported different latencies, lags adjusted separately. toy example:   maximum latency column 2 days, lag increased 3, max latency column b 3, lag increased 4; changes reflected column names. Meanwhile ahead uneffected. side-note, lag/ahead can somewhat ambiguous direction. , values brought forward time, given row, column lag_3_a represents value 3 days .","code":"toy_recipe <- epi_recipe(toy_df) %>%   step_adjust_latency(has_role(\"raw\"), method = \"extend_lags\") %>%   step_epi_lag(a, lag=1) %>%   step_epi_lag(b, lag=1) %>%   step_epi_ahead(a, ahead=1)  toy_recipe %>%   prep(toy_df) %>%   bake(toy_df) %>%   arrange(geo_value, time_value) #> An `epi_df` object, 21 x 7 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2015-01-14 #> #> # A tibble: 21 x 7 #>    geo_value time_value     a     b lag_3_a lag_4_b ahead_1_a #>    <chr>     <date>     <dbl> <dbl>   <dbl>   <dbl>     <dbl> #>  1 ca        2015-01-10    NA    NA      NA      NA       100 #>  2 ca        2015-01-11   100     5      NA      NA       103 #>  3 ca        2015-01-12   103    10      NA      NA        NA #>  4 ca        2015-01-13    NA    NA      NA      NA        NA #>  5 ca        2015-01-14    NA    NA     100      NA        NA #>  6 ca        2015-01-15    NA    NA     103       5        NA #>  7 ca        2015-01-16    NA    NA      NA      10        NA #>  8 ca        2015-01-17    NA    NA      NA      NA        NA #>  9 ca        2015-01-18    NA    NA      NA      NA        NA #> 10 ca        2015-01-19    NA    NA      NA      NA        NA #> # i 11 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_adjust_latency.html","id":"extend-ahead","dir":"Reference","previous_headings":"","what":"extend_ahead","title":"Adapt the model to latent data ‚Äî step_adjust_latency","text":"extend_ahead increases ahead, turning 3 day ahead forecast 7 day one; advantage simplicity reflective actual modelling task, potentially leaves information unused different data sources different latencies; must use latency latent data insure data available. toy example:   Even though 1 day ahead forecast, worst latency 3 days column b's \"ma\" data, outcome column ahead_4_a (4 days ahead). want ignore latency column b, need explicitly set columns consider adjusting like : step_adjust_latency(, method=\"extend_ahead\").","code":"toy_recipe <- epi_recipe(toy_df) %>%   step_adjust_latency(has_role(\"raw\"), method=\"extend_ahead\") %>%   step_epi_lag(a, lag=0) %>%   step_epi_ahead(a, ahead=1)  toy_recipe %>%   prep(toy_df) %>%   bake(toy_df) %>%   arrange(geo_value, time_value) #> An `epi_df` object, 10 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2015-01-14 #> #> # A tibble: 10 x 6 #>    geo_value time_value     a     b lag_0_a ahead_3_a #>    <chr>     <date>     <dbl> <dbl>   <dbl>     <dbl> #>  1 ca        2015-01-08    NA    NA      NA       100 #>  2 ca        2015-01-09    NA    NA      NA       103 #>  3 ca        2015-01-11   100     5     100        NA #>  4 ca        2015-01-12   103    10     103        NA #>  5 ma        2015-01-08    NA    NA      NA        20 #>  6 ma        2015-01-09    NA    NA      NA        23 #>  7 ma        2015-01-10    NA    NA      NA        25 #>  8 ma        2015-01-11    20     6      20        NA #>  9 ma        2015-01-12    23    NA      23        NA #> 10 ma        2015-01-13    25    NA      25        NA"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_adjust_latency.html","id":"programmatic-details","dir":"Reference","previous_headings":"","what":"Programmatic details","title":"Adapt the model to latent data ‚Äî step_adjust_latency","text":"step_adjust_latency uses metadata, time_type as_of, epi_df used initial prep step, rather baking prediction. means reusing forecaster new data advised, though typically advised general. latency adjustment applies columns created step, step go step_epi_ahead step_epi_lag. work:   :   create columns apply lags (step_growth_rate()), created step_adjust_latency, subseqent latency can addressed.","code":"toy_recipe <- epi_recipe(toy_df) %>%    # non-lag steps    step_adjust_latency(a, method = \"extend_lags\") %>%    step_epi_lag(a, lag=0) # other steps toy_recipe <- epi_recipe(toy_df) %>%    step_epi_lag(a, lag=0) %>%    step_adjust_latency(a, method = \"extend_lags\") #> Warning: If `method` is \"extend_lags\" or \"locf\", then the previous `step_epi_lag`s won't #> work with modified data."},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_adjust_latency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adapt the model to latent data ‚Äî step_adjust_latency","text":"","code":"rates <- covid_case_death_rates %>%   dplyr::filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\")) # setting the `as_of` to something realistic attributes(rates)$metadata$as_of <- max(rates$time_value) + 3  r <- epi_recipe(rates) %>%   step_adjust_latency(recipes::has_role(\"raw\"), method = \"extend_ahead\") %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) r #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs  #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations  #> 1. Adj. extend_ahead: recipes::has_role(\"raw\") latency TBD at train time #> 2. Leading: death_rate by 7 #> 3. Lagging: death_rate by 0, 7, 14  rates_fit <- epi_workflow() %>%   add_epi_recipe(r) %>%   add_model(linear_reg()) %>%   fit(data = rates) rates_fit #>  #> ‚ïê‚ïê Epi Workflow [trained] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê #> Preprocessor: Recipe #> Model: linear_reg() #> Postprocessor: None #>  #> ‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> 3 Recipe steps. #> 1. step_adjust_latency() #> 2. step_epi_ahead() #> 3. step_epi_lag() #>  #> ‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> Call: #> stats::lm(formula = ..y ~ ., data = data) #>  #> Coefficients: #>       (Intercept)   lag_0_death_rate   lag_7_death_rate  lag_14_death_rate   #>            0.3806            -0.2208            -0.0403            -0.0394   #>  #>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_adjust_latency_checks.html","id":null,"dir":"Reference","previous_headings":"","what":"checks: the recipe type, whether a previous step is the relevant epi_shift, that either fixed_latency or fixed_forecast_date is non-null, and that fixed_latency only references columns that exist at the time of the step inclusion ‚Äî step_adjust_latency_checks","title":"checks: the recipe type, whether a previous step is the relevant epi_shift, that either fixed_latency or fixed_forecast_date is non-null, and that fixed_latency only references columns that exist at the time of the step inclusion ‚Äî step_adjust_latency_checks","text":"checks: recipe type, whether previous step relevant epi_shift, either fixed_latency fixed_forecast_date non-null, fixed_latency references columns exist time step inclusion","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_adjust_latency_checks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"checks: the recipe type, whether a previous step is the relevant epi_shift, that either fixed_latency or fixed_forecast_date is non-null, and that fixed_latency only references columns that exist at the time of the step inclusion ‚Äî step_adjust_latency_checks","text":"","code":"step_adjust_latency_checks(   id,   method,   recipe,   fixed_latency,   fixed_forecast_date,   call = caller_env() )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_climate.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a climatological variable based on the history ‚Äî step_climate","title":"Calculate a climatological variable based on the history ‚Äî step_climate","text":"step_climate() creates specification recipe step generate one new columns derived data. step examines available seasons training data calculates measure center \"typical\" season. Think like weather: predict temperature January Pittsburgh, PA, might look previous January's record, average temperatures, include model. important align forecast horizon climate. step work best added step_epi_ahead(), strictly required. See details information.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_climate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a climatological variable based on the history ‚Äî step_climate","text":"","code":"step_climate(   recipe,   ...,   forecast_ahead = \"detect\",   role = \"predictor\",   time_type = c(\"detect\", \"epiweek\", \"week\", \"month\", \"day\"),   center_method = c(\"median\", \"mean\"),   window_size = 3L,   epi_keys = NULL,   prefix = \"climate_\",   skip = FALSE,   id = rand_id(\"climate\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_climate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a climatological variable based on the history ‚Äî step_climate","text":"recipe recipe object. step added sequence operations recipe. ... One selector functions choose variables step. See recipes::selections() details. forecast_ahead forecast horizon. default, step try detect whether forecast horizon already specified step_epi_ahead(). Alternatively, one can specify explicit horizon scalar integer. Auto-detection possible time type epi_df used create epi_recipe aggregation time_type specified step (say, daily weekly). , example, daily data used monthly time aggregation, auto-detection possible (may fact lead strange behaviour even forecast_ahead specified integer). See details . role role assigned variables created step? \"predictor\" likely choice. time_type duration time aggregation performed. center_method measure center calculated time window. window_size Scalar integer. many time units side included. example, window_size = 3 time_type = \"day\", day data, center calculated using 3 days three days . , case, operates like weekly rolling average, centered day. epi_keys Character vector NULL. columns mentioned grouped performing center calculation. example, given state-level data, national climate calculated NULL, passing epi_keys = \"geo_value\" calculate climate separately state. prefix character string prefixed new column. skip logical. step skipped recipe baked bake()? operations baked prep() run, operations may able conducted new data (e.g. processing outcome variable(s)). Care taken using skip = TRUE may affect computations subsequent operations. id unique identifier step","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_climate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a climatological variable based on the history ‚Äî step_climate","text":"updated version recipe new step added sequence existing operations.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_climate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate a climatological variable based on the history ‚Äî step_climate","text":"Construction climate predictor can helpful strongly seasonal data. utility greatest estimated \"climate\" aligned forecast horizon. example, today December 1, want make prediction December 15, want know climate week December 15 use model. also want align rest training data climate 2 weeks dates. accomplish , daily data, use time_type = \"week\" forecast_ahead = 2. climate predictor created taking averages week (window weeks , determined window_size), aligning appropriate dates training data time_value \"see\" typical climate 2 weeks future. Alternatively, scenario, use time_type = \"day\" forecast_ahead = 14. climate predictor created taking averages small window around day, aligning appropriate dates training data time_value \"see\" climate 14 days future. differences options type averaging performed historical data. first case, days week get value climate predictor (looking weekly windows), second case, every day data average climate day happens 14 days future. Autodetecting forecast horizon can guaranteed work correctly time types : example using daily data training daily climate calculations. However, using weekly data, predicting 4 weeks ahead, setting time_type = \"month\" perfectly reasonable. just climate calculated months (January, February, March, etc.) properly align producing forecast 5th week year challenging. scenarios like , may best approximately match times forecast_ahead = 1, example.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_climate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a climatological variable based on the history ‚Äî step_climate","text":"","code":"# automatically detects the horizon r <- epi_recipe(covid_case_death_rates) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_climate(death_rate, time_type = \"day\") r #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs  #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations  #> 1. Leading: death_rate by 7 #> 2. Calculating climate_predictor for: death_rate by day using the median  r %>%   prep(covid_case_death_rates) %>%   bake(new_data = NULL) #> An `epi_df` object, 20,888 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 20,888 √ó 6 #>    geo_value time_value case_rate death_rate ahead_7_death_rate #>  * <chr>     <date>         <dbl>      <dbl>              <dbl> #>  1 ak        2020-12-24        NA         NA              0.158 #>  2 al        2020-12-24        NA         NA              0.438 #>  3 ar        2020-12-24        NA         NA              1.27  #>  4 as        2020-12-24        NA         NA              0     #>  5 az        2020-12-24        NA         NA              1.10  #>  6 ca        2020-12-24        NA         NA              0.755 #>  7 co        2020-12-24        NA         NA              0.376 #>  8 ct        2020-12-24        NA         NA              0.819 #>  9 dc        2020-12-24        NA         NA              0.601 #> 10 de        2020-12-24        NA         NA              0.912 #> # ‚Ñπ 20,878 more rows #> # ‚Ñπ 1 more variable: climate_death_rate <dbl>  # same idea, but using weekly climate r <- epi_recipe(covid_case_death_rates) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_climate(death_rate,     forecast_ahead = 1, time_type = \"epiweek\",     window_size = 1L   ) r #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs  #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations  #> 1. Leading: death_rate by 7 #> 2. Calculating climate_predictor for: death_rate by epiweek using the median  r %>%   prep(covid_case_death_rates) %>%   bake(new_data = NULL) #> An `epi_df` object, 20,888 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 20,888 √ó 6 #>    geo_value time_value case_rate death_rate ahead_7_death_rate #>  * <chr>     <date>         <dbl>      <dbl>              <dbl> #>  1 ak        2020-12-24        NA         NA              0.158 #>  2 al        2020-12-24        NA         NA              0.438 #>  3 ar        2020-12-24        NA         NA              1.27  #>  4 as        2020-12-24        NA         NA              0     #>  5 az        2020-12-24        NA         NA              1.10  #>  6 ca        2020-12-24        NA         NA              0.755 #>  7 co        2020-12-24        NA         NA              0.376 #>  8 ct        2020-12-24        NA         NA              0.819 #>  9 dc        2020-12-24        NA         NA              0.601 #> 10 de        2020-12-24        NA         NA              0.912 #> # ‚Ñπ 20,878 more rows #> # ‚Ñπ 1 more variable: climate_death_rate <dbl>  # switching the order is possible if you specify `forecast_ahead` r <- epi_recipe(covid_case_death_rates) %>%   step_climate(death_rate, forecast_ahead = 7, time_type = \"day\") %>%   step_epi_ahead(death_rate, ahead = 7) r #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs  #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations  #> 1. Calculating climate_predictor for: death_rate by day using the median #> 2. Leading: death_rate by 7  r %>%   prep(covid_case_death_rates) %>%   bake(new_data = NULL) #> An `epi_df` object, 20,888 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 20,888 √ó 6 #>    geo_value time_value case_rate death_rate climate_death_rate #>  * <chr>     <date>         <dbl>      <dbl>              <dbl> #>  1 ak        2020-12-24        NA         NA                 NA #>  2 al        2020-12-24        NA         NA                 NA #>  3 ar        2020-12-24        NA         NA                 NA #>  4 as        2020-12-24        NA         NA                 NA #>  5 az        2020-12-24        NA         NA                 NA #>  6 ca        2020-12-24        NA         NA                 NA #>  7 co        2020-12-24        NA         NA                 NA #>  8 ct        2020-12-24        NA         NA                 NA #>  9 dc        2020-12-24        NA         NA                 NA #> 10 de        2020-12-24        NA         NA                 NA #> # ‚Ñπ 20,878 more rows #> # ‚Ñπ 1 more variable: ahead_7_death_rate <dbl>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_naomit.html","id":null,"dir":"Reference","previous_headings":"","what":"Unified NA omission wrapper function for recipes ‚Äî step_epi_naomit","title":"Unified NA omission wrapper function for recipes ‚Äî step_epi_naomit","text":"Unified NA omission wrapper function recipes","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_naomit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unified NA omission wrapper function for recipes ‚Äî step_epi_naomit","text":"","code":"step_epi_naomit(recipe)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_naomit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unified NA omission wrapper function for recipes ‚Äî step_epi_naomit","text":"recipe Recipe used omission steps","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_naomit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unified NA omission wrapper function for recipes ‚Äî step_epi_naomit","text":"Omits NA's predictors outcomes training time fit model. Also omits associated predictors outcomes prediction time due lack response avoidance data loss. Given recipe, step literally equivalent ","code":"recipe %>%    recipes::step_naomit(all_predictors(), skip = FALSE) %>%    recipes::step_naomit(all_outcomes(), skip = TRUE)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_naomit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unified NA omission wrapper function for recipes ‚Äî step_epi_naomit","text":"","code":"covid_case_death_rates %>%   epi_recipe() %>%   step_epi_naomit() #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs  #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations  #> 1. ‚Ä¢ Removing rows with NA values in: all_predictors() #> 2. ‚Ä¢ Removing rows with NA values in: all_outcomes()"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_shift.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a shifted predictor ‚Äî step_epi_lag","title":"Create a shifted predictor ‚Äî step_epi_lag","text":"step_epi_lag step_epi_ahead create specification recipe step add new columns shifted data. step_epi_lag create lagged predictor column, step_epi_ahead create leading outcome column. Shifted data default include NA values shift induced.  can properly removed step_epi_naomit(), may specify alternative value default argument.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a shifted predictor ‚Äî step_epi_lag","text":"","code":"step_epi_lag(   recipe,   ...,   lag,   role = \"predictor\",   prefix = \"lag_\",   default = NA,   skip = FALSE,   id = rand_id(\"epi_lag\") )  step_epi_ahead(   recipe,   ...,   ahead,   role = \"outcome\",   prefix = \"ahead_\",   default = NA,   skip = FALSE,   id = rand_id(\"epi_ahead\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a shifted predictor ‚Äî step_epi_lag","text":"recipe recipe object. step added sequence operations recipe. ... One selector functions choose variables step. See recipes::selections() details. lag, ahead vector integers. specified column lag lead value vector. Lag integers must nonnegative, ahead integers must positive. role model terms created step, analysis role assigned? lag default predictor ahead outcome. prefix character string prefixed new column. default Determines fills empty rows left leading/lagging (defaults NA). skip logical. step skipped recipe baked bake()? operations baked prep() run, operations may able conducted new data (e.g. processing outcome variable(s)). Care taken using skip = TRUE may affect computations subsequent operations. id unique identifier step","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_shift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a shifted predictor ‚Äî step_epi_lag","text":"updated version recipe new step added sequence existing operations.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_shift.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a shifted predictor ‚Äî step_epi_lag","text":"lag/ahead functions respect geo_value other_keys epi_df, allow discontiguous time_values. features noticably lacking recipe::step_lag(). lag/ahead functions also appropriately adjust amount data avoid accidentally dropping recent predictors test data. prefix id arguments unchangeable ensure code runs properly avoid inconsistency naming. step_epi_ahead, always set \"ahead_\" \"epi_ahead\" respectively, step_epi_lag, set \"lag_\" \"epi_lag, respectively.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_shift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a shifted predictor ‚Äî step_epi_lag","text":"","code":"r <- epi_recipe(covid_case_death_rates) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) r #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs  #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations  #> 1. Leading: death_rate by 7 #> 2. Lagging: death_rate by 0, 7, 14"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_slide.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a rolling window transformation ‚Äî step_epi_slide","title":"Calculate a rolling window transformation ‚Äî step_epi_slide","text":"step_epi_slide() creates specification recipe step generate one new columns derived data \"sliding\" computation along existing data. wrapper around epiprocess::epi_slide() allow use within epi_recipe().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_slide.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a rolling window transformation ‚Äî step_epi_slide","text":"","code":"step_epi_slide(   recipe,   ...,   .f,   .window_size = NULL,   .align = c(\"right\", \"center\", \"left\"),   role = \"predictor\",   prefix = \"epi_slide_\",   f_name = clean_f_name(.f),   skip = FALSE,   id = rand_id(\"epi_slide\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_slide.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a rolling window transformation ‚Äî step_epi_slide","text":"recipe recipe object. step added sequence operations recipe. ... One selector functions choose variables step. See recipes::selections() details. .f function one following formats: unquoted function name arguments, e.g., mean character string name function, e.g., \"mean\". Note can difficult examine mistakes (misspelling \"maen\" produce error try actually fit model) base R lambda function, e.g., function(x) mean(x, na.rm = TRUE) new-style base R lambda function, e.g., \\(x) mean(x, na.rm = TRUE) one-sided formula like ~ mean(.x, na.rm = TRUE). Note cases 3 4, x can variable name like (example \\(dog) mean(dog, na.rm = TRUE) work). case 5, argument must named .x. common, though difficult debug error using something like function(x) mean. work returns function mean, rather mean(x) .window_size size sliding window, required. Usually non-negative integer suffice (e.g. data indexed date, restrictive time_type cases (see epiprocess::epi_slide() details). example, set 7 7-day window. .align character string indicating window aligned. default, \"right\", meaning slide_window anchored right end point reference date. (see epiprocess::epi_slide() details). role model terms created step, analysis role assigned? lag default predictor ahead outcome. prefix character string prefixed new column. f_name character string 20 characters describes function. combined prefix columns ... name result using {prefix}{f_name}_{column}. default determined automatically using clean_f_name(). skip logical. step skipped recipe baked bake()? operations baked prep() run, operations may able conducted new data (e.g. processing outcome variable(s)). Care taken using skip = TRUE may affect computations subsequent operations. id unique identifier step","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_slide.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a rolling window transformation ‚Äî step_epi_slide","text":"updated version recipe new step added sequence existing operations.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_epi_slide.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a rolling window transformation ‚Äî step_epi_slide","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value >= as.Date(\"2021-01-01\"), geo_value %in% c(\"ca\", \"ny\")) rec <- epi_recipe(jhu) %>%   step_epi_slide(case_rate, death_rate,     .f = \\(x) mean(x, na.rm = TRUE),     .window_size = 7L   ) bake(prep(rec, jhu), new_data = NULL) #> An `epi_df` object, 730 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 730 √ó 6 #>    geo_value time_value case_rate death_rate epi_slide__.f_case_rate #>  * <chr>     <date>         <dbl>      <dbl>                   <dbl> #>  1 ca        2021-01-01      104.      0.854                    104. #>  2 ca        2021-01-02      102.      0.861                    103. #>  3 ca        2021-01-03      102.      0.864                    103. #>  4 ca        2021-01-04      102.      0.914                    103. #>  5 ca        2021-01-05      101.      0.913                    102. #>  6 ca        2021-01-06      108.      0.897                    103. #>  7 ca        2021-01-07      106.      0.943                    104. #>  8 ca        2021-01-08      106.      1.02                     104. #>  9 ca        2021-01-09      107.      1.11                     105. #> 10 ca        2021-01-10      110.      1.23                     106. #> # ‚Ñπ 720 more rows #> # ‚Ñπ 1 more variable: epi_slide__.f_death_rate <dbl>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_growth_rate.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a growth rate ‚Äî step_growth_rate","title":"Calculate a growth rate ‚Äî step_growth_rate","text":"step_growth_rate() creates specification recipe step generate one new columns derived data. wrapper around epiprocess::growth_rate() allow use within epi_recipe().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_growth_rate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a growth rate ‚Äî step_growth_rate","text":"","code":"step_growth_rate(   recipe,   ...,   role = \"predictor\",   horizon = 7,   method = c(\"rel_change\", \"linear_reg\"),   log_scale = FALSE,   na_rm = TRUE,   replace_Inf = NA,   prefix = \"gr_\",   skip = FALSE,   id = rand_id(\"growth_rate\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_growth_rate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a growth rate ‚Äî step_growth_rate","text":"recipe recipe object. step added sequence operations recipe. ... One selector functions choose variables step. See recipes::selections() details. role model terms created step, analysis role assigned? lag default predictor ahead outcome. horizon Bandwidth sliding window, method \"rel_change\" \"linear_reg\". See epiprocess::growth_rate() details. method Either \"rel_change\" \"linear_reg\", indicating method use growth rate calculation. local methods: run sliding fashion sequence (order estimate derivatives hence growth rates). See epiprocess::growth_rate() details. log_scale growth rates estimated using parameterization log scale? See details explanation. Default FALSE. na_rm missing values removed computation? Default FALSE. replace_Inf Sometimes, growth rate calculation can result infinite values (denominator zero, example). case, prediction methods fail. argument specifies potential replacement values. default (NA) likely result rows removed data. Alternatively, specify arbitrary large values, perhaps zero. Setting argument NULL result replacement. prefix character string prefixed new column. skip logical. step skipped recipe baked bake()? operations baked prep() run, operations may able conducted new data (e.g. processing outcome variable(s)). Care taken using skip = TRUE may affect computations subsequent operations. id unique identifier step","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_growth_rate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a growth rate ‚Äî step_growth_rate","text":"updated version recipe new step added sequence existing operations.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_growth_rate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a growth rate ‚Äî step_growth_rate","text":"","code":"tiny_geos <- c(\"as\", \"mp\", \"vi\", \"gu\", \"pr\") rates <- covid_case_death_rates %>%   filter(time_value >= as.Date(\"2021-11-01\"), !(geo_value %in% tiny_geos))  r <- epi_recipe(rates) %>%   step_growth_rate(case_rate, death_rate) r #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs  #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations  #> 1. Calculating growth_rate for: case_rate death_rate by rel_change  r %>%   prep(rates) %>%   bake(new_data = NULL) #> An `epi_df` object, 3,111 x 6 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3,111 √ó 6 #>    geo_value time_value case_rate death_rate gr_7_rel_change_case_rate #>  * <chr>     <date>         <dbl>      <dbl>                     <dbl> #>  1 ak        2021-11-01     87.9       0.494                        NA #>  2 al        2021-11-01     34.7       0.482                        NA #>  3 ar        2021-11-01     13.9       0.434                        NA #>  4 az        2021-11-01     40.4       0.566                        NA #>  5 ca        2021-11-01     15.6       0.241                        NA #>  6 co        2021-11-01     51.0       0.590                        NA #>  7 ct        2021-11-01      9.20      0.108                        NA #>  8 dc        2021-11-01     11.8       0.100                        NA #>  9 de        2021-11-01     26.0       0.391                        NA #> 10 fl        2021-11-01      7.99      0.484                        NA #> # ‚Ñπ 3,101 more rows #> # ‚Ñπ 1 more variable: gr_7_rel_change_death_rate <dbl>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_lag_difference.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a lagged difference ‚Äî step_lag_difference","title":"Calculate a lagged difference ‚Äî step_lag_difference","text":"step_lag_difference() creates specification recipe step generate one new columns derived data. column specification, step_lag_difference() calculate difference values distance horizon. example, horizon=1, simply difference adjacent days.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_lag_difference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a lagged difference ‚Äî step_lag_difference","text":"","code":"step_lag_difference(   recipe,   ...,   role = \"predictor\",   horizon = 7,   prefix = \"lag_diff_\",   skip = FALSE,   id = rand_id(\"lag_diff\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_lag_difference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a lagged difference ‚Äî step_lag_difference","text":"recipe recipe object. step added sequence operations recipe. ... One selector functions choose variables step. See recipes::selections() details. role model terms created step, analysis role assigned? lag default predictor ahead outcome. horizon Scalar vector. Time period(s) calculate differences. prefix character string prefixed new column. skip logical. step skipped recipe baked bake()? operations baked prep() run, operations may able conducted new data (e.g. processing outcome variable(s)). Care taken using skip = TRUE may affect computations subsequent operations. id unique identifier step","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_lag_difference.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a lagged difference ‚Äî step_lag_difference","text":"updated version recipe new step added sequence existing operations.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_lag_difference.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate a lagged difference ‚Äî step_lag_difference","text":"Much like step_epi_lag() step works actual time values (gaps fill NA values), respects grouping inherent epi_df() specified geo_value other_keys.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_lag_difference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a lagged difference ‚Äî step_lag_difference","text":"","code":"r <- epi_recipe(covid_case_death_rates) %>%   step_lag_difference(case_rate, death_rate, horizon = c(7, 14)) %>%   step_epi_naomit() r #>  #> ‚îÄ‚îÄ Epi Recipe ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Inputs  #> Number of variables by role #> raw:        2 #> geo_value:  1 #> time_value: 1 #>  #> ‚îÄ‚îÄ Operations  #> 1. Calculating lag_difference for: case_rate death_rate by 7, 14 #> 2. ‚Ä¢ Removing rows with NA values in: all_predictors() #> 3. ‚Ä¢ Removing rows with NA values in: all_outcomes()  r %>%   prep(covid_case_death_rates) %>%   bake(new_data = NULL) #> An `epi_df` object, 19,712 x 8 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 19,712 √ó 8 #>    geo_value time_value case_rate death_rate lag_diff_7_case_rate #>  * <chr>     <date>         <dbl>      <dbl>                <dbl> #>  1 ak        2021-01-14      37.4     0.0988               -4.07  #>  2 al        2021-01-14      73.6     2.51                 -7.70  #>  3 ar        2021-01-14      87.7     1.42                -10.3   #>  4 as        2021-01-14       0       0                     0     #>  5 az        2021-01-14     124.      2.14                  0.117 #>  6 ca        2021-01-14     108.      1.22                  2.38  #>  7 co        2021-01-14      31.7     0.354                -9.62  #>  8 ct        2021-01-14      75.4     1.07                  6.97  #>  9 dc        2021-01-14      41.5     0.681                 6.07  #> 10 de        2021-01-14      74.1     0.955                -5.46  #> # ‚Ñπ 19,702 more rows #> # ‚Ñπ 3 more variables: lag_diff_14_case_rate <dbl>, lag_diff_7_death_rate <dbl>, #> #   lag_diff_14_death_rate <dbl>"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_population_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert raw scale predictions to per-capita ‚Äî step_population_scaling","title":"Convert raw scale predictions to per-capita ‚Äî step_population_scaling","text":"step_population_scaling() creates specification recipe step perform per-capita scaling. Typical usage set df dataset contains population geo_value, use convert predictions made raw scale model rate-scale dividing population.  Although, worth noting nothing special \"population\", function can used scale variable. Population standard use case epidemiology forecasting scenario. value passed divide selected variables rate_rescaling argument common multiplier selected variables.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_population_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert raw scale predictions to per-capita ‚Äî step_population_scaling","text":"","code":"step_population_scaling(   recipe,   ...,   role = \"raw\",   df,   by = NULL,   df_pop_col,   rate_rescaling = 1,   create_new = TRUE,   suffix = \"_scaled\",   skip = FALSE,   id = rand_id(\"population_scaling\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_population_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert raw scale predictions to per-capita ‚Äî step_population_scaling","text":"recipe recipe object. step added sequence operations recipe. ... One selector functions choose variables step. See recipes::selections() details. role model terms created step, analysis role assigned? df data frame containing scaling data (typically population). target column divided value df_pop_col. (possibly named) character vector variables join df epi_df. NULL, default, function try infer reasonable set columns. First, try join variables training/test data roles \"geo_value\", \"key\", \"time_value\" also appear df; roles automatically set using epi_df, can use, e.g., update_role. roles set, try perform natural join, using variables common training/test data population data. columns training/testing data df name (included ), .df suffix added one user-provided data disambiguate. join different variables epi_df df, use named vector. example, = c(\"geo_value\" = \"states\") match epi_df$geo_value df$states. join multiple variables, use vector length > 1. example, = c(\"geo_value\" = \"states\", \"county\" = \"county\") match epi_df$geo_value df$states epi_df$county df$county. See dplyr::inner_join() details. df_pop_col name column data frame df contains population data used scaling. one column. rate_rescaling Sometimes raw scales \"per 100K\" \"per 1M\". Adjustments can made . example, original scale \"per 100K\", set rate_rescaling = 1e5 get rates. create_new TRUE create new column keep original column epi_df suffix character. suffix added column name create_new = TRUE. Default \"_scaled\". skip logical. step skipped recipe baked bake()? operations baked prep() run, operations may able conducted new data (e.g. processing outcome variable(s)). Care taken using skip = TRUE may affect computations subsequent operations. id unique identifier step","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_population_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert raw scale predictions to per-capita ‚Äî step_population_scaling","text":"Scales raw data population","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_population_scaling.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert raw scale predictions to per-capita ‚Äî step_population_scaling","text":"","code":"jhu <- cases_deaths_subset %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ca\", \"ny\")) %>%   select(geo_value, time_value, cases)  pop_data <- data.frame(states = c(\"ca\", \"ny\"), value = c(20000, 30000))  r <- epi_recipe(jhu) %>%   step_population_scaling(     df = pop_data,     df_pop_col = \"value\",     by = c(\"geo_value\" = \"states\"),     cases, suffix = \"_scaled\"   ) %>%   step_epi_lag(cases_scaled, lag = c(0, 7, 14)) %>%   step_epi_ahead(cases_scaled, ahead = 7, role = \"outcome\") %>%   step_epi_naomit()  f <- frosting() %>%   layer_predict() %>%   layer_threshold(.pred) %>%   layer_naomit(.pred) %>%   layer_population_scaling(.pred,     df = pop_data,     by = c(\"geo_value\" = \"states\"),     df_pop_col = \"value\"   )  wf <- epi_workflow(r, linear_reg()) %>%   fit(jhu) %>%   add_frosting(f)  forecast(wf) #> An `epi_df` object, 2 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2024-03-20 #>  #> # A tibble: 2 √ó 4 #>   geo_value time_value .pred .pred_scaled #>   <chr>     <date>     <dbl>        <dbl> #> 1 ca        2021-12-31  4.25       84938. #> 2 ny        2021-12-31  5.93      177766."},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_training_window.html","id":null,"dir":"Reference","previous_headings":"","what":"Limits the size of the training window to the most recent observations ‚Äî step_training_window","title":"Limits the size of the training window to the most recent observations ‚Äî step_training_window","text":"step_training_window creates specification recipe step limits size training window n_recent recent observations time_value per group, groups formed based remaining epi_keys.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_training_window.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Limits the size of the training window to the most recent observations ‚Äî step_training_window","text":"","code":"step_training_window(   recipe,   role = NA,   n_recent = 50,   epi_keys = NULL,   id = rand_id(\"training_window\") )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_training_window.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Limits the size of the training window to the most recent observations ‚Äî step_training_window","text":"recipe recipe object. step added sequence operations recipe. role model terms created step, analysis role assigned? lag default predictor ahead outcome. n_recent integer value represents number recent observations kept training window per key default value 50. epi_keys optional character vector specifying \"key\" variables group . default, NULL, ensures every key combination limited. id unique identifier step","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_training_window.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Limits the size of the training window to the most recent observations ‚Äî step_training_window","text":"updated version recipe new step added sequence existing operations.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_training_window.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Limits the size of the training window to the most recent observations ‚Äî step_training_window","text":"recommended step_epi_ahead(), step_epi_lag(), step_epi_naomit() steps. step_training_window() happens first, less n_training remaining examples, since either leading lagging introduce NA's later removed step_epi_naomit(). Typical usage use step last epi_recipe().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/step_training_window.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Limits the size of the training window to the most recent observations ‚Äî step_training_window","text":"","code":"tib <- tibble(   x = 1:10,   y = 1:10,   time_value = rep(seq(as.Date(\"2020-01-01\"), by = 1, length.out = 5), 2),   geo_value = rep(c(\"ca\", \"hi\"), each = 5) ) %>%   as_epi_df()  epi_recipe(y ~ x, data = tib) %>%   step_training_window(n_recent = 3) %>%   prep(tib) %>%   bake(new_data = NULL) #> An `epi_df` object, 6 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2025-06-23 21:50:32.80633 #>  #> # A tibble: 6 √ó 4 #>   geo_value time_value     x     y #> * <chr>     <date>     <int> <int> #> 1 ca        2020-01-03     3     3 #> 2 ca        2020-01-04     4     4 #> 3 ca        2020-01-05     5     5 #> 4 hi        2020-01-03     8     8 #> 5 hi        2020-01-04     9     9 #> 6 hi        2020-01-05    10    10  epi_recipe(y ~ x, data = tib) %>%   step_epi_naomit() %>%   step_training_window(n_recent = 3) %>%   prep(tib) %>%   bake(new_data = NULL) #> An `epi_df` object, 6 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2025-06-23 21:50:32.80633 #>  #> # A tibble: 6 √ó 4 #>   geo_value time_value     x     y #> * <chr>     <date>     <int> <int> #> 1 ca        2020-01-03     3     3 #> 2 ca        2020-01-04     4     4 #> 3 ca        2020-01-05     5     5 #> 4 hi        2020-01-03     8     8 #> 5 hi        2020-01-04     9     9 #> 6 hi        2020-01-05    10    10"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/tidy.frosting.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidy the result of a frosting object ‚Äî tidy.frosting","title":"Tidy the result of a frosting object ‚Äî tidy.frosting","text":"tidy return data frame contains information regarding frosting operation within frosting (tidy method operation exists). Note modified version tidy method recipe.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/tidy.frosting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tidy the result of a frosting object ‚Äî tidy.frosting","text":"","code":"# S3 method for class 'frosting' tidy(x, number = NA, id = NA, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/tidy.frosting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tidy the result of a frosting object ‚Äî tidy.frosting","text":"x frosting layer object number integer NA. missing, id provided, return value list operations frosting. number given, tidy method executed operation frosting (exists). number must provided id . id character string NA. missing number provided, return value list operations frosting. character string given, tidy method executed operation frosting (exists). id must provided number . ... currently used.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/tidy.frosting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tidy the result of a frosting object ‚Äî tidy.frosting","text":"tibble columns vary depending tidy method executed. number, id NA, tibble columns number (operation iteration), operation (\"layer\"), type (method, e.g. \"predict\", \"naomit\"), character column id.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/tidy.frosting.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tidy the result of a frosting object ‚Äî tidy.frosting","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\"))  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit()  wf <- epi_workflow(r, parsnip::linear_reg()) %>% fit(jhu) latest <- get_test_data(recipe = r, x = jhu)  f <- frosting() %>%   layer_predict() %>%   layer_naomit(.pred)  tidy(f) #> # A tibble: 2 √ó 4 #>   number operation type    id                    #>    <int> <chr>     <chr>   <chr>                 #> 1      1 layer     predict predict_default_A9P3F #> 2      2 layer     naomit  naomit_0BHNB"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/update.layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Update post-processing layer ‚Äî update.layer","title":"Update post-processing layer ‚Äî update.layer","text":"layer method update() takes named arguments ... whose values replace elements name actual post-processing layer. Analogous update.step() recipes package.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/update.layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update post-processing layer ‚Äî update.layer","text":"","code":"# S3 method for class 'layer' update(object, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/update.layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update post-processing layer ‚Äî update.layer","text":"object post-processing layer. ... Key-value pairs keys match names elements layer, values new values update layer .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/update.layer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update post-processing layer ‚Äî update.layer","text":"","code":"jhu <- covid_case_death_rates %>%   filter(time_value > \"2021-11-01\", geo_value %in% c(\"ak\", \"ca\", \"ny\")) r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_naomit() wf <- epi_workflow(r, linear_reg()) %>% fit(jhu) latest <- jhu %>% filter(time_value >= max(time_value) - 14)  # Specify a `forecast_date` that is greater than or equal to `as_of` date f <- frosting() %>%   layer_predict() %>%   layer_add_forecast_date(forecast_date = \"2022-05-31\") %>%   layer_naomit(.pred)  wf1 <- wf %>% add_frosting(f)  p1 <- predict(wf1, latest) p1 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 4 #>   geo_value time_value .pred forecast_date #>   <chr>     <date>     <dbl> <date>        #> 1 ak        2021-12-31 0.245 2022-05-31    #> 2 ca        2021-12-31 0.312 2022-05-31    #> 3 ny        2021-12-31 0.295 2022-05-31     # Update forecast date f$layers[[2]] <- update(f$layers[[2]], forecast_date = \"2021-06-01\")  # Need to still update workflow if only update a layer in frosting wf2 <- wf %>% add_frosting(f) wf2$post # Check that wf1 has update #> $actions #> $actions$frosting #> $frosting #>  #> ‚îÄ‚îÄ Frosting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #>  #> ‚îÄ‚îÄ Layers  #> 1. Creating predictions: \"<calculated>\" #> 2. Adding forecast date: \"2021-06-01\" #> 3. Removing na predictions from: .pred #>  #> attr(,\"class\") #> [1] \"action_post\" \"action\"      #>  #>  #> attr(,\"class\") #> [1] \"stage_post\" \"stage\"      p1 <- predict(wf2, latest) p1 #> An `epi_df` object, 3 x 4 with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2023-03-10 #>  #> # A tibble: 3 √ó 4 #>   geo_value time_value .pred forecast_date #>   <chr>     <date>     <dbl> <date>        #> 1 ak        2021-12-31 0.245 2021-06-01    #> 2 ca        2021-12-31 0.312 2021-06-01    #> 3 ny        2021-12-31 0.295 2021-06-01"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/weighted_interval_score.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute weighted interval score ‚Äî weighted_interval_score","title":"Compute weighted interval score ‚Äî weighted_interval_score","text":"Weighted interval score (WIS), well-known quantile-based approximation commonly-used continuous ranked probability score (CRPS). WIS proper score, can thought distributional generalization absolute error. example, see Bracher et al. (2020) discussion context COVID-19 forecasting.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/weighted_interval_score.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute weighted interval score ‚Äî weighted_interval_score","text":"","code":"weighted_interval_score(   x,   actual,   quantile_levels = NULL,   na_handling = c(\"impute\", \"drop\", \"propagate\", \"fail\"),   ... )"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/weighted_interval_score.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute weighted interval score ‚Äî weighted_interval_score","text":"x vector class quantile_pred. actual double. Actual value(s) quantile_levels probabilities. specified, score computed set levels. Otherwise, present x used. na_handling character. Determines missing values handled. \"impute\", missing values calculated possible using available quantiles. \"drop\", explicitly missing values ignored calculation score, implicitly missing values imputed possible. \"propogate\", resulting score NA missing values exist. Finally, quantile_levels specified, \"fail\" result score NA required quantile levels (implicit explicit) corresponding values. ... used","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/weighted_interval_score.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute weighted interval score ‚Äî weighted_interval_score","text":"vector nonnegative scores.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/weighted_interval_score.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute weighted interval score ‚Äî weighted_interval_score","text":"","code":"quantile_levels <- c(.2, .4, .6, .8) predq1 <- 1:4 # predq2 <- 8:11 dstn <- quantile_pred(rbind(predq1, predq2), quantile_levels) actual <- c(3.3, 7.1) weighted_interval_score(dstn, actual) #> [1] 0.65 1.90 weighted_interval_score(dstn, actual, c(.25, .5, .75)) #> [1] 0.6833333 1.9833333  # Missing value behaviours dstn <- quantile_pred(matrix(c(1, 2, NA, 4), nrow = 1), 1:4 / 5) weighted_interval_score(dstn, 2.5) #> [1] 0.5 weighted_interval_score(dstn, 2.5, 1:9 / 10) #> [1] 0.455656 weighted_interval_score(dstn, 2.5, 1:9 / 10, na_handling = \"drop\") #> [1] 0.462613 weighted_interval_score(dstn, 2.5, na_handling = \"propagate\") #> [1] NA weighted_interval_score(   quantile_pred(matrix(1:4, nrow = 1), 1:4 / 5),   actual = 2.5,   quantile_levels = 1:9 / 10,   na_handling = \"fail\" ) #> [1] NA   # Using some actual forecasts -------- library(dplyr) training <- covid_case_death_rates %>%   filter(time_value >= \"2021-10-01\", time_value <= \"2021-12-01\") preds <- flatline_forecaster(   training, \"death_rate\",   flatline_args_list(quantile_levels = c(.01, .025, 1:19 / 20, .975, .99)) )$predictions actuals <- covid_case_death_rates %>%   filter(time_value == as.Date(\"2021-12-01\") + 7) %>%   select(geo_value, time_value, actual = death_rate) preds <- left_join(preds, actuals,   by = c(\"target_date\" = \"time_value\", \"geo_value\") ) %>%   mutate(wis = weighted_interval_score(.pred_distn, actual)) preds #> # A tibble: 56 √ó 7 #>    geo_value .pred .pred_distn forecast_date target_date actual    wis #>    <chr>     <dbl>  <qtls(23)> <date>        <date>       <dbl>  <dbl> #>  1 ak        0.217     [0.217] 2021-12-01    2021-12-08  0.0988 0.0673 #>  2 al        0.119     [0.119] 2021-12-01    2021-12-08  0.174  0.0364 #>  3 ar        0.207     [0.207] 2021-12-01    2021-12-08  0.514  0.196  #>  4 as        0             [0] 2021-12-01    2021-12-08  0      0.0145 #>  5 az        0.485     [0.485] 2021-12-01    2021-12-08  0.826  0.223  #>  6 ca        0.169     [0.169] 2021-12-01    2021-12-08  0.185  0.0278 #>  7 co        0.509     [0.509] 2021-12-01    2021-12-08  0.534  0.0313 #>  8 ct        0.177     [0.177] 2021-12-01    2021-12-08  0.149  0.0301 #>  9 dc        0             [0] 2021-12-01    2021-12-08  0.0200 0.0166 #> 10 de        0.217     [0.217] 2021-12-01    2021-12-08  0.391  0.101  #> # ‚Ñπ 46 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/within_window.html","id":null,"dir":"Reference","previous_headings":"","what":"generate the idx values within window_size of target_idx given that our time value is of the type matching modulus ‚Äî within_window","title":"generate the idx values within window_size of target_idx given that our time value is of the type matching modulus ‚Äî within_window","text":"generate idx values within window_size target_idx given time value type matching modulus","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/within_window.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"generate the idx values within window_size of target_idx given that our time value is of the type matching modulus ‚Äî within_window","text":"","code":"within_window(target_idx, window_size, modulus)"},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/within_window.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"generate the idx values within window_size of target_idx given that our time value is of the type matching modulus ‚Äî within_window","text":"target_idx time index drawing window around window_size size window one side target_idx modulus number days/weeks/months year, including leap days/weeks","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/yday_leap.html","id":null,"dir":"Reference","previous_headings":"","what":"a function that assigns Feb 29th to 999, and aligns all other dates the same number in the year, regardless of whether it's a leap year ‚Äî yday_leap","title":"a function that assigns Feb 29th to 999, and aligns all other dates the same number in the year, regardless of whether it's a leap year ‚Äî yday_leap","text":"function assigns Feb 29th 999, aligns dates number year, regardless whether leap year","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/reference/yday_leap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"a function that assigns Feb 29th to 999, and aligns all other dates the same number in the year, regardless of whether it's a leap year ‚Äî yday_leap","text":"","code":"yday_leap(time_value)"},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/dev/news/index.html","id":"breaking-changes-0-2","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"epipredict 0.2","text":"Moved example datasets hosted package loaded epidatasets package. datasets can longer loaded data(<dataset name>), can accessed data(<dataset name>, package = \"epidatasets\"), epidatasets::<dataset name> , loading package, name dataset alone (#382). step_adjust_latency() longer allows empty column selection. Addresses upstream breaking changes cmu-delphi/epiprocess#595 (growth_rate()). step_growth_rate() lost additional_gr_args_list argument now na_rm argument. Moves epiprocess depends (#440). internals changed, downstream users may need add library(epiprocess) existing code. Removes dependence distributional package, replacing quantiles hardhat::quantile_pred(). associated functions deprecated lifecycle messages. Rename check_enough_train_data() check_enough_data(), generalize enough use check either training testing. Add check enough data predict arx_forecaster() Adds .facet_filter option epiprocess::autoplot() (cmu-delphi/epiprocess#647).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/news/index.html","id":"improvements-0-2","dir":"Changelog","previous_headings":"","what":"Improvements","title":"epipredict 0.2","text":"Add step_adjust_latency, give several methods adjust forecast forecast_date last day data. Fix layer_population_scaling default other_keys. Make key column inference consistent within package current epiprocess. Fix quantile_reg() producing error asked output just median-level predictions. (temporary) ahead negative allowed step_epi_ahead step_epi_shift Add reference_date argument epi_recipe() Add step_climate() create ‚Äúclimate‚Äù predictor forecast workflows Add climatological_forecaster() automatically create climate baselines Replace dist_quantiles() hardhat::quantile_pred() Allow quantile() threshold interval desired (#434) arx_forecaster() detects ‚Äôs enough data predict Add observed_response autoplot forecasts can plotted values ‚Äôre predicting","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/news/index.html","id":"bug-fixes-0-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"epipredict 0.2","text":"Shifting columns results error either step_epi_ahead step_epi_lag Quantiles produced grf sometimes order. dist_quantiles can NA values without causing unrelated errors adjust default quantiles throughout match. force layer_residual_quantiles() always include 0.5. Rename recipes:::check_training_set() recipes:::validate_training_data(), changed recipes 1.1.0. new column name duplicating existing column name results error instead random name.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/dev/news/index.html","id":"epipredict-01","dir":"Changelog","previous_headings":"","what":"epipredict 0.1","title":"epipredict 0.1","text":"simplify layer_residual_quantiles() avoid timesuck utils::methods() rename dist_quantiles() descriptive, breaking change removes previous pivot_quantiles() (now *_wider(), breaking change) add pivot_quantiles_wider() easier plotting add complement pivot_quantiles_longer() add cdc_baseline_forecaster() flusight_hub_formatter() add smooth_quantile_reg() improved printing various methods / internals canned forecasters get class fixed quantile bug flatline_forecaster() add functionality output unfit workflow canned forecasters add quantile_reg() clean documentation bugs add smooth_quantile_reg() add classifier training window step debugged min_train_window argument removed canned forecasters add forecasters implement post-processing vignettes avaliable arx_forecaster pkgdown Publish public easy navigation Two simple forecasters test beds Working vignette use checkmate input validation refactor quantile extrapolation (possibly creates different results) force target_date + forecast_date handling match time_type epi_df. allows annual weekly data add check_enough_train_data() error training data small added check_enough_train_data() arx_forecaster() layer_residual_quantiles() now error residual quantiles NA *_args_list() functions now warn forecast_date + ahead != target_date predictor argument arx_forecaster() now defaults value outcome argument arx_fcast_epi_workflow() arx_class_epi_workflow() now default trainer = parsnip::logistic_reg() match canned versions. add forecast() method simplify generating forecasts refactor bake.epi_recipe() remove epi_juice(). Revise compat-purrr use r-lang standalone-* version (via usethis) Replaced old version-faithful example sliding AR & ARX forecasters vignette epi_recipe() now warn given non-epi_df data layer_predict() predict.epi_workflow() now appropriately forward ... args intended predict.model_fit() bake.epi_recipe() now re-infer geo time type case baking steps changed appropriate values produce length 0 dist_quantiles() add functionality calculate weighted interval scores dist_quantiles() Add step_epi_slide produce generic sliding computations epi_df Add quantile random forests (via grf) parsnip engine Replace epi_keys() epiprocess::key_colnames(), #352 descriptive error messages arg_is_*(), #287 Fix bug fit() drops epi_workflow class (also error non-epi_df data given epi_recipe()), #363 Try retain epi_df class baking extent possible, #376","code":""}]
