[{"path":"https://cmu-delphi.github.io/epipredict/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 epipredict authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/articles/knn-forecasts.html","id":"knn-enhanced-direct-arx-forecastor","dir":"Articles","previous_headings":"","what":"KNN Enhanced Direct ARX Forecastor","title":"KNN AR(X) forecasts","text":"First, download data process (hidden). now make forecasts archive compare forecasts latest data.","code":"# Latest snapshot of data, and forecast dates x_latest <- epix_as_of(x, max_version = max(x$DT$version)) fc_time_values <- seq(as.Date(\"2020-10-01\"), as.Date(\"2021-12-01\"),                        by = \"1 month\")   k_week_ahead <- function(ahead = 7, as_of = TRUE) {   if (as_of) {     x %>%       epix_slide(fc = knnarx_forecaster(         percent_cli, case_rate, geo_value, time_value,          args = knnarx_args_list(ahead = ahead,                       lags = c(1,7,14),                       query_window_len = 32,                       topK = 100,                       intercept = FALSE)),         n = Inf, ref_time_values = fc_time_values) %>%       mutate(target_date = time_value + ahead, as_of = as_of,              geo_value = fc_key_vars)   } else {     x_latest %>%       epi_slide(fc = knnarx_forecaster(         percent_cli, case_rate, geo_value, time_value,         args = knnarx_args_list(ahead = ahead,                       lags = c(1,7,14),                       query_window_len = 32,                       topK = 100,                        intercept = FALSE)),         n = Inf, ref_time_values = fc_time_values) %>%       mutate(target_date = time_value + ahead, as_of = as_of)   } }  # Generate the forecasts, and bind them together fc <- bind_rows(   purrr::map_dfr(c(7,14,21,28), ~ k_week_ahead(.x, as_of = TRUE)),   purrr::map_dfr(c(7,14,21,28), ~ k_week_ahead(.x, as_of = FALSE)) ) ggplot(fc %>% filter(as_of == TRUE), aes(x = target_date, group = time_value)) +   geom_vline(aes(xintercept = time_value), linetype = 2, alpha = 0.5) +   geom_line(data = x_latest, aes(x = time_value, y = case_rate),             inherit.aes = FALSE, color = \"gray50\") +   geom_ribbon(aes(ymin = fc_q0.05, ymax = fc_q0.95, fill = geo_value), alpha = 0.4) +   geom_line(aes(y = fc_point)) +   geom_point(aes(y = fc_point), size = 0.5) +   facet_wrap(~ geo_value, ncol = 4, scales = \"free_y\") +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %y\") +   labs(x = \"Date\", y = \"Reported COVID-19 case rates\") +   theme(legend.position = \"none\")"},{"path":"https://cmu-delphi.github.io/epipredict/articles/knn-forecasts.html","id":"knn-enhanced-iterative-ar-forecastor","dir":"Articles","previous_headings":"","what":"KNN Enhanced Iterative AR Forecastor","title":"KNN AR(X) forecasts","text":"moment, KNN Enhanced iterative forecasting strategy support AR forecastor, means can deal one signal time. direct example, following pipeline run predictions iterative forecasting strategy.  update_model parameter iterative forecastor API decides one-step ahead model updated iterative predicting procedure. following pipeline shows results trigger turned .","code":"ahead <- 21 final_iterative <- x %>%   epix_slide(     fc = knn_iteraive_ar_forecaster(       NULL, case_rate, geo_value, time_value,       args = knn_iteraive_ar_args_list(         ahead = ahead,         lags = c(1, 7, 14),         query_window_len = 32,         topK = 100,         symmetrize = FALSE,         update_model = FALSE       )     ) %>% nest_by(key_vars),     n = Inf, ref_time_values = fc_time_values   ) %>% unnest(fc_data) %>%    mutate(target_date = time_value + ahead, as_of = TRUE) %>%   rename(geo_value = fc_key_vars)  ggplot(final_iterative, aes(x = target_date, group = time_value)) +   geom_vline(aes(xintercept = time_value), linetype = 2, alpha = 0.5) +   geom_line(data = x_latest  , aes(x = time_value, y = case_rate),             inherit.aes = FALSE, color = \"gray50\") +   geom_ribbon(aes(ymin = q0.05, ymax = q0.95, fill = geo_value), alpha = 0.4) +   geom_line(aes(y = point)) +   geom_point(aes(y = point), size = 0.5) +   facet_wrap(~ geo_value, ncol = 4, scales = \"free_y\") +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %y\") +   labs(x = \"Date\", y = \"Reported COVID-19 case rates\") +   theme(legend.position = \"none\") final_dynamiciterative <- x %>%   epix_slide(     fc = knn_iteraive_ar_forecaster(       NULL, case_rate, geo_value, time_value,       args = knn_iteraive_ar_args_list(         ahead = ahead,         lags = c(1, 7, 14),         query_window_len = 32,         topK = 100,         symmetrize = FALSE,         update_model = TRUE       )     ) %>% nest_by(key_vars),     n = Inf, ref_time_values = fc_time_values   ) %>% unnest(fc_data) %>%    mutate(target_date = time_value + ahead, as_of = TRUE) %>%   rename(geo_value = fc_key_vars)  ggplot(final_dynamiciterative, aes(x = target_date, group = time_value)) +   geom_vline(aes(xintercept = time_value), linetype = 2, alpha = 0.5) +   geom_line(data = x_latest  , aes(x = time_value, y = case_rate),             inherit.aes = FALSE, color = \"gray50\") +   geom_ribbon(aes(ymin = q0.05, ymax = q0.95, fill = geo_value), alpha = 0.4) +   geom_line(aes(y = point)) +   geom_point(aes(y = point), size = 0.5) +   facet_wrap(~ geo_value, ncol = 4, scales = \"free_y\") +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %y\") +   labs(x = \"Date\", y = \"Reported COVID-19 case rates\") +   theme(legend.position = \"none\")"},{"path":"https://cmu-delphi.github.io/epipredict/articles/knn-forecasts.html","id":"using-data-for-canada","dir":"Articles","previous_headings":"","what":"Using data for Canada","title":"KNN AR(X) forecasts","text":"leveraging flexibility epiprocess, can apply techniques data sources. Since ’m British Columbia, may well thing Canada. COVID-19 Canada Open Data Working Group collects daily time series data COVID-19 cases, deaths, recoveries, testing vaccinations health region province levels. Data collected publicly available sources government datasets news releases. Unfortunately, simple versioned source, created Commit history. First, load versioned case numbers provincial level, convert epi_archive object. run similar forcasting exercise . figures shows results provinces. Note showing 7-day averages rather reported case numbers due highly variable provincial reporting mismatches.","code":"# source(\"drafts/canada-case-rates.R) can <- readRDS(   system.file(\"extdata\", \"can_prov_cases.rds\",                package = \"epipredict\", mustWork = TRUE)   ) %>%   group_by(version, geo_value) %>%    arrange(time_value) %>%    mutate(cr_7dav = RcppRoll::roll_meanr(case_rate, n = 7L))  can <- as_epi_archive(can) can_latest <- epix_as_of(can, max_version = max(can$DT$version)) can_fc_time_values = seq(as.Date(\"2020-10-01\"), as.Date(\"2021-11-01\"),                        by = \"1 month\")  can_k_week_ahead <- function(ahead = 7, as_of = TRUE) {   if (as_of) {     can %>%       epix_slide(fc = knnarx_forecaster(         y = cr_7dav, key_vars = geo_value, time_value = time_value,         args =knnarx_args_list(ahead = ahead,                       lags = c(1,7,14),                       query_window_len = 32,                       topK = 200)),         n = Inf, ref_time_values = fc_time_values) %>%       mutate(target_date = time_value + ahead, geo_value = fc_key_vars,              as_of = as_of)   } else {     can_latest %>%       epi_slide(fc = knnarx_forecaster(         y = cr_7dav, key_vars = geo_value, time_value = time_value,         args = knnarx_args_list(ahead = ahead,                       lags = c(1,7,14),                       query_window_len = 32,                       topK = 300)),         n = Inf, ref_time_values = fc_time_values) %>%       mutate(target_date = time_value + ahead, geo_value = fc_key_vars,              as_of = as_of)   } }  can_fc <- bind_rows(   purrr:::map_dfr(c(7,14,21,28), ~ can_k_week_ahead(ahead = .x, as_of = TRUE)),   purrr:::map_dfr(c(7,14,21,28), ~ can_k_week_ahead(ahead = .x, as_of = FALSE)) ) ggplot(can_fc %>% filter(! as_of),         aes(x = target_date, group = time_value)) +   coord_cartesian(xlim = lubridate::ymd(c(\"2020-12-01\", NA))) +   geom_line(data = can_latest, aes(x = time_value, y = cr_7dav),             inherit.aes = FALSE, color = \"gray50\") +   geom_ribbon(aes(ymin = fc_q0.05, ymax = fc_q0.95, fill = geo_value),               alpha = 0.4) +   geom_line(aes(y = fc_point)) + geom_point(aes(y = fc_point), size = 0.5) +      geom_vline(aes(xintercept = time_value), linetype = 2, alpha = 0.5) +   facet_wrap(~geo_value, scales = \"free_y\", ncol = 3) +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %y\") +   labs(title = \"Finalized data\", x = \"Date\",         y = \"Reported COVID-19 case rates\") +   theme(legend.position = \"none\") ggplot(can_fc %>% filter(as_of),         aes(x = target_date, group = time_value)) +   coord_cartesian(xlim = lubridate::ymd(c(\"2020-12-01\", NA))) +   geom_line(data = can_latest, aes(x = time_value, y = cr_7dav),             inherit.aes = FALSE, color = \"gray50\") +   geom_ribbon(aes(ymin = fc_q0.05, ymax = fc_q0.95, fill = geo_value),               alpha = 0.4) +   geom_line(aes(y = fc_point)) + geom_point(aes(y = fc_point), size = 0.5) +   geom_vline(aes(xintercept = time_value), linetype = 2, alpha = 0.5) +   facet_wrap(~ geo_value, scales = \"free_y\", ncol = 3) +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %y\") +   labs(title = \"Properly versioned data\", x = \"Date\",         y = \"Reported COVID-19 case rates\") +   theme(legend.position = \"none\")"},{"path":"https://cmu-delphi.github.io/epipredict/articles/simple-forecasts.html","id":"reproducing-the-arx-forecaster","dir":"Articles","previous_headings":"","what":"Reproducing the ARX forecaster","title":"Simple forecasts","text":"First, download data process (hidden). now make forecasts archive compare forecasts latest data. , arx_forecaster() heavy lifting. creates leads target (respecting time stamps locations) along lags features (, response doctors visits), estimates autoregressive model, creates predictions, non-parametric confidence bands. tunable parameters. Now plot top latest case rates.  look generally great, ’s ’ve used two locations, ’re behaviour rather different.","code":"# Latest snapshot of data, and forecast dates x_latest <- epix_as_of(x, max_version = max(x$DT$version)) fc_time_values <- seq(as.Date(\"2020-08-01\"), as.Date(\"2021-12-01\"),                        by = \"1 month\")   k_week_ahead <- function(ahead = 7, as_of = TRUE) {   if (as_of) {     x %>%       epix_slide(fc = arx_forecaster(         percent_cli, case_rate, geo_value, time_value,          args = arx_args_list(ahead = ahead, intercept = FALSE)),         n = 120, ref_time_values = fc_time_values) %>%       mutate(target_date = time_value + ahead, as_of = as_of,              geo_value = fc_key_vars)   } else {     x_latest %>%       epi_slide(fc = arx_forecaster(         percent_cli, case_rate, geo_value, time_value,         args = arx_args_list(ahead = ahead, intercept = FALSE)),         n = 120, ref_time_values = fc_time_values) %>%       mutate(target_date = time_value + ahead, as_of = as_of)   } }  # Generate the forecasts, and bind them together fc <- bind_rows(   purrr::map_dfr(c(7,14,21,28), ~ k_week_ahead(.x, as_of = TRUE)),   purrr::map_dfr(c(7,14,21,28), ~ k_week_ahead(.x, as_of = FALSE)) ) ggplot(fc, aes(x = target_date, group = time_value, fill = as_of)) +   geom_line(data = x_latest, aes(x = time_value, y = case_rate),             inherit.aes = FALSE, color = \"gray50\") +   geom_ribbon(aes(ymin = fc_q0.05, ymax = fc_q0.95), alpha = 0.4) +   geom_line(aes(y = fc_point)) + geom_point(aes(y = fc_point), size = 0.5) +   geom_vline(aes(xintercept = time_value), linetype = 2, alpha = 0.5) +   facet_grid(vars(geo_value), vars(as_of), scales = \"free\") +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %y\") +   labs(x = \"Date\", y = \"Reported COVID-19 case rates\") +   theme(legend.position = \"none\")"},{"path":"https://cmu-delphi.github.io/epipredict/articles/simple-forecasts.html","id":"smooth-forecasts-at-daily-horizons","dir":"Articles","previous_headings":"","what":"Smooth forecasts at daily horizons","title":"Simple forecasts","text":"making forecasts multiple horizons, may want “smooth” rather jagged . One way , described Tuzhilina et al. estimate version multiple least squares model response vector \\(Y \\\\mathbb{R}^{d}\\) \\(d\\) number horizons. , example, taking \\(h = {7, 14, 21, 28}\\) , result \\(d=4\\). concatenating row-wise matrix \\(\\mathbf{Y}\\), multiple least squares solves \\(d\\) OLS problems simultaneously optimizing \\[ \\min_\\Theta \\lVert \\mathbf{Y} - \\mathbf{X}\\Theta \\rVert_F^2 \\] \\(\\lVert\\mathbf{}\\rVert_F\\) Frobenius norm matrix \\(\\mathbf{}\\) given \\(\\left(\\sum_{ij} a_{ij}^2\\right)^{1/2}\\) \\(\\Theta\\) matrix coefficients \\(\\mathbb{R}^{p\\times d}\\). produce smooth forecasts, first expand vector horizons \\(h\\) basis (say basis \\(\\) polynomials, \\(\\leq d\\)) right multiply \\(\\mathbf{Y}\\) result. leads following smoothed optimization problem \\[ \\min_\\Gamma \\lVert \\mathbf{Y}\\mathbf{H}^\\mathsf{T} - \\mathbf{X}\\Gamma \\rVert_F^2. \\] Predictions can produced easily undoing transformation \\(\\mathbf{H}\\). See Tuzhilina et al. details. epipredict, methodology implemented smooth_arx_forecaster(). , ’ll make forecasts archive, time h=1:28 =4. Everything else works similarly arx_forecaster() . Unfortunately, ’s bug forecaster…","code":"fc_data <- x %>%   epix_slide(     fc = smooth_arx_forecaster(       percent_cli, case_rate, geo_value, time_value     ) %>% nest_by(key_vars), # on each date, this produces a data frame,                               # which we nest to allow for sliding.     n = 120, ref_time_values = fc_time_values) %>%   unnest(fc_data) %>% # unnest it to get a long dataframe like before   mutate(target_date = time_value + ahead) %>%   rename(geo_value = fc_key_vars) ggplot(fc_data, aes(x = target_date, group = time_value)) +   geom_vline(aes(xintercept = time_value), linetype = 2, alpha = 0.5) +   geom_line(data = x_latest, aes(x = time_value, y = case_rate),             inherit.aes = FALSE, color = \"gray50\") +   geom_ribbon(aes(ymin = q0.05, ymax = q0.95, fill = geo_value), alpha = 0.4) +   geom_line(aes(y = point)) +   geom_point(aes(y = point), size = 0.5) +   facet_wrap(~ geo_value, scales = \"free_y\") +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %y\") +   labs(x = \"Date\", y = \"Reported COVID-19 case rates\") +   theme(legend.position = \"none\")"},{"path":"https://cmu-delphi.github.io/epipredict/articles/simple-forecasts.html","id":"using-data-for-canada","dir":"Articles","previous_headings":"","what":"Using data for Canada","title":"Simple forecasts","text":"leveraging flexibility epiprocess, can apply techniques data sources. Since ’m British Columbia, may well thing Canada. COVID-19 Canada Open Data Working Group collects daily time series data COVID-19 cases, deaths, recoveries, testing vaccinations health region province levels. Data collected publicly available sources government datasets news releases. Unfortunately, simple versioned source, created Commit history. First, load versioned case numbers provincial level, convert epi_archive object. run similar forcasting exercise . figures shows results provinces. Note showing 7-day averages rather reported case numbers due highly variable provincial reporting mismatches.","code":"# source(\"drafts/canada-case-rates.R) can <- readRDS(   system.file(\"extdata\", \"can_prov_cases.rds\",                package = \"epipredict\", mustWork = TRUE)   ) %>%   group_by(version, geo_value) %>%    arrange(time_value) %>%    mutate(cr_7dav = RcppRoll::roll_meanr(case_rate, n = 7L)) #%>%   #filter(geo_value %in% c('Alberta', \"BC\")) can <- as_epi_archive(can) can_latest <- epix_as_of(can, max_version = max(can$DT$version))  can_k_week_ahead <- function(ahead = 7, as_of = TRUE) {   if (as_of) {     can %>%       epix_slide(fc = arx_forecaster(         y = cr_7dav, key_vars = geo_value, time_value = time_value,         args = arx_args_list(intercept = FALSE, ahead = ahead)),         n = 120, ref_time_values = fc_time_values) %>%       mutate(target_date = time_value + ahead, geo_value = fc_key_vars,              as_of = as_of)   } else {     can_latest %>%       epi_slide(fc = arx_forecaster(         y = cr_7dav, key_vars = geo_value, time_value = time_value,         args = arx_args_list(intercept = FALSE, ahead = ahead)),         n = 120, ref_time_values = fc_time_values) %>%       mutate(target_date = time_value + ahead, geo_value = fc_key_vars,              as_of = as_of)   } }  can_fc <- bind_rows(   purrr:::map_dfr(c(7,14,21,28), ~ can_k_week_ahead(ahead = .x, as_of = TRUE)),   purrr:::map_dfr(c(7,14,21,28), ~ can_k_week_ahead(ahead = .x, as_of = FALSE)) ) ggplot(can_fc %>% filter(! as_of),         aes(x = target_date, group = time_value)) +   coord_cartesian(xlim = lubridate::ymd(c(\"2020-12-01\", NA))) +   geom_line(data = can_latest, aes(x = time_value, y = cr_7dav),             inherit.aes = FALSE, color = \"gray50\") +   geom_ribbon(aes(ymin = fc_q0.05, ymax = fc_q0.95, fill = geo_value),               alpha = 0.4) +   geom_line(aes(y = fc_point)) + geom_point(aes(y = fc_point), size = 0.5) +   geom_vline(aes(xintercept = time_value), linetype = 2, alpha = 0.5) +   facet_wrap(~geo_value, scales = \"free_y\", ncol = 3) +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %y\") +   labs(title = \"Finalized data\", x = \"Date\",         y = \"Reported COVID-19 case rates\") +   theme(legend.position = \"none\") ggplot(can_fc %>% filter(as_of),         aes(x = target_date, group = time_value)) +   coord_cartesian(xlim = lubridate::ymd(c(\"2020-12-01\", NA))) +   geom_line(data = can_latest, aes(x = time_value, y = cr_7dav),             inherit.aes = FALSE, color = \"gray50\") +   geom_ribbon(aes(ymin = fc_q0.05, ymax = fc_q0.95, fill = geo_value),               alpha = 0.4) +   geom_line(aes(y = fc_point)) + geom_point(aes(y = fc_point), size = 0.5) +   geom_vline(aes(xintercept = time_value), linetype = 2, alpha = 0.5) +   facet_wrap(~ geo_value, scales = \"free_y\", ncol = 3) +   scale_x_date(minor_breaks = \"month\", date_labels = \"%b %y\") +   labs(title = \"Properly versioned data\", x = \"Date\",         y = \"Reported COVID-19 case rates\") +   theme(legend.position = \"none\")"},{"path":"https://cmu-delphi.github.io/epipredict/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jacob Bien. Author. Daniel McDonald. Author. Ryan Tibshirani. Author, maintainer.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bien J, McDonald D, Tibshirani R (2022). epipredict: Basic epidemiology forecasting methods. https://github.com/cmu-delphi/epipredict/, https://cmu-delphi.github.io/epiprocess.","code":"@Manual{,   title = {epipredict: Basic epidemiology forecasting methods},   author = {Jacob Bien and Daniel McDonald and Ryan Tibshirani},   year = {2022},   note = {https://github.com/cmu-delphi/epipredict/, https://cmu-delphi.github.io/epiprocess}, }"},{"path":"https://cmu-delphi.github.io/epipredict/index.html","id":"epipredict","dir":"","previous_headings":"","what":"Basic epidemiology forecasting methods","title":"Basic epidemiology forecasting methods","text":"Note: package currently development likely work expected.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Basic epidemiology forecasting methods","text":"can install development version epipredict GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"cmu-delphi/epipredict\")"},{"path":"https://cmu-delphi.github.io/epipredict/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Basic epidemiology forecasting methods","text":"can view documentation main branch https://cmu-delphi.github.io/epipredict.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/index.html","id":"goals-for-epipredict","dir":"","previous_headings":"","what":"Goals for epipredict","title":"Basic epidemiology forecasting methods","text":"hope provide: Baseline flat-line forecaster Autoregressive forecaster Autoregressive classifier Preprocessor: things data model training Trainer: train model data, resulting fitted model object Predictor: make predictions, using fitted model object Postprocessor: things predictions returning Target audience: Basic. data, calls forecaster default arguments. Intermediate. Wants examine changes arguments, take advantage built flexibility. Advanced. Wants write forecasters. Maybe willing build components write. Advanced user find task relatively easy (’ll show ). Example: quiet period, user decides want first predict whether surge occur, say using variant information GISAID. surging locations, want train AR model using past surges location. Everywhere else, predict flat line. able lines code. Delphi’s forecasts produced/evaluated way now, code base scattered evolving. want consolidate, generalize, simplify allow others benefit well. basic framework allow something like following. feel familiar anyone working R+tidyverse. Simple linear autoregressive model scaling (modular) run epi_df one line. hypothetical example first classifying, fitting different models also fit framework. isn’t far current production models.","code":"my_fcaster = new_epi_predictor() %>%   add_preprocessor(scaler, var = cases, by = pop) %>%   add_preprocessor(lagger, var = dv_cli, lags = c(0, 7, 14)) %>%   add_trainer(lm) %>%   add_predictor(lm.predict) %>%   add_postprocessor(scaler, by = 1/pop) my_fcaster(lead(cases, 7) ~ ., epi_df, key_vars, time_vars)"},{"path":"https://cmu-delphi.github.io/epipredict/index.html","id":"why-doesnt-this-exist","dir":"","previous_headings":"Goals for epipredict","what":"Why doesn’t this exist","title":"Basic epidemiology forecasting methods","text":"Closest neighbor {fable}. want major downsides: Small modifications hard (e.g. can’t “just use” glmnet instead lm) AR model. “iterative” forecasting, bad epidemiology. Much better simple models use “direct” forecasting. epi tasks, dramatically -cover. Layering possible/natural Can’t use methods aren’t already implemented. forecasts can’t produced fable. However: developers behind fable wrote package called fabletools powers model creation (based R6). can almost certainly borrow technology lever .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/index.html","id":"what-this-isnt","dir":"","previous_headings":"Goals for epipredict","what":"What this isn’t","title":"Basic epidemiology forecasting methods","text":"framework SIR models. intend create simple versions, advanced models—use variants, hospitalizations, different types immunity, age stratification, etc.—compartmentalized way (though see pypm). types models also better scenario modeling short term forecasts unless quite complicated.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_epi_recipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Add an epi_recipe to a workflow — add_epi_recipe","title":"Add an epi_recipe to a workflow — add_epi_recipe","text":"Add epi_recipe workflow","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_epi_recipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add an epi_recipe to a workflow — add_epi_recipe","text":"","code":"add_epi_recipe(x, recipe, ..., blueprint = default_epi_recipe_blueprint())"},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_epi_recipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add an epi_recipe to a workflow — add_epi_recipe","text":"x workflow epi_workflow recipe recipe created using recipes::recipe() ... used. blueprint hardhat blueprint used fine tuning preprocessing. default_epi_recipe_blueprint() used. Note preprocessing done separate preprocessing might done automatically underlying model.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_epi_recipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add an epi_recipe to a workflow — add_epi_recipe","text":"x, updated new recipe preprocessor.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_epi_recipe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add an epi_recipe to a workflow — add_epi_recipe","text":"behaviour workflows::add_recipe() sets different default blueprint automatically handle epiprocess::epi_df data.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/reference/add_epi_recipe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add an epi_recipe to a workflow — add_epi_recipe","text":"","code":"library(epiprocess) #>  #> Attaching package: ‘epiprocess’ #> The following object is masked from ‘package:stats’: #>  #>     filter library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(recipes) #>  #> Attaching package: ‘recipes’ #> The following object is masked from ‘package:stats’: #>  #>     step  jhu <- jhu_csse_daily_subset %>%   filter(time_value > \"2021-08-01\") %>%   select(geo_value:death_rate_7d_av) %>%   rename(case_rate = case_rate_7d_av, death_rate = death_rate_7d_av)  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_naomit(all_predictors()) %>%   step_naomit(all_outcomes(), skip = TRUE)  workflow <- epi_workflow() %>%   add_epi_recipe(r)  workflow #> ══ Workflow ════════════════════════════════════════════════════════════════════ #> Preprocessor: Recipe #> Model: None #>  #> ── Preprocessor ──────────────────────────────────────────────────────────────── #> 5 Recipe Steps #>  #> • step_epi_shift() #> • step_epi_shift() #> • step_epi_shift() #> • step_naomit() #> • step_naomit()"},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_args_list.html","id":null,"dir":"Reference","previous_headings":"","what":"ARX forecaster argument constructor — arx_args_list","title":"ARX forecaster argument constructor — arx_args_list","text":"Constructs list arguments arx_forecaster().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_args_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ARX forecaster argument constructor — arx_args_list","text":"","code":"arx_args_list(   lags = c(0, 7, 14),   ahead = 7,   min_train_window = 20,   levels = c(0.05, 0.95),   intercept = TRUE,   symmetrize = TRUE,   nonneg = TRUE,   quantile_by_key = FALSE )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_args_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ARX forecaster argument constructor — arx_args_list","text":"lags Vector List. Positive integers enumerating lags use autoregressive-type models. ahead Integer. Number time steps ahead forecast date forecasts produced. min_train_window Integer. minimal amount training data needed produce forecast. smaller, forecaster return NA predictions. levels Vector NULL. vector probabilities produce prediction intervals. created computing quantiles training residuals. NULL value result point forecasts . intercept Logical. default TRUE includes intercept forecaster. symmetrize Logical. default TRUE calculates symmetric prediction intervals. nonneg Logical. default TRUE enforeces nonnegative predictions hard-thresholding 0. quantile_by_key currently implemented","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_args_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ARX forecaster argument constructor — arx_args_list","text":"list containing updated parameter choices.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_args_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ARX forecaster argument constructor — arx_args_list","text":"","code":"arx_args_list() #> $lags #> [1]  0  7 14 #>  #> $ahead #> [1] 7 #>  #> $min_train_window #> [1] 20 #>  #> $levels #> [1] 0.05 0.95 #>  #> $intercept #> [1] TRUE #>  #> $symmetrize #> [1] TRUE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>  arx_args_list(symmetrize = FALSE) #> $lags #> [1]  0  7 14 #>  #> $ahead #> [1] 7 #>  #> $min_train_window #> [1] 20 #>  #> $levels #> [1] 0.05 0.95 #>  #> $intercept #> [1] TRUE #>  #> $symmetrize #> [1] FALSE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>  arx_args_list(levels = c(.1, .3, .7, .9), min_train_window = 120) #> $lags #> [1]  0  7 14 #>  #> $ahead #> [1] 7 #>  #> $min_train_window #> [1] 120 #>  #> $levels #> [1] 0.1 0.3 0.7 0.9 #>  #> $intercept #> [1] TRUE #>  #> $symmetrize #> [1] TRUE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>"},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_forecaster.html","id":null,"dir":"Reference","previous_headings":"","what":"AR forecaster with optional covariates — arx_forecaster","title":"AR forecaster with optional covariates — arx_forecaster","text":"AR forecaster optional covariates","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_forecaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AR forecaster with optional covariates — arx_forecaster","text":"","code":"arx_forecaster(x, y, key_vars, time_value, args = arx_args_list())"},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_forecaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AR forecaster with optional covariates — arx_forecaster","text":"x Covariates. Allowed missing (resulting AR y). y Response. key_vars Factor(s). prediction made unique combination. time_value time value associated row measurements. args Additional arguments specifying forecasting task. Created calling arx_args_list().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/arx_forecaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"AR forecaster with optional covariates — arx_forecaster","text":"data frame point (optionally interval) forecasts single ahead (unique horizon) unique combination key_vars.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/assign_arg_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign argument list to inside an environment — assign_arg_list","title":"Assign argument list to inside an environment — assign_arg_list","text":"function similar attach() without need detach. Calling beginning forecaster makes members arg_list available inside forecaster ugly args$member syntax.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/assign_arg_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign argument list to inside an environment — assign_arg_list","text":"","code":"assign_arg_list(l, env = parent.frame())"},{"path":"https://cmu-delphi.github.io/epipredict/reference/assign_arg_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign argument list to inside an environment — assign_arg_list","text":"l List named arguments. env environment args assigned. default goes calling environment.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/assign_arg_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign argument list to inside an environment — assign_arg_list","text":"Nothing returned. Called side effects.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/assign_arg_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assign argument list to inside an environment — assign_arg_list","text":"","code":"if (FALSE) {   rm(list = ls())   l <- list(a=1, b=c(12, 10), ff = function() -5)   assign_arg_list(l)   a }"},{"path":"https://cmu-delphi.github.io/epipredict/reference/case_death_rate_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset of JHU daily state cases and deaths — case_death_rate_subset","title":"Subset of JHU daily state cases and deaths — case_death_rate_subset","text":"data source confirmed COVID-19 cases deaths based reports made available Center Systems Science Engineering Johns Hopkins University. example data ranges Dec 31, 2020 Dec 31, 2021, includes states.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/case_death_rate_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset of JHU daily state cases and deaths — case_death_rate_subset","text":"","code":"case_death_rate_subset"},{"path":"https://cmu-delphi.github.io/epipredict/reference/case_death_rate_subset.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Subset of JHU daily state cases and deaths — case_death_rate_subset","text":"tibble 20,496 rows 4 variables: geo_value geographic value associated row measurements. time_value time value associated row measurements. case_rate 7-day average signal number new confirmed COVID-19 cases per 100,000 population, daily death_rate 7-day average signal number new confirmed deaths due COVID-19 per 100,000 population, daily","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/case_death_rate_subset.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Subset of JHU daily state cases and deaths — case_death_rate_subset","text":"object contains modified part COVID-19 Data Repository Center Systems Science Engineering (CSSE) Johns Hopkins University republished COVIDcast Epidata API. data set licensed terms Creative Commons Attribution 4.0 International license Johns Hopkins University behalf Center Systems Science Engineering. Copyright Johns Hopkins University 2020. Modifications: COVIDcast Epidata API: signals taken directly JHU CSSE COVID-19 GitHub repository without changes. 7-day average signals computed Delphi calculating moving averages preceding 7 days, signal June 7 average underlying data June 1 7, inclusive.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/create_lags_and_leads.html","id":null,"dir":"Reference","previous_headings":"","what":"Create lags and leads of predictors and response — create_lags_and_leads","title":"Create lags and leads of predictors and response — create_lags_and_leads","text":"Create lags leads predictors response","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/create_lags_and_leads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create lags and leads of predictors and response — create_lags_and_leads","text":"","code":"create_lags_and_leads(x, y, xy_lags, y_leads, time_value, key_vars = NULL)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/create_lags_and_leads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create lags and leads of predictors and response — create_lags_and_leads","text":"x Data frame matrix. Predictor variables. May missing. y Response vector. Typical usage \"lead\" y number steps forward prediction horizon (ahead). xy_lags Vector list. vector, lags apply column x y. list, must length ncol(x)+1 component apply requisite predictor. NULL list element remove variable completely result. Negative values \"lead\" variable. y_leads Scalar vector. scalar, \"lead\" y amount. vector produce multiple columns y useful model. Negative values \"lag\" variable. time_value Vector time values data observed key_vars Factors representing different groups. May NULL (default).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/create_lags_and_leads.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create lags and leads of predictors and response — create_lags_and_leads","text":"data.frame.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/create_lags_and_leads.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create lags and leads of predictors and response — create_lags_and_leads","text":"","code":"x <- 1:20 y <- -20:-1 time_value <- c(1:18, 20, 21) create_lags_and_leads(x, y, c(1, 2), 1, time_value) #> # A tibble: 24 × 7 #>    keys  time_value    y1    x1    x2    x3    x4 #>    <chr>      <dbl> <int> <int> <int> <int> <int> #>  1 empty          0   -20    NA    NA    NA    NA #>  2 empty          1   -19    NA    NA    NA    NA #>  3 empty          2   -18     1    NA   -20    NA #>  4 empty          3   -17     2     1   -19   -20 #>  5 empty          4   -16     3     2   -18   -19 #>  6 empty          5   -15     4     3   -17   -18 #>  7 empty          6   -14     5     4   -16   -17 #>  8 empty          7   -13     6     5   -15   -16 #>  9 empty          8   -12     7     6   -14   -15 #> 10 empty          9   -11     8     7   -13   -14 #> # … with 14 more rows create_lags_and_leads(x, y, list(c(1, 2), 1), 1, time_value) #> # A tibble: 24 × 6 #>    keys  time_value    y1    x1    x2    x3 #>    <chr>      <dbl> <int> <int> <int> <int> #>  1 empty          0   -20    NA    NA    NA #>  2 empty          1   -19    NA    NA    NA #>  3 empty          2   -18     1    NA   -20 #>  4 empty          3   -17     2     1   -19 #>  5 empty          4   -16     3     2   -18 #>  6 empty          5   -15     4     3   -17 #>  7 empty          6   -14     5     4   -16 #>  8 empty          7   -13     6     5   -15 #>  9 empty          8   -12     7     6   -14 #> 10 empty          9   -11     8     7   -13 #> # … with 14 more rows create_lags_and_leads(x, y, list(c(-1, 1), NULL), 1, time_value) #> # A tibble: 23 × 5 #>    keys  time_value    y1    x1    x2 #>    <chr>      <dbl> <int> <int> <int> #>  1 empty          0   -20     1    NA #>  2 empty          1   -19     2    NA #>  3 empty          2   -18     3     1 #>  4 empty          3   -17     4     2 #>  5 empty          4   -16     5     3 #>  6 empty          5   -15     6     4 #>  7 empty          6   -14     7     5 #>  8 empty          7   -13     8     6 #>  9 empty          8   -12     9     7 #> 10 empty          9   -11    10     8 #> # … with 13 more rows create_lags_and_leads(x, y, c(1, 2), c(0, 1), time_value) #> # A tibble: 24 × 8 #>    keys  time_value    y1    y2    x1    x2    x3    x4 #>    <chr>      <dbl> <int> <int> <int> <int> <int> <int> #>  1 empty          1   -20   -19    NA    NA    NA    NA #>  2 empty          2   -19   -18     1    NA   -20    NA #>  3 empty          3   -18   -17     2     1   -19   -20 #>  4 empty          4   -17   -16     3     2   -18   -19 #>  5 empty          5   -16   -15     4     3   -17   -18 #>  6 empty          6   -15   -14     5     4   -16   -17 #>  7 empty          7   -14   -13     6     5   -15   -16 #>  8 empty          8   -13   -12     7     6   -14   -15 #>  9 empty          9   -12   -11     8     7   -13   -14 #> 10 empty         10   -11   -10     9     8   -12   -13 #> # … with 14 more rows"},{"path":"https://cmu-delphi.github.io/epipredict/reference/default_epi_recipe_blueprint.html","id":null,"dir":"Reference","previous_headings":"","what":"Recipe blueprint that accounts for epi_df panel data — default_epi_recipe_blueprint","title":"Recipe blueprint that accounts for epi_df panel data — default_epi_recipe_blueprint","text":"Used simplicity. See hardhat::default_recipe_blueprint() details.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/default_epi_recipe_blueprint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recipe blueprint that accounts for epi_df panel data — default_epi_recipe_blueprint","text":"","code":"default_epi_recipe_blueprint(   intercept = FALSE,   allow_novel_levels = FALSE,   fresh = TRUE,   bake_dependent_roles = c(\"time_value\", \"geo_value\", \"key\", \"raw\"),   composition = \"tibble\" )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/default_epi_recipe_blueprint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recipe blueprint that accounts for epi_df panel data — default_epi_recipe_blueprint","text":"intercept logical. intercept included processed data? information used process function mold forge function list. allow_novel_levels logical. novel factor levels allowed prediction time? information used clean function forge function list, passed scream(). fresh already trained operations re-trained prep() called? bake_dependent_roles character vector recipes column \"roles\" specifying roles required recipes::bake() new data. \"predictor\" \"outcome\", predictors always required outcomes handled outcomes argument forge(). Typically, non-standard roles (\"id\" \"case_weights\") required bake() new data. Unless specified bake_dependent_roles, non-standard role columns excluded checks done forge() validate column structure new_data, passed bake() even existed new_data, returned forge()$extras$roles slot. See documentation recipes::add_role() information roles. composition Either \"tibble\", \"matrix\", \"dgCMatrix\" format processed predictors. \"matrix\" \"dgCMatrix\" chosen, predictors must numeric preprocessing method applied; otherwise error thrown.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/default_epi_recipe_blueprint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recipe blueprint that accounts for epi_df panel data — default_epi_recipe_blueprint","text":"recipe blueprint.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/default_epi_recipe_blueprint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Recipe blueprint that accounts for epi_df panel data — default_epi_recipe_blueprint","text":"bake_dependent_roles automatically set epi_df defaults.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/df_mat_mul.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiply columns of a data.frame by a matrix — df_mat_mul","title":"Multiply columns of a data.frame by a matrix — df_mat_mul","text":"Multiply columns data.frame matrix","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/df_mat_mul.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiply columns of a data.frame by a matrix — df_mat_mul","text":"","code":"df_mat_mul(dat, mat, out_names = \"out\", ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/df_mat_mul.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiply columns of a data.frame by a matrix — df_mat_mul","text":"dat data.frame mat matrix out_names Character vector. Creates names resulting columns multiplication. scalar, treated prefix remaining columns numbered sequentially. ... <tidy-select> One unquoted expressions separated commas. Variable names can used positions data frame, expressions like x:y can used select range variables.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/df_mat_mul.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiply columns of a data.frame by a matrix — df_mat_mul","text":"data.frame new columns right. Original columns removed.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/df_mat_mul.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiply columns of a data.frame by a matrix — df_mat_mul","text":"","code":"df <- data.frame(matrix(1:200, ncol = 10)) mat <- matrix(1:10, ncol = 2) df_mat_mul(df, mat, \"z\", dplyr::num_range(\"X\", 2:6)) #>    X1  X7  X8  X9 X10   z1   z2 #> 1   1 121 141 161 181 1115 2640 #> 2   2 122 142 162 182 1130 2680 #> 3   3 123 143 163 183 1145 2720 #> 4   4 124 144 164 184 1160 2760 #> 5   5 125 145 165 185 1175 2800 #> 6   6 126 146 166 186 1190 2840 #> 7   7 127 147 167 187 1205 2880 #> 8   8 128 148 168 188 1220 2920 #> 9   9 129 149 169 189 1235 2960 #> 10 10 130 150 170 190 1250 3000 #> 11 11 131 151 171 191 1265 3040 #> 12 12 132 152 172 192 1280 3080 #> 13 13 133 153 173 193 1295 3120 #> 14 14 134 154 174 194 1310 3160 #> 15 15 135 155 175 195 1325 3200 #> 16 16 136 156 176 196 1340 3240 #> 17 17 137 157 177 197 1355 3280 #> 18 18 138 158 178 198 1370 3320 #> 19 19 139 159 179 199 1385 3360 #> 20 20 140 160 180 200 1400 3400"},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_keys.html","id":null,"dir":"Reference","previous_headings":"","what":"Grab any keys associated to an epi_df — epi_keys","title":"Grab any keys associated to an epi_df — epi_keys","text":"Grab keys associated epi_df","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_keys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grab any keys associated to an epi_df — epi_keys","text":"","code":"epi_keys(x)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_keys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grab any keys associated to an epi_df — epi_keys","text":"x data.frame, tibble, epi_df","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_keys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Grab any keys associated to an epi_df — epi_keys","text":"epi_df, returns \"keys\". Otherwise NULL","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_recipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a epi_recipe for preprocessing data — epi_recipe","title":"Create a epi_recipe for preprocessing data — epi_recipe","text":"recipe description steps applied data set order prepare data analysis. loose wrapper around recipes::recipe() properly handle additional columns present epi_df","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_recipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a epi_recipe for preprocessing data — epi_recipe","text":"","code":"epi_recipe(x, ...)  # S3 method for default epi_recipe(x, ...)  # S3 method for epi_df epi_recipe(x, formula = NULL, ..., vars = NULL, roles = NULL)  # S3 method for formula epi_recipe(formula, data, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_recipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a epi_recipe for preprocessing data — epi_recipe","text":"x, data data frame, tibble, epi_df template data set (see ). always coerced first row avoid memory issues ... arguments passed methods (currently used). formula model formula. -line functions used (e.g. log(x), x:y, etc.) minus signs allowed. types transformations enacted using step functions package. Dots allowed simple multivariate outcome terms (.e. need cbind; see Examples). vars character string column names corresponding variables used context (see ) roles character string (length vars) describes single role variable take. value anything common roles \"outcome\", \"predictor\", \"time_value\", \"geo_value\"","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_recipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a epi_recipe for preprocessing data — epi_recipe","text":"object class recipe sub-objects: var_info tibble containing information original data set columns term_info tibble contains current set terms data set. initially defaults data contained var_info. steps list step  check objects define sequence preprocessing operations applied data. default value NULL template tibble data. initialized data given data argument can different recipe trained.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_recipe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a epi_recipe for preprocessing data — epi_recipe","text":"","code":"library(epiprocess) library(dplyr) library(recipes)  jhu <- jhu_csse_daily_subset %>%   filter(time_value > \"2021-08-01\") %>%   select(geo_value:death_rate_7d_av) %>%   rename(case_rate = case_rate_7d_av, death_rate = death_rate_7d_av)  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_naomit(all_predictors()) %>%   # below, `skip` means we don't do this at predict time   step_naomit(all_outcomes(), skip = TRUE)  r #> Recipe #>  #> Inputs: #>  #>        role #variables #>   geo_value          1 #>         raw          2 #>  time_value          1 #>  #> Operations: #>  #> $terms #> <list_of<quosure>> #>  #> [[1]] #> <quosure> #> expr: ^death_rate #> env:  0x55cc9cf9a038 #>  #>  #> $role #> [1] \"predictor\" #>  #> $trained #> [1] FALSE #>  #> $shift #> [1]   0  -7 -14 #>  #> $prefix #> [1] \"lag_\" #>  #> $default #> [1] NA #>  #> $keys #> [1] \"time_value\" \"geo_value\"  #>  #> $columns #> NULL #>  #> $skip #> [1] FALSE #>  #> $id #> [1] \"epi_lag_VTUUg\" #>  #> attr(,\"class\") #> [1] \"step_epi_shift\" \"step\"           #> $terms #> <list_of<quosure>> #>  #> [[1]] #> <quosure> #> expr: ^death_rate #> env:  0x55cc9cf99f90 #>  #>  #> $role #> [1] \"outcome\" #>  #> $trained #> [1] FALSE #>  #> $shift #> [1] 7 #>  #> $prefix #> [1] \"ahead_\" #>  #> $default #> [1] NA #>  #> $keys #> [1] \"time_value\" \"geo_value\"  #>  #> $columns #> NULL #>  #> $skip #> [1] FALSE #>  #> $id #> [1] \"epi_ahead_YvcIE\" #>  #> attr(,\"class\") #> [1] \"step_epi_shift\" \"step\"           #> $terms #> <list_of<quosure>> #>  #> [[1]] #> <quosure> #> expr: ^case_rate #> env:  0x55cc9cf99ee8 #>  #>  #> $role #> [1] \"predictor\" #>  #> $trained #> [1] FALSE #>  #> $shift #> [1]   0  -7 -14 #>  #> $prefix #> [1] \"lag_\" #>  #> $default #> [1] NA #>  #> $keys #> [1] \"time_value\" \"geo_value\"  #>  #> $columns #> NULL #>  #> $skip #> [1] FALSE #>  #> $id #> [1] \"epi_lag_sMn5m\" #>  #> attr(,\"class\") #> [1] \"step_epi_shift\" \"step\"           #> Removing rows with NA values in all_predictors() #> Removing rows with NA values in all_outcomes()"},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_shift.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift predictors while maintaining grouping and time_value ordering — epi_shift","title":"Shift predictors while maintaining grouping and time_value ordering — epi_shift","text":"lower-level function. performs error checking.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift predictors while maintaining grouping and time_value ordering — epi_shift","text":"","code":"epi_shift(x, lags, time_value, keys = NULL, out_name = \"x\")"},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift predictors while maintaining grouping and time_value ordering — epi_shift","text":"x Data frame. Variables lag lags List. list element vector lags. Negative values produce leads. list length number columns x. time_value Vector. length x giving time stamps. keys Data frame, vector, NULL. Additional grouping vars. out_name Chr. output list use prefix.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_shift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shift predictors while maintaining grouping and time_value ordering — epi_shift","text":"list tibbles","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an epi_workflow — epi_workflow","title":"Create an epi_workflow — epi_workflow","text":"container object unifies preprocessing, fitting, prediction, postprocessing predictive modeling epidemiological data. extends functionality workflows::workflow() handle typical panel data structures found field. extension handled completely internally, invisible user. intents purposes, operates exactly like workflows::workflow(). details numerous examples, see .","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an epi_workflow — epi_workflow","text":"","code":"epi_workflow(preprocessor = NULL, spec = NULL)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an epi_workflow — epi_workflow","text":"preprocessor optional preprocessor add workflow. One : formula, passed add_formula(). recipe, passed add_recipe(). workflow_variables() object, passed add_variables(). spec optional parsnip model specification add workflow. Passed add_model().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an epi_workflow — epi_workflow","text":"new epi_workflow object.","code":""},{"path":[]},{"path":"https://cmu-delphi.github.io/epipredict/reference/epi_workflow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an epi_workflow — epi_workflow","text":"","code":"library(epiprocess) library(dplyr) library(parsnip) library(recipes)  jhu <- jhu_csse_daily_subset %>%   filter(time_value > \"2021-08-01\") %>%   select(geo_value:death_rate_7d_av) %>%   rename(case_rate = case_rate_7d_av, death_rate = death_rate_7d_av)  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_naomit(all_predictors()) %>%   step_naomit(all_outcomes(), skip = TRUE)  wf <- epi_workflow(r, linear_reg())  wf #> ══ Workflow ════════════════════════════════════════════════════════════════════ #> Preprocessor: Recipe #> Model: linear_reg() #>  #> ── Preprocessor ──────────────────────────────────────────────────────────────── #> 5 Recipe Steps #>  #> • step_epi_shift() #> • step_epi_shift() #> • step_epi_shift() #> • step_naomit() #> • step_naomit() #>  #> ── Model ─────────────────────────────────────────────────────────────────────── #> Linear Regression Model Specification (regression) #>  #> Computational engine: lm  #>"},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine the precision of a number — get_precision","title":"Determine the precision of a number — get_precision","text":"Determine precision number, number digits past decimal point.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine the precision of a number — get_precision","text":"","code":"get_precision(x, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine the precision of a number — get_precision","text":"x numeric vector ... Ignore ","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine the precision of a number — get_precision","text":"vector integers, number digits (last non-zero digit) past decimal point.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_precision.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Determine the precision of a number — get_precision","text":"number expressed scientific notation, take number digits","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_test_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Get test data for prediction based on longest lag period — get_test_data","title":"Get test data for prediction based on longest lag period — get_test_data","text":"Based longest lag period recipe, get_test_data() creates tibble epiprocess::epi_df format columns geo_value, time_value variables original dataset, used create test data.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_test_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get test data for prediction based on longest lag period — get_test_data","text":"","code":"get_test_data(recipe, x)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_test_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get test data for prediction based on longest lag period — get_test_data","text":"recipe recipe object. step added sequence operations recipe. x data frame, tibble, epi_df data set.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_test_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get test data for prediction based on longest lag period — get_test_data","text":"tibble columns geo_value, time_valueand variables original dataset.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/get_test_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get test data for prediction based on longest lag period — get_test_data","text":"","code":"# create recipe  rec <- epi_recipe(case_death_rate_subset) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14))  get_test_data(recipe = rec, x = case_death_rate_subset) #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to max; returning -Inf #> An `epi_df` object, with metadata: #> * geo_type  = state #> * time_type = day #> * as_of     = 2022-05-31 19:08:25 #>  #> # A tibble: 0 × 4 #> # Groups:   geo_value [0] #> # … with 4 variables: geo_value <chr>, time_value <date>, case_rate <dbl>, #> #   death_rate <dbl>"},{"path":"https://cmu-delphi.github.io/epipredict/reference/grab_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the names from a data frame via tidy select — grab_names","title":"Get the names from a data frame via tidy select — grab_names","text":"Given data.frame, use <tidy-select> syntax choose variables. Return names variables","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/grab_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the names from a data frame via tidy select — grab_names","text":"","code":"grab_names(dat, ...)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/grab_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the names from a data frame via tidy select — grab_names","text":"dat data.frame ... <tidy-select> One unquoted expressions separated commas. Variable names can used positions data frame, expressions like x:y can used select range variables.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/grab_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the names from a data frame via tidy select — grab_names","text":"character vector","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/grab_names.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the names from a data frame via tidy select — grab_names","text":"internal function, checks performed.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/grab_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the names from a data frame via tidy select — grab_names","text":"","code":"df <- data.frame(a = 1, b = 2, cc = rep(NA, 3)) grab_names(df, dplyr::starts_with(\"c\")) #> [1] \"cc\""},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_recipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for epi_recipe — is_epi_recipe","title":"Test for epi_recipe — is_epi_recipe","text":"Test epi_recipe","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_recipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for epi_recipe — is_epi_recipe","text":"","code":"is_epi_recipe(x)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_recipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for epi_recipe — is_epi_recipe","text":"x object.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_recipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for epi_recipe — is_epi_recipe","text":"TRUE object inherits epi_recipe.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for an epi_workflow — is_epi_workflow","title":"Test for an epi_workflow — is_epi_workflow","text":"Test epi_workflow","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for an epi_workflow — is_epi_workflow","text":"","code":"is_epi_workflow(x)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for an epi_workflow — is_epi_workflow","text":"x object.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/is_epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for an epi_workflow — is_epi_workflow","text":"TRUE object inherits epi_workflow.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/knn_iteraive_ar_args_list.html","id":null,"dir":"Reference","previous_headings":"","what":"KNN enhanced iterative AR forecaster argument constructor — knn_iteraive_ar_args_list","title":"KNN enhanced iterative AR forecaster argument constructor — knn_iteraive_ar_args_list","text":"Constructs list arguments knn_iteraive_ar_forecaster().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/knn_iteraive_ar_args_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"KNN enhanced iterative AR forecaster argument constructor — knn_iteraive_ar_args_list","text":"","code":"knn_iteraive_ar_args_list(   lags = c(0, 7, 14),   query_window_len = 50,   topK = 500,   ahead = 7,   min_train_window = 20,   levels = c(0.05, 0.95),   intercept = TRUE,   symmetrize = TRUE,   nonneg = TRUE,   quantile_by_key = FALSE,   update_model = TRUE )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/knn_iteraive_ar_args_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"KNN enhanced iterative AR forecaster argument constructor — knn_iteraive_ar_args_list","text":"lags Vector List. Positive integers enumerating lags use autoregressive-type models. query_window_len Integer. Length query window KNN searching. topK Integer. Number similar training samples. ahead Integer. Number time steps ahead forecast date forecasts produced. min_train_window Integer. minimal amount training data needed produce forecast. smaller, forecaster return NA predictions. levels Vector NULL. vector probabilities produce prediction intervals. created computing quantiles training residuals. NULL value result point forecasts . intercept Logical. default TRUE includes intercept forecaster. symmetrize Logical. default TRUE calculates symmetric prediction intervals. nonneg Logical. default TRUE enforeces nonnegative predictions hard-thresholding 0. quantile_by_key currently implemented update_model Logical. default TRUE updates one-step ahead model every time iterative forecasting strategy.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/knn_iteraive_ar_args_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"KNN enhanced iterative AR forecaster argument constructor — knn_iteraive_ar_args_list","text":"list containing updated parameter choices.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/knn_iteraive_ar_args_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"KNN enhanced iterative AR forecaster argument constructor — knn_iteraive_ar_args_list","text":"","code":"arx_args_list() #> $lags #> [1]  0  7 14 #>  #> $ahead #> [1] 7 #>  #> $min_train_window #> [1] 20 #>  #> $levels #> [1] 0.05 0.95 #>  #> $intercept #> [1] TRUE #>  #> $symmetrize #> [1] TRUE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>  arx_args_list(symmetrize = FALSE) #> $lags #> [1]  0  7 14 #>  #> $ahead #> [1] 7 #>  #> $min_train_window #> [1] 20 #>  #> $levels #> [1] 0.05 0.95 #>  #> $intercept #> [1] TRUE #>  #> $symmetrize #> [1] FALSE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>  arx_args_list(levels = c(.1, .3, .7, .9), min_train_window = 120) #> $lags #> [1]  0  7 14 #>  #> $ahead #> [1] 7 #>  #> $min_train_window #> [1] 120 #>  #> $levels #> [1] 0.1 0.3 0.7 0.9 #>  #> $intercept #> [1] TRUE #>  #> $symmetrize #> [1] TRUE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>"},{"path":"https://cmu-delphi.github.io/epipredict/reference/knn_iteraive_ar_forecaster.html","id":null,"dir":"Reference","previous_headings":"","what":"KNN enhanced iterative AR forecaster with optional covariates — knn_iteraive_ar_forecaster","title":"KNN enhanced iterative AR forecaster with optional covariates — knn_iteraive_ar_forecaster","text":"KNN enhanced iterative AR forecaster optional covariates","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/knn_iteraive_ar_forecaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"KNN enhanced iterative AR forecaster with optional covariates — knn_iteraive_ar_forecaster","text":"","code":"knn_iteraive_ar_forecaster(   x,   y,   key_vars,   time_value,   args = knn_iteraive_ar_args_list() )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/knn_iteraive_ar_forecaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"KNN enhanced iterative AR forecaster with optional covariates — knn_iteraive_ar_forecaster","text":"x Unused covariates. Must missing (resulting AR y) . y Response. key_vars Factor(s). prediction made unique combination. time_value time value associated row measurements. args Additional arguments specifying forecasting task. Created calling knn_iteraive_ar_args_list().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/knn_iteraive_ar_forecaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"KNN enhanced iterative AR forecaster with optional covariates — knn_iteraive_ar_forecaster","text":"data frame point (optionally interval) forecasts multiple aheads (multiple horizons one specified ahead) unique combination key_vars.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/knnarx_args_list.html","id":null,"dir":"Reference","previous_headings":"","what":"KNN enhanced ARX forecaster argument constructor — knnarx_args_list","title":"KNN enhanced ARX forecaster argument constructor — knnarx_args_list","text":"Constructs list arguments knnarx_forecaster().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/knnarx_args_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"KNN enhanced ARX forecaster argument constructor — knnarx_args_list","text":"","code":"knnarx_args_list(   lags = c(0, 7, 14),   query_window_len = 50,   topK = 500,   ahead = 7,   min_train_window = 20,   levels = c(0.05, 0.95),   intercept = TRUE,   symmetrize = TRUE,   nonneg = TRUE,   quantile_by_key = FALSE )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/knnarx_args_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"KNN enhanced ARX forecaster argument constructor — knnarx_args_list","text":"lags Vector List. Positive integers enumerating lags use autoregressive-type models. query_window_len Integer. Length query window KNN searching. topK Integer. Number similar training samples. ahead Integer. Number time steps ahead forecast date forecasts produced. min_train_window Integer. minimal amount training data needed produce forecast. smaller, forecaster return NA predictions. levels Vector NULL. vector probabilities produce prediction intervals. created computing quantiles training residuals. NULL value result point forecasts . intercept Logical. default TRUE includes intercept forecaster. symmetrize Logical. default TRUE calculates symmetric prediction intervals. nonneg Logical. default TRUE enforeces nonnegative predictions hard-thresholding 0. quantile_by_key currently implemented","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/knnarx_args_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"KNN enhanced ARX forecaster argument constructor — knnarx_args_list","text":"list containing updated parameter choices.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/knnarx_args_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"KNN enhanced ARX forecaster argument constructor — knnarx_args_list","text":"","code":"knnarx_args_list() #> $lags #> [1]  0  7 14 #>  #> $ahead #> [1] 7 #>  #> $query_window_len #> [1] 50 #>  #> $topK #> [1] 500 #>  #> $min_train_window #> [1] 20 #>  #> $levels #> [1] 0.05 0.95 #>  #> $intercept #> [1] TRUE #>  #> $symmetrize #> [1] TRUE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>  knnarx_args_list(symmetrize = FALSE) #> $lags #> [1]  0  7 14 #>  #> $ahead #> [1] 7 #>  #> $query_window_len #> [1] 50 #>  #> $topK #> [1] 500 #>  #> $min_train_window #> [1] 20 #>  #> $levels #> [1] 0.05 0.95 #>  #> $intercept #> [1] TRUE #>  #> $symmetrize #> [1] FALSE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>  knnarx_args_list(levels = c(.1, .3, .7, .9), min_train_window = 120) #> $lags #> [1]  0  7 14 #>  #> $ahead #> [1] 7 #>  #> $query_window_len #> [1] 50 #>  #> $topK #> [1] 500 #>  #> $min_train_window #> [1] 120 #>  #> $levels #> [1] 0.1 0.3 0.7 0.9 #>  #> $intercept #> [1] TRUE #>  #> $symmetrize #> [1] TRUE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>"},{"path":"https://cmu-delphi.github.io/epipredict/reference/knnarx_forecaster.html","id":null,"dir":"Reference","previous_headings":"","what":"KNN enhanced ARX forecaster with optional covariates — knnarx_forecaster","title":"KNN enhanced ARX forecaster with optional covariates — knnarx_forecaster","text":"KNN enhanced ARX forecaster optional covariates","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/knnarx_forecaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"KNN enhanced ARX forecaster with optional covariates — knnarx_forecaster","text":"","code":"knnarx_forecaster(x, y, key_vars, time_value, args = knnarx_args_list())"},{"path":"https://cmu-delphi.github.io/epipredict/reference/knnarx_forecaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"KNN enhanced ARX forecaster with optional covariates — knnarx_forecaster","text":"x Covariates. Allowed missing (resulting AR y). y Response. key_vars Factor(s). prediction made unique combination. time_value time value associated row measurements. args Additional arguments specifying forecasting task. Created calling knnarx_args_list().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/knnarx_forecaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"KNN enhanced ARX forecaster with optional covariates — knnarx_forecaster","text":"data frame point (optionally interval) forecasts single ahead (unique horizon) unique combination key_vars.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://cmu-delphi.github.io/epipredict/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/predict-epi_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict from an epi_workflow — predict-epi_workflow","title":"Predict from an epi_workflow — predict-epi_workflow","text":"predict() method fit epi_workflow object. nice thing predicting epi_workflow : Preprocess new_data using preprocessing method specified workflow created fit. accomplished using hardhat::forge(), apply formula preprocessing call recipes::bake() recipe supplied. Call parsnip::predict.model_fit() using underlying fit parsnip model. Ensure returned object epiprocess::epi_df possible. Specifically, output time_value geo_value columns well prediction.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/predict-epi_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict from an epi_workflow — predict-epi_workflow","text":"","code":"# S3 method for epi_workflow predict(   object,   new_data,   type = NULL,   opts = list(),   forecast_date = NULL,   ... )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/predict-epi_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict from an epi_workflow — predict-epi_workflow","text":"object epi_workflow fit workflows::fit.workflow() new_data data frame containing new predictors preprocess predict type single character value NULL. Possible values \"numeric\", \"class\", \"prob\", \"conf_int\", \"pred_int\", \"quantile\", \"time\", \"hazard\", \"survival\", \"raw\". NULL, predict() choose appropriate value based model's mode. opts list optional arguments underlying predict function used type = \"raw\". list include options model object new data predicted. forecast_date date forecast () made. ... Arguments underlying model's prediction function passed (see opts). parsnip related options can passed, depending value type. Possible arguments : interval: types \"survival\" \"quantile\", interval estimates added, available? Options \"none\" \"confidence\". level: types \"conf_int\", \"pred_int\", \"survival\" parameter tail area intervals (e.g. confidence level confidence intervals). Default value 0.95. std_error: add standard error fit prediction (scale linear predictors) types \"conf_int\" \"pred_int\". Default value FALSE. quantile: quantile(s) quantile regression (implemented yet) time: time(s) hazard survival probability estimates.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/predict-epi_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict from an epi_workflow — predict-epi_workflow","text":"data frame model predictions, many rows new_data . new_data epi_df data frame time_value geo_value columns, result well.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/predict-epi_workflow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict from an epi_workflow — predict-epi_workflow","text":"","code":"library(epiprocess) library(dplyr) library(parsnip) library(recipes)  jhu <- jhu_csse_daily_subset %>%   filter(time_value > \"2021-08-01\") %>%   select(geo_value:death_rate_7d_av) %>%   rename(case_rate = case_rate_7d_av, death_rate = death_rate_7d_av)  r <- epi_recipe(jhu) %>%   step_epi_lag(death_rate, lag = c(0, 7, 14)) %>%   step_epi_ahead(death_rate, ahead = 7) %>%   step_epi_lag(case_rate, lag = c(0, 7, 14)) %>%   step_naomit(all_predictors()) %>%   step_naomit(all_outcomes(), skip = TRUE)  wf <- epi_workflow(r, linear_reg()) %>% fit(jhu) #> Error in UseMethod(\"prep\"): no applicable method for 'prep' applied to an object of class \"c('step_epi_shift', 'step')\"  jhu_latest <- jhu %>%   filter(!is.na(case_rate), !is.na(death_rate)) %>%   group_by(geo_value) %>%   slice_tail(n = 15) %>% # have lags 0,...,14, so need 15 for a complete case   ungroup()  preds <- predict(wf, jhu_latest, forecast_date = \"2021-12-31\") %>%   filter(!is.na(.pred)) #> Error in predict(wf, jhu_latest, forecast_date = \"2021-12-31\"): object 'wf' not found  preds #> Error in eval(expr, envir, enclos): object 'preds' not found"},{"path":"https://cmu-delphi.github.io/epipredict/reference/smooth_arx_args_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Smooth ARX forecaster argument constructor — smooth_arx_args_list","title":"Smooth ARX forecaster argument constructor — smooth_arx_args_list","text":"Constructs list arguments smooth_arx_forecaster().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/smooth_arx_args_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smooth ARX forecaster argument constructor — smooth_arx_args_list","text":"","code":"smooth_arx_args_list(   lags = c(0, 7, 14),   ahead = 1:28,   degree = 4,   kronecker_version = FALSE,   min_train_window = 20,   levels = c(0.05, 0.95),   intercept = TRUE,   symmetrize = TRUE,   nonneg = TRUE,   quantile_by_key = FALSE )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/smooth_arx_args_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smooth ARX forecaster argument constructor — smooth_arx_args_list","text":"lags Vector List. Positive integers enumerating lags use autoregressive-type models. ahead Integer. Number time steps ahead forecast date forecasts produced. degree Integer. Order orthodonal polynomials use smoothing. strictly less length(ahead). kronecker_version Logical. ensure \"seen\" latest ahead value. default FALSE computationally simpler uses less recent data. min_train_window Integer. minimal amount training data needed produce forecast. smaller, forecaster return NA predictions. levels Vector NULL. vector probabilities produce prediction intervals. created computing quantiles training residuals. NULL value result point forecasts . intercept Logical. default TRUE includes intercept forecaster. symmetrize Logical. default TRUE calculates symmetric prediction intervals. nonneg Logical. default TRUE enforeces nonnegative predictions hard-thresholding 0. quantile_by_key currently implemented.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/smooth_arx_args_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Smooth ARX forecaster argument constructor — smooth_arx_args_list","text":"list containing updated parameter choices.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/smooth_arx_args_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Smooth ARX forecaster argument constructor — smooth_arx_args_list","text":"","code":"smooth_arx_args_list() #> $lags #> [1]  0  7 14 #>  #> $ahead #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #> [26] 26 27 28 #>  #> $degree #> [1] 4 #>  #> $min_train_window #> [1] 20 #>  #> $kronecker_version #> [1] FALSE #>  #> $levels #> [1] 0.05 0.95 #>  #> $intercept #> [1] TRUE #>  #> $symmetrize #> [1] TRUE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>  smooth_arx_args_list(symmetrize = FALSE) #> $lags #> [1]  0  7 14 #>  #> $ahead #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #> [26] 26 27 28 #>  #> $degree #> [1] 4 #>  #> $min_train_window #> [1] 20 #>  #> $kronecker_version #> [1] FALSE #>  #> $levels #> [1] 0.05 0.95 #>  #> $intercept #> [1] TRUE #>  #> $symmetrize #> [1] FALSE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>  smooth_arx_args_list(levels = c(.1, .3, .7, .9), min_train_window = 120) #> $lags #> [1]  0  7 14 #>  #> $ahead #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #> [26] 26 27 28 #>  #> $degree #> [1] 4 #>  #> $min_train_window #> [1] 120 #>  #> $kronecker_version #> [1] FALSE #>  #> $levels #> [1] 0.1 0.3 0.7 0.9 #>  #> $intercept #> [1] TRUE #>  #> $symmetrize #> [1] TRUE #>  #> $nonneg #> [1] TRUE #>  #> $max_lags #> [1] 14 #>"},{"path":"https://cmu-delphi.github.io/epipredict/reference/smooth_arx_forecaster.html","id":null,"dir":"Reference","previous_headings":"","what":"Smooth AR forecaster with optional covariates — smooth_arx_forecaster","title":"Smooth AR forecaster with optional covariates — smooth_arx_forecaster","text":"Smooth AR forecaster optional covariates","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/smooth_arx_forecaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smooth AR forecaster with optional covariates — smooth_arx_forecaster","text":"","code":"smooth_arx_forecaster(   x,   y,   key_vars,   time_value,   args = smooth_arx_args_list() )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/smooth_arx_forecaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smooth AR forecaster with optional covariates — smooth_arx_forecaster","text":"x Covariates. Allowed missing (resulting AR y). y Response. key_vars Factor(s). prediction made unique combination. time_value time value associated row measurements. args Additional arguments specifying forecasting task. Created calling smooth_arx_args_list().","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/smooth_arx_forecaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Smooth AR forecaster with optional covariates — smooth_arx_forecaster","text":"data frame point (optionally interval) forecasts across multiple aheads unique combination key_vars.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_ahead.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a leading outcome — step_epi_ahead","title":"Create a leading outcome — step_epi_ahead","text":"step_epi_ahead creates specification recipe step add new columns leading data. Leading data default include NA values lag induced. can removed step_naomit(), may specify alternative filler value default argument. step_epi_lag creates specification recipe step add new columns lagged data. Lagged data default include NA values lag induced. can removed step_naomit(), may specify alternative filler value default argument. step_epi_shift creates specification recipe step add new columns shifted data. shifted data default include NA values shift induced. can removed step_naomit(), may specify alternative filler value default argument.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_ahead.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a leading outcome — step_epi_ahead","text":"","code":"step_epi_ahead(   recipe,   ...,   role = \"outcome\",   trained = FALSE,   ahead = 1,   prefix = \"ahead_\",   default = NA,   keys = epi_keys(recipe),   columns = NULL,   skip = FALSE,   id = rand_id(\"epi_ahead\") )  step_epi_lag(   recipe,   ...,   role = \"predictor\",   trained = FALSE,   lag = 1,   prefix = \"lag_\",   default = NA,   keys = epi_keys(recipe),   columns = NULL,   skip = FALSE,   id = rand_id(\"epi_lag\") )  step_epi_shift(   recipe,   ...,   role,   trained,   shift,   prefix,   default,   keys,   columns,   skip,   id )"},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_ahead.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a leading outcome — step_epi_ahead","text":"recipe recipe object. step added sequence operations recipe. ... One selector functions choose variables step. See selections() details. role model terms created step, analysis role assigned? trained logical indicate quantities preprocessing estimated. ahead vector positive integers. specified column lead value vector. prefix prefix generated column names, default \"ahead_\". default Determines fills empty rows left leading/lagging (defaults NA). keys character vector keys epi_df columns character string variable names populated (eventually) terms argument. skip logical. step skipped recipe baked bake()? operations baked prep() run, operations may able conducted new data (e.g. processing outcome variable(s)). Care taken using skip = TRUE may affect computations subsequent operations. id character string unique step identify . lag vector positive integers. specified column lagged value vector. shift vector integers. specified column shifted value vector.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_ahead.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a leading outcome — step_epi_ahead","text":"updated version recipe new step added sequence existing operations. updated version recipe new step added sequence existing operations. updated version recipe new step added sequence existing operations.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_ahead.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a leading outcome — step_epi_ahead","text":"step assumes data already proper sequential order leading. step assumes data already proper sequential order lagging. step assumes data already proper sequential order shifting.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_ahead.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a leading outcome — step_epi_ahead","text":"","code":"tib <- tibble::tibble(   x = 1:5, y = 1:5,   time_value = seq(as.Date(\"2020-01-01\"), by = 1, length.out = 5),   geo_value = \"ca\"   ) %>% epiprocess::as_epi_df()  library(recipes) epi_recipe(y ~ x, data = tib) %>%   step_epi_lag(x, lag = 2:3) %>%   step_epi_ahead(y, ahead = 1) %>%   prep(tib) %>%   bake(tib) #> Error in UseMethod(\"prep\"): no applicable method for 'prep' applied to an object of class \"c('step_epi_shift', 'step')\""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_naomit.html","id":null,"dir":"Reference","previous_headings":"","what":"Unified NA omission wrapper function for recipes — step_epi_naomit","title":"Unified NA omission wrapper function for recipes — step_epi_naomit","text":"Unified NA omission wrapper function recipes","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_naomit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unified NA omission wrapper function for recipes — step_epi_naomit","text":"","code":"step_epi_naomit(recipe)"},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_naomit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unified NA omission wrapper function for recipes — step_epi_naomit","text":"recipe Recipe used omission steps","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_naomit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unified NA omission wrapper function for recipes — step_epi_naomit","text":"Omits NA's predictors outcomes training time; however, omits associated predictors prediction time avoid losing data.","code":""},{"path":"https://cmu-delphi.github.io/epipredict/reference/step_epi_naomit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unified NA omission wrapper function for recipes — step_epi_naomit","text":"","code":"tibble(geo_value = rep(\"place\",200),            time_value = as.Date(\"2021-01-01\") + 0:199,            case_rate = 1:200,            death_rate = 1:200) %>%  as_epi_df() %>%  recipe() %>%  step_epi_naomit() #> Recipe #>  #> Inputs: #>  #>   4 variables (no declared roles) #>  #> Operations: #>  #> Removing rows with NA values in all_predictors() #> Removing rows with NA values in all_outcomes()"},{"path":"https://cmu-delphi.github.io/epipredict/news/index.html","id":"epipredict-0009000","dir":"Changelog","previous_headings":"","what":"epipredict 0.0.0.9000","title":"epipredict 0.0.0.9000","text":"Publish public easy navigation Two simple forecasters test beds Working vignette","code":""}]
