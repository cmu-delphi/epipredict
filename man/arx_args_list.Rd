% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/arx_forecaster.R
\name{arx_args_list}
\alias{arx_args_list}
\title{ARX forecaster argument constructor}
\usage{
arx_args_list(
  lags = c(0L, 7L, 14L),
  ahead = 7L,
  n_training = Inf,
  forecast_date = NULL,
  target_date = NULL,
  adjust_latency = c("none", "extend_ahead", "extend_lags", "locf"),
  warn_latency = TRUE,
  quantile_levels = c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95),
  symmetrize = TRUE,
  nonneg = TRUE,
  quantile_by_key = character(0L),
  check_enough_data_n = NULL,
  check_enough_data_epi_keys = NULL,
  ...
)
}
\arguments{
\item{lags}{Vector or List. Positive integers enumerating lags to use
in autoregressive-type models (in days). By default, an unnamed list
of lags will be set to correspond to the order of the predictors.}

\item{ahead}{Integer. Number of time steps ahead (in days) of the forecast
date for which forecasts should be produced.}

\item{n_training}{Integer. An upper limit for the number of rows per
key that are used for training
(in the time unit of the \code{epi_df}).}

\item{forecast_date}{Date. The date from which the forecast is occurring.
The default \code{NULL} will determine this automatically from either
\enumerate{
\item the maximum time value for which there's data if there is no latency
adjustment (the default case), or
\item the \code{as_of} date of \code{epi_data} if \code{adjust_latency} is
non-\code{NULL}.
}}

\item{target_date}{Date. The date that is being forecast. The default \code{NULL}
will determine this automatically as \code{forecast_date + ahead}.}

\item{adjust_latency}{Character. One of the \code{method}s of
\code{\link[=step_adjust_latency]{step_adjust_latency()}}, or \code{"none"} (in which case there is no adjustment).
If the \code{forecast_date} is after the last day of data, this determines how
to shift the model to account for this difference. The options are:
\itemize{
\item \code{"none"} the default, assumes the \code{forecast_date} is the last day of data
\item \code{"extend_ahead"}: increase the \code{ahead} by the latency so it's relative to
the last day of data. For example, if the last day of data was 3 days ago,
the ahead becomes \code{ahead+3}.
\item \code{"extend_lags"}: increase the lags so they're relative to the actual
forecast date. For example, if the lags are \code{c(0, 7, 14)} and the last day of
data was 3 days ago, the lags become \code{c(3, 10, 17)}.
}}

\item{warn_latency}{by default, \code{step_adjust_latency} warns the user if the
latency is large. If this is \code{FALSE}, that warning is turned off.}

\item{quantile_levels}{Vector or \code{NULL}. A vector of probabilities to produce
prediction intervals. These are created by computing the quantiles of
training residuals. A \code{NULL} value will result in point forecasts only.}

\item{symmetrize}{Logical. The default \code{TRUE} calculates symmetric prediction
intervals. This argument only applies when residual quantiles are used. It
is not applicable with \code{trainer = quantile_reg()}, for example. Typically, one
would only want non-symmetric quantiles when increasing trajectories are
quite different from decreasing ones, such as a strictly postive variable
near zero.}

\item{nonneg}{Logical. The default \code{TRUE} enforces nonnegative predictions
by hard-thresholding at 0.}

\item{quantile_by_key}{Character vector. Groups residuals by listed keys
before calculating residual quantiles. See the \code{by_key} argument to
\code{\link[=layer_residual_quantiles]{layer_residual_quantiles()}} for more information. The default,
\code{character(0)} performs no grouping. This argument only applies when
residual quantiles are used. It is not applicable with
\code{trainer = quantile_reg()}, for example.}

\item{check_enough_data_n}{Integer. A lower limit for the number of rows per
epi_key that are required for training. If \code{NULL}, this check is ignored.}

\item{check_enough_data_epi_keys}{Character vector. A character vector of
column names on which to group the data and check threshold within each
group. Useful if training per group (for example, per geo_value).}

\item{...}{Space to handle future expansions (unused).}
}
\value{
A list containing updated parameter choices with class \code{arx_flist}.
}
\description{
Constructs a list of arguments for \code{\link[=arx_forecaster]{arx_forecaster()}}.
}
\examples{
arx_args_list()
arx_args_list(symmetrize = FALSE)
arx_args_list(quantile_levels = c(.1, .3, .7, .9), n_training = 120)
}
\seealso{
\code{\link[=arx_forecaster]{arx_forecaster()}}
}
