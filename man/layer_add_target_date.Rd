% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer_add_target_date.R
\name{layer_add_target_date}
\alias{layer_add_target_date}
\title{Post-processing step to add the target date}
\usage{
layer_add_target_date(
  frosting,
  target_date = NULL,
  id = rand_id("add_target_date")
)
}
\arguments{
\item{frosting}{a \code{frosting} postprocessor}

\item{target_date}{The target date to add as a column to the \code{epi_df}. If
there's a forecast date specified upstream (either in a
\code{step_adjust_latency} or in a \code{layer_forecast_date}), then it is the
forecast date plus \code{ahead} (from \code{step_epi_ahead} in the \code{epi_recipe}).
Otherwise, it is the maximum \code{time_value} (from the data used in
pre-processing, fitting the model, and post-processing) plus \code{ahead}, where
\code{ahead} has been specified in preprocessing. The user may override these by
specifying a target date of their own (of the form "yyyy-mm-dd").}

\item{id}{a random id string}
}
\value{
an updated \code{frosting} postprocessor
}
\description{
Post-processing step to add the target date
}
\details{
By default, this function assumes that a value for \code{ahead} has been
specified in a preprocessing step (most likely in \code{step_epi_ahead}). Then,
\code{ahead} is added to the \code{forecast_date} in the test data to get the target
date. \code{forecast_date} itself can be set in 3 ways:
\enumerate{
\item The default \code{forecast_date} is simply the maximum \code{time_value} over every
dataset used (prep, training, and prediction).
\item if \code{step_adjust_latency} is present, it will typically use the training
\code{epi_df}'s \code{as_of}
\item \code{layer_add_forecast_date}, which inherits from 2 if not manually specifed
}
}
\examples{
jhu <- covid_case_death_rates \%>\%
  filter(time_value > "2021-11-01", geo_value \%in\% c("ak", "ca", "ny"))
r <- epi_recipe(jhu) \%>\%
  step_epi_lag(death_rate, lag = c(0, 7, 14)) \%>\%
  step_epi_ahead(death_rate, ahead = 7) \%>\%
  step_epi_naomit()

wf <- epi_workflow(r, linear_reg()) \%>\% fit(jhu)

# Use ahead + forecast date
f <- frosting() \%>\%
  layer_predict() \%>\%
  layer_add_forecast_date(forecast_date = as.Date("2022-05-31")) \%>\%
  layer_add_target_date() \%>\%
  layer_naomit(.pred)
wf1 <- wf \%>\% add_frosting(f)

p <- forecast(wf1)
p

# Use ahead + forecast_date from adjust_latency
# setting the `as_of` to something realistic
attributes(jhu)$metadata$as_of <- max(jhu$time_value) + 3
r <- epi_recipe(jhu) \%>\%
  step_epi_lag(death_rate, lag = c(0, 7, 14)) \%>\%
  step_epi_ahead(death_rate, ahead = 7) \%>\%
  step_adjust_latency(method = "extend_ahead") \%>\%
  step_epi_naomit()
f2 <- frosting() \%>\%
  layer_predict() \%>\%
  layer_add_target_date() \%>\%
  layer_naomit(.pred)
wf2 <- wf \%>\% add_frosting(f2)

p2 <- forecast(wf2)
p2

# Use ahead + max time value from pre, fit, post
# which is the same if include `layer_add_forecast_date()`
f3 <- frosting() \%>\%
  layer_predict() \%>\%
  layer_add_target_date() \%>\%
  layer_naomit(.pred)
wf3 <- wf \%>\% add_frosting(f3)

p3 <- forecast(wf2)
p2

# Specify own target date
f4 <- frosting() \%>\%
  layer_predict() \%>\%
  layer_add_target_date(target_date = "2022-01-08") \%>\%
  layer_naomit(.pred)
wf4 <- wf \%>\% add_frosting(f4)

p4 <- forecast(wf4)
p4
}
