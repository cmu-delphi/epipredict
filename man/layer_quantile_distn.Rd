% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer_quantile_distn.R
\name{layer_quantile_distn}
\alias{layer_quantile_distn}
\title{Returns predictive quantiles}
\usage{
layer_quantile_distn(
  frosting,
  ...,
  quantile_levels = c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95),
  truncate = c(-Inf, Inf),
  name = ".pred_distn",
  id = rand_id("quantile_distn")
)
}
\arguments{
\item{frosting}{a \code{frosting} postprocessor}

\item{...}{Unused, include for consistency with other layers.}

\item{quantile_levels}{a vector of probabilities to extract}

\item{truncate}{Do we truncate the distribution to an interval}

\item{name}{character. The name for the output column.}

\item{id}{a random id string}
}
\value{
an updated \code{frosting} postprocessor. An additional column of predictive
quantiles will be added to the predictions.
}
\description{
This function calculates quantiles when the prediction was \emph{distributional}.
If the model producing the forecast is not distributional, it is recommended
to use \code{layer_residual_quantiles()} instead.
}
\details{
Currently, the only distributional modes/engines are
\itemize{
\item \code{quantile_reg()}
\item \code{smooth_quantile_reg()}
\item \code{rand_forest(mode = "regression") \%>\% set_engine("grf_quantiles")}
}

If these engines were used, then this layer will grab out estimated
(or extrapolated) quantiles at the requested quantile values.
}
\examples{
jhu <- covid_case_death_rates \%>\%
  filter(time_value > "2021-11-01", geo_value \%in\% c("ak", "ca", "ny"))

r <- epi_recipe(jhu) \%>\%
  step_epi_lag(death_rate, lag = c(0, 7, 14)) \%>\%
  step_epi_ahead(death_rate, ahead = 7) \%>\%
  step_epi_naomit()

wf <- epi_workflow(r, quantile_reg(quantile_levels = c(.25, .5, .75))) \%>\%
  fit(jhu)

f <- frosting() \%>\%
  layer_predict() \%>\%
  layer_quantile_distn() \%>\%
  layer_naomit(.pred)
wf1 <- wf \%>\% add_frosting(f)

p <- forecast(wf1)
p
}
