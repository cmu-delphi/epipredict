% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer_point_from_distn.R
\name{layer_point_from_distn}
\alias{layer_point_from_distn}
\title{Converts distributional forecasts to point forecasts}
\usage{
layer_point_from_distn(
  frosting,
  ...,
  type = c("median", "mean"),
  name = NULL,
  id = rand_id("point_from_distn")
)
}
\arguments{
\item{frosting}{a \code{frosting} postprocessor}

\item{...}{Unused, include for consistency with other layers.}

\item{type}{character. Either \code{mean} or \code{median}.}

\item{name}{character. The name for the output column. The default \code{NULL}
will overwrite the \code{.pred} column, removing the distribution information.}

\item{id}{a random id string}
}
\value{
an updated \code{frosting} postprocessor.
}
\description{
This function adds a postprocessing layer to extract a point forecast from
a distributional forecast. NOTE: With default arguments, this will remove
information, so one should usually call this AFTER \code{layer_quantile_distn()}
or set the \code{name} argument to something specific.
}
\examples{
library(dplyr)
jhu <- case_death_rate_subset \%>\%
  filter(time_value > "2021-11-01", geo_value \%in\% c("ak", "ca", "ny"))

r <- recipe(jhu) \%>\%
  step_epi_lag(death_rate, lag = c(0, 7, 14)) \%>\%
  step_epi_ahead(death_rate, ahead = 7) \%>\%
  step_epi_naomit()

wf <- epi_workflow(r, quantile_reg(quantile_levels = c(.25, .5, .75))) \%>\%
  fit(jhu)

f1 <- frosting() \%>\%
  layer_predict() \%>\%
  layer_quantile_distn() \%>\% # puts the other quantiles in a different col
  layer_point_from_distn() \%>\% # mutate `.pred` to contain only a point prediction
  layer_naomit(.pred)
wf1 <- wf \%>\% add_frosting(f1)

p1 <- forecast(wf1)
p1

f2 <- frosting() \%>\%
  layer_predict() \%>\%
  layer_point_from_distn() \%>\% # mutate `.pred` to contain only a point prediction
  layer_naomit(.pred)
wf2 <- wf \%>\% add_frosting(f2)

p2 <- forecast(wf2)
p2
}
