% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layers.R
\name{update.layer}
\alias{update.layer}
\title{Update post-processing \code{layer}}
\usage{
\method{update}{layer}(object, ...)
}
\arguments{
\item{object}{A post-processing \code{layer}.}

\item{...}{Key-value pairs where the keys match up with names of elements
in the layer, and the values are the new values to update the layer with.}
}
\description{
This \code{layer} method for \code{update()} takes named arguments as \code{...} whose values
will replace the elements of the same name in the actual post-processing layer.
Analogous to \code{update.step()} from the \code{recipes} package.
}
\examples{
library(dplyr)
jhu <- case_death_rate_subset \%>\%
  filter(time_value > "2021-11-01", geo_value \%in\% c("ak", "ca", "ny"))
r <- recipe(jhu) \%>\%
  step_epi_lag(death_rate, lag = c(0, 7, 14)) \%>\%
  step_epi_ahead(death_rate, ahead = 7) \%>\%
  step_epi_naomit()
wf <- epi_workflow(r, parsnip::linear_reg()) \%>\% fit(jhu)
latest <- jhu \%>\%
  filter(time_value >= max(time_value) - 14)

# Specify a `forecast_date` that is greater than or equal to `as_of` date
f <- frosting() \%>\%
  layer_predict() \%>\%
  layer_add_forecast_date(forecast_date = "2022-05-31") \%>\%
  layer_naomit(.pred)

wf1 <- wf \%>\% add_frosting(f)

p1 <- predict(wf1, latest)
p1

# Update forecast date
f$layers[[2]] <- update(f$layers[[2]], forecast_date = "2021-06-01")

# Need to still update workflow if only update a layer in frosting
wf2 <- wf \%>\% add_frosting(f)
wf2$post # Check that wf1 has update
p1 <- predict(wf2, latest)
p1
}
