% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer_unnest.R
\name{layer_unnest}
\alias{layer_unnest}
\title{Unnest prediction list-cols}
\usage{
layer_unnest(frosting, ..., id = rand_id("unnest"))
}
\arguments{
\item{frosting}{a \code{frosting} postprocessor}

\item{...}{<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> One or more unquoted
expressions separated by commas. Variable names can be used as if they
were positions in the data frame, so expressions like \code{x:y} can
be used to select a range of variables.}

\item{id}{a random id string}
}
\value{
an updated \code{frosting} postprocessor
}
\description{
For any model that produces forecasts for multiple outcomes, such as multiple
aheads, the resulting prediction is a list of forecasts inside a column of
the prediction tibble, which is not an ideal format. This layer "lengthens"
the result, moving each outcome to a separate row, in the same manner as
\code{tidyr::unnest()} would. At the moment, the only such engine is
\code{smooth_quantile_reg()}.
}
\examples{
jhu <- covid_case_death_rates \%>\%
  filter(time_value > "2021-11-01", geo_value \%in\% c("ak", "ca", "ny"))

aheads <- 1:7

r <- epi_recipe(jhu) \%>\%
  step_epi_lag(death_rate, lag = c(0, 7, 14)) \%>\%
  step_epi_ahead(death_rate, ahead = aheads) \%>\%
  step_epi_naomit()

wf <- epi_workflow(
  r,
  smooth_quantile_reg(
    quantile_levels = c(.05, .1, .25, .5, .75, .9, .95),
    outcome_locations = aheads
  )
) \%>\%
  fit(jhu)

f <- frosting() \%>\%
  layer_predict() \%>\%
  layer_naomit() \%>\%
  layer_unnest(.pred)

wf1 <- wf \%>\% add_frosting(f)

p <- forecast(wf1)
p
}
