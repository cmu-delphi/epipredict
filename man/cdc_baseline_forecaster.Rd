% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cdc_baseline_forecaster.R
\name{cdc_baseline_forecaster}
\alias{cdc_baseline_forecaster}
\title{Predict the future with the most recent value}
\usage{
cdc_baseline_forecaster(
  epi_data,
  outcome,
  args_list = cdc_baseline_args_list()
)
}
\arguments{
\item{epi_data}{An \code{\link[epiprocess:epi_df]{epiprocess::epi_df}}}

\item{outcome}{A scalar character for the column name we wish to predict.}

\item{args_list}{A list of additional arguments as created by the
\code{\link[=cdc_baseline_args_list]{cdc_baseline_args_list()}} constructor function.}
}
\value{
A data frame of point and interval forecasts for all aheads (unique
horizons) for each unique combination of \code{key_vars}.
}
\description{
This is a simple forecasting model for
\link[epiprocess:epi_df]{epiprocess::epi_df} data. It uses the most recent observation as the
forecast for any future date, and produces intervals by shuffling the quantiles
of the residuals of such a "flatline" forecast and incrementing these
forward over all available training data.
}
\details{
By default, the predictive intervals are computed separately for each
combination of \code{geo_value} in the \code{epi_data} argument.

This forecaster is meant to produce exactly the CDC Baseline used for
\href{https://covid19forecasthub.org}{COVID19ForecastHub}
}
\examples{
library(dplyr)
library(epiprocess)
weekly_deaths <- covid_case_death_rates \%>\%
  select(geo_value, time_value, death_rate) \%>\%
  left_join(state_census \%>\% select(pop, abbr), by = c("geo_value" = "abbr")) \%>\%
  mutate(deaths = pmax(death_rate / 1e5 * pop * 7, 0)) \%>\%
  select(-pop, -death_rate) \%>\%
  group_by(geo_value) \%>\%
  epi_slide(~ sum(.$deaths), .window_size = 7, .new_col_name = "deaths_7dsum") \%>\%
  ungroup() \%>\%
  filter(weekdays(time_value) == "Saturday")

cdc <- cdc_baseline_forecaster(weekly_deaths, "deaths_7dsum")
preds <- pivot_quantiles_wider(cdc$predictions, .pred_distn)

library(ggplot2)
forecast_date <- unique(preds$forecast_date)
four_states <- c("ca", "pa", "wa", "ny")
preds \%>\%
  filter(geo_value \%in\% four_states) \%>\%
  ggplot(aes(target_date)) +
  geom_ribbon(aes(ymin = `0.1`, ymax = `0.9`), fill = blues9[3]) +
  geom_ribbon(aes(ymin = `0.25`, ymax = `0.75`), fill = blues9[6]) +
  geom_line(aes(y = .pred), color = "orange") +
  geom_line(
    data = weekly_deaths \%>\% filter(geo_value \%in\% four_states),
    aes(x = time_value, y = deaths_7dsum)
  ) +
  scale_x_date(limits = c(forecast_date - 90, forecast_date + 30)) +
  labs(x = "Date", y = "Weekly deaths") +
  facet_wrap(~geo_value, scales = "free_y") +
  theme_bw() +
  geom_vline(xintercept = forecast_date)
}
