% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_grf_quantiles.R
\name{grf_quantiles}
\alias{grf_quantiles}
\title{Random quantile forests via grf}
\description{
\code{\link[grf:quantile_forest]{grf::quantile_forest()}} fits random forests in a way that makes it easy
to calculate \emph{quantile} forests. Currently, this is the only engine
provided here, since quantile regression is the typical use-case.
}
\section{Tuning Parameters}{


This model has 3 tuning parameters:
\itemize{
\item \code{mtry}: # Randomly Selected Predictors (type: integer, default: see below)
\item \code{trees}: # Trees (type: integer, default: 2000L)
\item \code{min_n}: Minimal Node Size (type: integer, default: 5)
}

\code{mtry} depends on the number of columns in the design matrix.
The default in \code{\link[grf:quantile_forest]{grf::quantile_forest()}} is \code{min(ceiling(sqrt(ncol(X)) + 20), ncol(X))}.

For categorical predictors, a one-hot encoding is always used. This makes
splitting efficient, but has implications for the \code{mtry} choice. A factor
with many levels will become a large number of columns in the design matrix
which means that some of these may be selected frequently for potential splits.
This is different than in other implementations of random forest. For more
details, see \href{https://grf-labs.github.io/grf/articles/categorical_inputs.html}{the \code{grf} discussion}.
}

\section{Translation from parsnip to the original package}{


\if{html}{\out{<div class="sourceCode r">}}\preformatted{rand_forest(
  mode = "regression", # you must specify the `mode = regression`
  mtry = integer(1),
  trees = integer(1),
  min_n = integer(1)
) \%>\%
  set_engine("grf_quantiles") \%>\%
  translate()
#> Random Forest Model Specification (regression)
#> 
#> Main Arguments:
#>   mtry = integer(1)
#>   trees = integer(1)
#>   min_n = integer(1)
#> 
#> Computational engine: grf_quantiles 
#> 
#> Model fit template:
#> grf::quantile_forest(X = missing_arg(), Y = missing_arg(), mtry = min_cols(~integer(1), 
#>     x), num.trees = integer(1), min.node.size = min_rows(~integer(1), 
#>     x), quantiles = c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95), 
#>     num.threads = 1L, seed = stats::runif(1, 0, .Machine$integer.max))
}\if{html}{\out{</div>}}
}

\section{Case weights}{


Case weights are not supported.
}

\examples{
library(grf)
tib <- data.frame(
  y = rnorm(100), x = rnorm(100), z = rnorm(100),
  f = factor(sample(letters[1:3], 100, replace = TRUE))
)
spec <- rand_forest(engine = "grf_quantiles", mode = "regression")
out <- fit(spec, formula = y ~ x + z, data = tib)
predict(out, new_data = tib[1:5, ]) \%>\%
  pivot_quantiles_wider(.pred)

# -- adjusting the desired quantiles

spec <- rand_forest(mode = "regression") \%>\%
  set_engine(engine = "grf_quantiles", quantiles = c(1:9 / 10))
out <- fit(spec, formula = y ~ x + z, data = tib)
predict(out, new_data = tib[1:5, ]) \%>\%
  pivot_quantiles_wider(.pred)

# -- a more complicated task

dat <- covid_case_death_rates \%>\%
  filter(time_value > as.Date("2021-10-01"))
rec <- epi_recipe(dat) \%>\%
  step_epi_lag(case_rate, death_rate, lag = c(0, 7, 14)) \%>\%
  step_epi_ahead(death_rate, ahead = 7) \%>\%
  step_epi_naomit()
frost <- frosting() \%>\%
  layer_predict() \%>\%
  layer_threshold(.pred)
spec <- rand_forest(mode = "regression") \%>\%
  set_engine(engine = "grf_quantiles", quantiles = c(.25, .5, .75))

ewf <- epi_workflow(rec, spec, frost) \%>\%
  fit(dat) \%>\%
  forecast()
ewf \%>\%
  rename(forecast_date = time_value) \%>\%
  mutate(target_date = forecast_date + 7L) \%>\%
  pivot_quantiles_wider(.pred)

}
