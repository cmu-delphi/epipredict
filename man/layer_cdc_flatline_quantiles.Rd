% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer_cdc_flatline_quantiles.R
\name{layer_cdc_flatline_quantiles}
\alias{layer_cdc_flatline_quantiles}
\title{CDC Flatline Forecast Quantiles}
\usage{
layer_cdc_flatline_quantiles(
  frosting,
  ...,
  aheads = 1:4,
  quantile_levels = c(0.01, 0.025, 1:19/20, 0.975, 0.99),
  nsims = 1000,
  by_key = "geo_value",
  symmetrize = FALSE,
  nonneg = TRUE,
  id = rand_id("cdc_baseline_bands")
)
}
\arguments{
\item{frosting}{a \code{frosting} postprocessor}

\item{...}{Unused, include for consistency with other layers.}

\item{aheads}{Numeric vector of desired forecast horizons. These should be
given in the "units of the training data". So, for example, for data
typically observed daily (possibly with missing values), but
with weekly forecast targets, you would use \code{c(7, 14, 21, 28)}. But with
weekly data, you would use \code{1:4}.}

\item{quantile_levels}{Numeric vector of probabilities with values in (0,1)
referring to the desired predictive intervals. The default is the standard
set for the COVID Forecast Hub.}

\item{nsims}{Positive integer. The number of draws from the empirical CDF.
These samples are spaced evenly on the (0, 1) scale, F_X(x) resulting
in linear interpolation on the X scale. This is achieved with
\code{\link[stats:quantile]{stats::quantile()}} Type 7 (the default for that function).}

\item{by_key}{A character vector of keys to group the residuals by before
calculating quantiles. The default, \code{c()} performs no grouping.}

\item{symmetrize}{Logical. If \code{TRUE}, does two things: (i) forces the
"empirical" CDF of residuals to be symmetric by pretending that for every
actually-observed residual X we also observed another residual -X, and (ii)
at each ahead, forces the median simulated value to be equal to the point
prediction by adding or subtracting the same amount to every simulated
value. Adjustments in (ii) take place before propagating forward and
simulating the next ahead. This forces any 1-ahead predictive intervals to
be symmetric about the point prediction, and encourages larger aheads to be
more symmetric.}

\item{nonneg}{Logical. Force all predictive intervals be non-negative.
Because non-negativity is forced \emph{before} propagating forward, this has
slightly different behaviour than would occur if using \code{\link[=layer_threshold]{layer_threshold()}}.
Thresholding at each ahead takes place after any shifting from
\code{symmetrize}.}

\item{id}{a random id string}
}
\value{
an updated \code{frosting} postprocessor. Calling \code{\link[=predict]{predict()}} will result
in an additional \verb{<list-col>} named \code{.pred_distn_all} containing 2-column
\code{\link[tibble:tibble]{tibble::tibble()}}'s. For each
desired combination of \code{key}'s, the tibble will contain one row per ahead
with the associated \code{\link[=dist_quantiles]{dist_quantiles()}}.
}
\description{
This layer creates quantile forecasts by taking a sample from the
interpolated CDF of the flatline residuals, and shuffling them.
These are then added on to the point prediction.
}
\details{
This layer is intended to be used in concert with \code{\link[=flatline]{flatline()}}. But it can
also be used with anything else. As long as residuals are available in the
the fitted model, this layer could be useful. Like
\code{\link[=layer_residual_quantiles]{layer_residual_quantiles()}} it only uses the residuals for the fitted model
object. However, it propagates these forward for \emph{all} aheads, by
iteratively shuffling them (randomly), and then adding them to the previous
set. This is in contrast to what happens with the \code{\link[=flatline_forecaster]{flatline_forecaster()}}.
When using \code{\link[=flatline]{flatline()}} as the underlying engine (here), both will result in the
same predictions (the most recent observed value), but that model calculates
separate residuals for each \code{ahead} by comparing to observations further into
the future. This version continues to use the same set of residuals, and
adds them on to produce wider intervals as \code{ahead} increases.
}
\examples{
r <- epi_recipe(case_death_rate_subset) \%>\%
  # data is "daily", so we fit this to 1 ahead, the result will contain
  # 1 day ahead residuals
  step_epi_ahead(death_rate, ahead = 1L, skip = TRUE) \%>\%
  recipes::update_role(death_rate, new_role = "predictor") \%>\%
  recipes::add_role(time_value, geo_value, new_role = "predictor")

forecast_date <- max(case_death_rate_subset$time_value)

latest <- get_test_data(
  epi_recipe(case_death_rate_subset), case_death_rate_subset
)

f <- frosting() \%>\%
  layer_predict() \%>\%
  layer_cdc_flatline_quantiles(aheads = c(7, 14, 21, 28), symmetrize = TRUE)

eng <- parsnip::linear_reg() \%>\% parsnip::set_engine("flatline")

wf <- epi_workflow(r, eng, f) \%>\% fit(case_death_rate_subset)
preds <- suppressWarnings(predict(wf, new_data = latest)) \%>\%
  dplyr::select(-time_value) \%>\%
  dplyr::mutate(forecast_date = forecast_date)
preds

preds <- preds \%>\%
  unnest(.pred_distn_all) \%>\%
  pivot_quantiles(.pred_distn) \%>\%
  mutate(target_date = forecast_date + ahead)

if (require("ggplot2")) {
four_states <- c("ca", "pa", "wa", "ny")
preds \%>\%
  filter(geo_value \%in\% four_states) \%>\%
  ggplot(aes(target_date)) +
  geom_ribbon(aes(ymin = `0.1`, ymax = `0.9`), fill = blues9[3]) +
  geom_ribbon(aes(ymin = `0.25`, ymax = `0.75`), fill = blues9[6]) +
  geom_line(aes(y = .pred), color = "orange") +
  geom_line(
    data = case_death_rate_subset \%>\% filter(geo_value \%in\% four_states),
    aes(x = time_value, y = death_rate)
  ) +
  scale_x_date(limits = c(forecast_date - 90, forecast_date + 30)) +
  labs(x = "Date", y = "Death rate") +
  facet_wrap(~geo_value, scales = "free_y") +
  theme_bw() +
  geom_vline(xintercept = forecast_date)
}
}
