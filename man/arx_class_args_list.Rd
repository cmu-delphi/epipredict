% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/arx_classifier.R
\name{arx_class_args_list}
\alias{arx_class_args_list}
\title{ARX classifier argument constructor}
\usage{
arx_class_args_list(
  lags = c(0L, 7L, 14L),
  ahead = 7L,
  n_training = Inf,
  forecast_date = NULL,
  target_date = NULL,
  adjust_latency = NULL,
  outcome_transform = c("growth_rate", "lag_difference"),
  breaks = 0.25,
  horizon = 7L,
  method = c("rel_change", "linear_reg"),
  log_scale = FALSE,
  additional_gr_args = list(),
  check_enough_data_n = NULL,
  check_enough_data_epi_keys = NULL,
  ...
)
}
\arguments{
\item{lags}{Vector or List. Positive integers enumerating lags to use
in autoregressive-type models (in days). By default, an unnamed list
of lags will be set to correspond to the order of the predictors.}

\item{ahead}{Integer. Number of time steps ahead (in days) of the forecast
date for which forecasts should be produced.}

\item{n_training}{Integer. An upper limit for the number of rows per
key that are used for training
(in the time unit of the \code{epi_df}).}

\item{forecast_date}{Date. The date on which the forecast is created.  The
default \code{NULL} will attempt to determine this automatically either as the
max time value if there is no latency adjustment, or as the \code{as_of} of
\code{epi_data} if \code{adjust_latency} is non-\code{NULL}.}

\item{target_date}{Date. The date for which the forecast is intended. The
default \code{NULL} will attempt to determine this automatically as
\code{forecast_date + ahead}.}

\item{adjust_latency}{Character or \code{NULL}. One of the \code{method}s of
\code{\link[=step_adjust_latency]{step_adjust_latency()}}, or \code{NULL} (in which case there is no adjustment).
If there is a difference between the \code{forecast_date} and the last day of
data, this determines how to shift the model to account for this
difference. The options are:
\itemize{
\item \code{NULL} the default, assumes the \code{forecast_date} is the last day of data
\item \code{"extend_ahead"}: increase the \code{ahead} by the latency so it's relative to
the last day of data. If the last day of data was 3 days ago, the ahead
becomes \code{ahead+3}.
\item \code{"extend_lags"}: increase the lags so they're relative to the actual forecast date. If the lags are
\code{c(0,7,14)} and the last day of data was 3 days ago, the lags become
\code{c(3,10,17)}.
}}

\item{outcome_transform}{Scalar character. Whether the outcome should
be created using growth rates (as the predictors are) or lagged
differences. The second case is closer to the requirements for the
\href{https://github.com/cdcepi/Flusight-forecast-data/blob/745511c436923e1dc201dea0f4181f21a8217b52/data-experimental/README.md}{2022-23 CDC Flusight Hospitalization Experimental Target}.
See the Classification Vignette for details of how to create a reasonable
baseline for this case. Selecting \code{"growth_rate"} (the default) uses
\code{\link[epiprocess:growth_rate]{epiprocess::growth_rate()}} to create the outcome using some of the
additional arguments below. Choosing \code{"lag_difference"} instead simply
uses the change from the value at the selected \code{horizon}.}

\item{breaks}{Vector. A vector of breaks to turn real-valued growth rates
into discrete classes. The default gives binary upswing classification
as in \href{https://doi.org/10.1073/pnas.2111453118}{McDonald, Bien, Green, Hu, et al.}.
This coincides with the default \code{trainer = parsnip::logistic_reg()}
argument in \code{\link[=arx_classifier]{arx_classifier()}}. However, multiclass classification is also
supported (e.g. with \code{breaks = c(-.2, .25)}) provided that
\code{trainer = parsnip::multinom_reg()} (or another multiclass trainer)
is used as well. These will be sliently expanded to cover the entire
real line (so the default will become \code{breaks = c(-Inf, .25, Inf)}) before
being used to discretize the response. This is different than the
behaviour in \code{\link[recipes:step_cut]{recipes::step_cut()}} which creates classes that only cover
the range of the training data.}

\item{horizon}{Scalar integer. This is passed to the \code{h} argument of
\code{\link[epiprocess:growth_rate]{epiprocess::growth_rate()}}. It determines the amount of data used to
calculate the growth rate.}

\item{method}{Character. Options available for growth rate calculation.}

\item{log_scale}{Scalar logical. Whether to compute growth rates on the
log scale.}

\item{additional_gr_args}{List. Optional arguments controlling growth rate
calculation. See \code{\link[epiprocess:growth_rate]{epiprocess::growth_rate()}} and the related Vignette for
more details.}

\item{check_enough_data_n}{Integer. A lower limit for the number of rows per
epi_key that are required for training. If \code{NULL}, this check is ignored.}

\item{check_enough_data_epi_keys}{Character vector. A character vector of
column names on which to group the data and check threshold within each
group. Useful if training per group (for example, per geo_value).}

\item{...}{Space to handle future expansions (unused).}
}
\value{
A list containing updated parameter choices with class \code{arx_clist}.
}
\description{
Constructs a list of arguments for \code{\link[=arx_classifier]{arx_classifier()}}.
}
\examples{
arx_class_args_list()

# 3-class classsification,
# also needs arx_classifier(trainer = parsnip::multinom_reg())
arx_class_args_list(breaks = c(-.2, .25))
}
