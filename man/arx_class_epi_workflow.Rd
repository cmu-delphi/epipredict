% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/arx_classifier.R
\name{arx_class_epi_workflow}
\alias{arx_class_epi_workflow}
\title{Create a template \code{arx_classifier} workflow}
\usage{
arx_class_epi_workflow(
  epi_data,
  outcome,
  predictors,
  trainer = parsnip::logistic_reg(),
  args_list = arx_class_args_list()
)
}
\arguments{
\item{epi_data}{An \code{epi_df} object}

\item{outcome}{A character (scalar) specifying the outcome (in the
\code{epi_df}). Note that as with \code{\link[=arx_forecaster]{arx_forecaster()}}, this is expected to
be real-valued. Conversion of this data to unordered classes is handled
internally based on the \code{breaks} argument to \code{\link[=arx_class_args_list]{arx_class_args_list()}}.
If discrete classes are already in the \code{epi_df}, it is recommended to
code up a classifier from scratch using \code{\link[=epi_recipe]{epi_recipe()}}.}

\item{predictors}{A character vector giving column(s) of predictor variables.
This defaults to the \code{outcome}. However, if manually specified, only those
variables specifically mentioned will be used. (The \code{outcome} will not be
added.)  By default, equals the outcome. If manually specified, does not
add the outcome variable, so make sure to specify it.}

\item{trainer}{A \code{{parsnip}} model describing the type of estimation. For
now, we enforce \code{mode = "classification"}. Typical values are
\code{\link[parsnip:logistic_reg]{parsnip::logistic_reg()}} or \code{\link[parsnip:multinom_reg]{parsnip::multinom_reg()}}. More complicated
trainers like \code{\link[parsnip:naive_Bayes]{parsnip::naive_Bayes()}} or \code{\link[parsnip:rand_forest]{parsnip::rand_forest()}} can also
be used. May be \code{NULL} if you'd like to decide later.}

\item{args_list}{A list of customization arguments to determine
the type of forecasting model. See \code{\link[=arx_class_args_list]{arx_class_args_list()}}.}
}
\value{
An unfit \code{epi_workflow}.
}
\description{
This function creates an unfit workflow for use with \code{\link[=arx_classifier]{arx_classifier()}}.
It is useful if you want to make small modifications to that classifier
before fitting and predicting. Supplying a trainer to the function
may alter the returned \code{epi_workflow} object but can be omitted.
}
\examples{
jhu <- covid_case_death_rates \%>\%
  filter(time_value >= as.Date("2021-11-01"))

arx_class_epi_workflow(jhu, "death_rate", c("case_rate", "death_rate"))

arx_class_epi_workflow(
  jhu,
  "death_rate",
  c("case_rate", "death_rate"),
  trainer = multinom_reg(),
  args_list = arx_class_args_list(
    breaks = c(-.05, .1), ahead = 14,
    horizon = 14, method = "linear_reg"
  )
)
}
\seealso{
\code{\link[=arx_classifier]{arx_classifier()}} \code{\link[=arx_class_args_list]{arx_class_args_list()}}
}
