% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step_population_scaling.R
\name{step_population_scaling}
\alias{step_population_scaling}
\title{Convert raw scale predictions to per-capita}
\usage{
step_population_scaling(
  recipe,
  ...,
  role = "raw",
  df,
  by = NULL,
  df_pop_col,
  rate_rescaling = 1,
  create_new = TRUE,
  suffix = "_scaled",
  skip = FALSE,
  id = rand_id("population_scaling")
)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the
sequence of operations for this recipe.}

\item{...}{One or more selector functions to choose variables
for this step. See \code{\link[recipes:selections]{recipes::selections()}} for more details.}

\item{role}{For model terms created by this step, what analysis role should
they be assigned? \code{lag} is default a predictor while \code{ahead} is an outcome.}

\item{df}{a data frame that contains the population data to be used for
inverting the existing scaling.}

\item{by}{A (possibly named) character vector of variables to join by.

If \code{NULL}, the default, the function will perform a natural join, using all
variables in common across the \code{epi_df} produced by the \code{predict()} call
and the user-provided dataset.
If columns in that \code{epi_df} and \code{df} have the same name (and aren't
included in \code{by}), \code{.df} is added to the one from the user-provided data
to disambiguate.

To join by different variables on the \code{epi_df} and \code{df}, use a named vector.
For example, \code{by = c("geo_value" = "states")} will match \code{epi_df$geo_value}
to \code{df$states}. To join by multiple variables, use a vector with length > 1.
For example, \code{by = c("geo_value" = "states", "county" = "county")} will match
\code{epi_df$geo_value} to \code{df$states} and \code{epi_df$county} to \code{df$county}.

See \code{\link[dplyr:mutate-joins]{dplyr::left_join()}} for more details.}

\item{df_pop_col}{the name of the column in the data frame \code{df} that
contains the population data and will be used for scaling.
This should be one column.}

\item{rate_rescaling}{Sometimes raw scales are "per 100K" or "per 1M".
Adjustments can be made here. For example, if the original
scale is "per 100K", then set \code{rate_rescaling = 1e5} to get rates.}

\item{create_new}{TRUE to create a new column and keep the original column
in the \code{epi_df}}

\item{suffix}{a character. The suffix added to the column name if
\code{create_new = TRUE}. Default to "_scaled".}

\item{skip}{A logical. Should the step be skipped when the
recipe is baked by \code{\link[=bake]{bake()}}? While all operations are baked
when \code{\link[=prep]{prep()}} is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using \code{skip = TRUE} as it may affect
the computations for subsequent operations.}

\item{id}{A unique identifier for the step}
}
\value{
Scales raw data by the population
}
\description{
\code{step_population_scaling} creates a specification of a recipe step
that will perform per-capita scaling. Typical usage would
load a dataset that contains state-level population, and use it to convert
predictions made from a raw scale model to rate-scale by dividing by
the population.
Although, it is worth noting that there is nothing special about "population".
The function can be used to scale by any variable. Population is the
standard use case in the epidemiology forecasting scenario. Any value
passed will \emph{divide} the selected variables while the \code{rate_rescaling}
argument is a common \emph{multiplier} of the selected variables.
}
\examples{
library(dplyr)
jhu <- epidatasets::cases_deaths_subset \%>\%
  filter(time_value > "2021-11-01", geo_value \%in\% c("ca", "ny")) \%>\%
  select(geo_value, time_value, cases)

pop_data <- data.frame(states = c("ca", "ny"), value = c(20000, 30000))

r <- epi_recipe(jhu) \%>\%
  step_population_scaling(
    df = pop_data,
    df_pop_col = "value",
    by = c("geo_value" = "states"),
    cases, suffix = "_scaled"
  ) \%>\%
  step_epi_lag(cases_scaled, lag = c(0, 7, 14)) \%>\%
  step_epi_ahead(cases_scaled, ahead = 7, role = "outcome") \%>\%
  step_epi_naomit()

f <- frosting() \%>\%
  layer_predict() \%>\%
  layer_threshold(.pred) \%>\%
  layer_naomit(.pred) \%>\%
  layer_population_scaling(.pred,
    df = pop_data,
    by = c("geo_value" = "states"),
    df_pop_col = "value"
  )

wf <- epi_workflow(r, linear_reg()) \%>\%
  fit(jhu) \%>\%
  add_frosting(f)

forecast(wf)
}
