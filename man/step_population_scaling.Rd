% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step_population_scaling.R
\name{step_population_scaling}
\alias{step_population_scaling}
\title{Convert raw scale predictions to per-capita}
\usage{
step_population_scaling(
  recipe,
  ...,
  role = "raw",
  df,
  by = NULL,
  df_pop_col,
  rate_rescaling = 1,
  create_new = TRUE,
  suffix = "_scaled",
  skip = FALSE,
  id = rand_id("population_scaling")
)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the
sequence of operations for this recipe.}

\item{...}{One or more selector functions to choose variables
for this step. See \code{\link[recipes:selections]{recipes::selections()}} for more details.}

\item{role}{For model terms created by this step, what analysis role should
they be assigned?}

\item{df}{a data frame containing the scaling data (typically population). The
target column is divided by the value in \code{df_pop_col}.}

\item{by}{A (possibly named) character vector of variables by which to join
\code{df} to the \code{epi_df}.

If \code{NULL}, the default, the function will try to infer a reasonable set of
columns. First, it will try to join by all variables in the training/test
data with roles \code{"geo_value"}, \code{"key"}, or \code{"time_value"} that also appear in
\code{df}; these roles are automatically set if you are using an \code{epi_df}, or you
can use, e.g., \code{update_role}. If no such roles are set, it will try to
perform a natural join, using variables in common between the training/test
data and population data.

If columns in the training/testing data and \code{df} have the same name (and
aren't included in \code{by}), a \code{.df} suffix is added to the one from the
user-provided data to disambiguate.

To join by different variables on the \code{epi_df} and \code{df}, use a named vector.
For example, \code{by = c("geo_value" = "states")} will match \code{epi_df$geo_value}
to \code{df$states}. To join by multiple variables, use a vector with length > 1.
For example, \code{by = c("geo_value" = "states", "county" = "county")} will match
\code{epi_df$geo_value} to \code{df$states} and \code{epi_df$county} to \code{df$county}.

See \code{\link[dplyr:mutate-joins]{dplyr::inner_join()}} for more details.}

\item{df_pop_col}{the name of the column in the data frame \code{df} that
contains the population data and will be used for scaling.
This should be one column.}

\item{rate_rescaling}{Sometimes raw scales are "per 100K" or "per 1M".
Adjustments can be made here. For example, if the original
scale is "per 100K", then set \code{rate_rescaling = 1e5} to get rates.}

\item{create_new}{\code{TRUE} to create a new column and keep the original column
in the \code{epi_df}}

\item{suffix}{a character. The suffix added to the column name if
\code{create_new = TRUE}. Default to "_scaled".}

\item{skip}{A logical. Should the step be skipped when the
recipe is baked by \code{\link[=bake]{bake()}}? While all operations are baked
when \code{\link[=prep]{prep()}} is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using \code{skip = TRUE} as it may affect
the computations for subsequent operations.}

\item{id}{A unique identifier for the step}
}
\value{
Scales raw data by the population
}
\description{
\code{step_population_scaling()} creates a specification of a recipe step that
will perform per-capita scaling. Typical usage would set \code{df} to be a dataset
that contains population for each \code{geo_value}, and use it to convert
predictions made from a raw scale model to rate-scale by dividing by the
population.  Although, it is worth noting that there is nothing special about
"population", and the function can be used to scale by any variable.
Population is the standard use case in the epidemiology forecasting scenario.
Any value passed will \emph{divide} the selected variables while the
\code{rate_rescaling} argument is a common \emph{multiplier} of the selected variables.
}
\examples{
jhu <- cases_deaths_subset \%>\%
  filter(time_value > "2021-11-01", geo_value \%in\% c("ca", "ny")) \%>\%
  select(geo_value, time_value, cases)

pop_data <- data.frame(states = c("ca", "ny"), value = c(20000, 30000))

r <- epi_recipe(jhu) \%>\%
  step_population_scaling(
    df = pop_data,
    df_pop_col = "value",
    by = c("geo_value" = "states"),
    cases, suffix = "_scaled"
  ) \%>\%
  step_epi_lag(cases_scaled, lag = c(0, 7, 14)) \%>\%
  step_epi_ahead(cases_scaled, ahead = 7, role = "outcome") \%>\%
  step_epi_naomit()

f <- frosting() \%>\%
  layer_predict() \%>\%
  layer_threshold(.pred) \%>\%
  layer_naomit(.pred) \%>\%
  layer_population_scaling(.pred,
    df = pop_data,
    by = c("geo_value" = "states"),
    df_pop_col = "value"
  )

wf <- epi_workflow(r, linear_reg()) \%>\%
  fit(jhu) \%>\%
  add_frosting(f)

forecast(wf)
}
