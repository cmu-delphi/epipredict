% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer_population_scaling.R
\name{layer_population_scaling}
\alias{layer_population_scaling}
\title{Convert per-capita predictions to raw scale}
\usage{
layer_population_scaling(
  frosting,
  ...,
  df,
  by = NULL,
  df_pop_col,
  rate_rescaling = 1,
  create_new = TRUE,
  suffix = "_scaled",
  id = rand_id("population_scaling")
)
}
\arguments{
\item{frosting}{a \code{frosting} postprocessor. The layer will be added to the
sequence of operations for this frosting.}

\item{...}{One or more selector functions to scale variables
for this step. See \code{\link[recipes:selections]{recipes::selections()}} for more details.}

\item{df}{a data frame that contains the population data to be used for
inverting the existing scaling.}

\item{by}{A (possibly named) character vector of variables to join \code{df} onto
the \code{epi_df} by.

If \code{NULL}, the default, the function will try to infer a reasonable set of
columns. First, it will try to join by all variables in the test data with
roles \code{"geo_value"}, \code{"key"}, or \code{"time_value"} that also appear in \code{df};
these roles are automatically set if you are using an \code{epi_df}, or you can
use, e.g., \code{update_role}. If no such roles are set, it will try to perform a
natural join, using variables in common between the training/test data and
population data.

If columns in the training/testing data and \code{df} have the same name (and
aren't included in \code{by}), a \code{.df} suffix is added to the one from the
user-provided data to disambiguate.

To join by different variables on the \code{epi_df} and \code{df}, use a named vector.
For example, \code{by = c("geo_value" = "states")} will match \code{epi_df$geo_value}
to \code{df$states}. To join by multiple variables, use a vector with length > 1.
For example, \code{by = c("geo_value" = "states", "county" = "county")} will match
\code{epi_df$geo_value} to \code{df$states} and \code{epi_df$county} to \code{df$county}.

See \code{\link[dplyr:mutate-joins]{dplyr::left_join()}} for more details.}

\item{df_pop_col}{the name of the column in the data frame \code{df} that
contains the population data and used for scaling.}

\item{rate_rescaling}{Sometimes rates are "per 100K" or "per 1M" rather than
"per person". Adjustments can be made here. For example, if the original
rate is "per 100K", then set \code{rate_rescaling = 1e5} to get counts back.}

\item{create_new}{TRUE to create a new column and keep the original column
in the \code{epi_df}.}

\item{suffix}{a character. The suffix added to the column name if
\code{create_new = TRUE}. Default to "_scaled".}

\item{id}{a random id string}
}
\value{
an updated \code{frosting} postprocessor
}
\description{
\code{layer_population_scaling} creates a specification of a frosting layer that
will "undo" per-capita scaling done in \code{step_population_scaling()}.
Typical usage would set \code{df} to be a dataset that contains a list of
population for the \code{geo_value}s, and use it to convert predictions made from
a raw scale model to rate-scale by dividing by the population.
Although, it is worth noting that there is nothing special about
"population", and  the function can be used to scale by any variable.
Population is the standard use case in the epidemiology forecasting scenario.
Any value passed will \emph{multiply} the selected variables while the
\code{rate_rescaling} argument is a common \emph{divisor} of the selected variables.
}
\examples{
jhu <- cases_deaths_subset \%>\%
  filter(time_value > "2021-11-01", geo_value \%in\% c("ca", "ny")) \%>\%
  select(geo_value, time_value, cases)

pop_data <- data.frame(states = c("ca", "ny"), value = c(20000, 30000))

r <- epi_recipe(jhu) \%>\%
  step_population_scaling(
    df = pop_data,
    df_pop_col = "value",
    by = c("geo_value" = "states"),
    cases, suffix = "_scaled"
  ) \%>\%
  step_epi_lag(cases_scaled, lag = c(0, 7, 14)) \%>\%
  step_epi_ahead(cases_scaled, ahead = 7, role = "outcome") \%>\%
  step_epi_naomit()

f <- frosting() \%>\%
  layer_predict() \%>\%
  layer_threshold(.pred) \%>\%
  layer_naomit(.pred) \%>\%
  layer_population_scaling(.pred,
    df = pop_data,
    by = c("geo_value" = "states"),
    df_pop_col = "value"
  )

wf <- epi_workflow(r, linear_reg()) \%>\%
  fit(jhu) \%>\%
  add_frosting(f)

forecast(wf)
}
